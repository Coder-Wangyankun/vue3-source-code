{"version":3,"file":"compiler-dom.esm-browser.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/codeframe.ts","../../shared/src/normalizeProp.ts","../../shared/src/domTagConfig.ts","../../shared/src/index.ts","../../compiler-core/src/errors.ts","../../compiler-core/src/runtimeHelpers.ts","../../compiler-core/src/ast.ts","../../compiler-core/src/utils.ts","../../compiler-core/src/compat/compatConfig.ts","../../compiler-core/src/parse.ts","../../compiler-core/src/transforms/hoistStatic.ts","../../compiler-core/src/transform.ts","../../compiler-core/src/codegen.ts","../../compiler-core/src/babelUtils.ts","../../compiler-core/src/transforms/transformExpression.ts","../../compiler-core/src/transforms/vIf.ts","../../compiler-core/src/transforms/vFor.ts","../../compiler-core/src/transforms/vSlot.ts","../../compiler-core/src/transforms/transformElement.ts","../../compiler-core/src/transforms/transformSlotOutlet.ts","../../compiler-core/src/transforms/vOn.ts","../../compiler-core/src/transforms/vBind.ts","../../compiler-core/src/transforms/transformText.ts","../../compiler-core/src/transforms/vOnce.ts","../../compiler-core/src/transforms/vModel.ts","../../compiler-core/src/compat/transformFilter.ts","../../compiler-core/src/transforms/vMemo.ts","../../compiler-core/src/compile.ts","../../compiler-core/src/transforms/noopDirectiveTransform.ts","../src/runtimeHelpers.ts","../src/decodeHtmlBrowser.ts","../src/parserOptions.ts","../src/transforms/transformStyle.ts","../src/errors.ts","../src/transforms/vHtml.ts","../src/transforms/vOn.ts","../src/transforms/ignoreSideEffectTags.ts","../src/index.ts","../src/transforms/vText.ts","../src/transforms/vModel.ts","../src/transforms/vShow.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean\r\n): (key: string) => boolean {\r\n  const map: Record<string, boolean> = Object.create(null)\r\n  const list: Array<string> = str.split(',')\r\n  for (let i = 0; i < list.length; i++) {\r\n    map[list[i]] = true\r\n  }\r\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\r\n}\r\n","const range: number = 2\r\n\r\nexport function generateCodeFrame(\r\n  source: string,\r\n  start = 0,\r\n  end = source.length\r\n): string {\r\n  // Split the content into individual lines but capture the newline sequence\r\n  // that separated each line. This is important because the actual sequence is\r\n  // needed to properly take into account the full line length for offset\r\n  // comparison\r\n  let lines = source.split(/(\\r?\\n)/)\r\n\r\n  // Separate the lines and newline sequences into separate arrays for easier referencing\r\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1)\r\n  lines = lines.filter((_, idx) => idx % 2 === 0)\r\n\r\n  let count = 0\r\n  const res: string[] = []\r\n  for (let i = 0; i < lines.length; i++) {\r\n    count +=\r\n      lines[i].length +\r\n      ((newlineSequences[i] && newlineSequences[i].length) || 0)\r\n    if (count >= start) {\r\n      for (let j = i - range; j <= i + range || end > count; j++) {\r\n        if (j < 0 || j >= lines.length) continue\r\n        const line = j + 1\r\n        res.push(\r\n          `${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${\r\n            lines[j]\r\n          }`\r\n        )\r\n        const lineLength = lines[j].length\r\n        const newLineSeqLength =\r\n          (newlineSequences[j] && newlineSequences[j].length) || 0\r\n\r\n        if (j === i) {\r\n          // push underline\r\n          const pad = start - (count - (lineLength + newLineSeqLength))\r\n          const length = Math.max(\r\n            1,\r\n            end > count ? lineLength - pad : end - start\r\n          )\r\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\r\n        } else if (j > i) {\r\n          if (end > count) {\r\n            const length = Math.max(Math.min(end - count, lineLength), 1)\r\n            res.push(`   |  ` + '^'.repeat(length))\r\n          }\r\n\r\n          count += lineLength + newLineSeqLength\r\n        }\r\n      }\r\n      break\r\n    }\r\n  }\r\n  return res.join('\\n')\r\n}\r\n","import { isArray, isString, isObject, hyphenate } from './'\r\nimport { isNoUnitNumericStyleProp } from './domAttrConfig'\r\n\r\nexport type NormalizedStyle = Record<string, string | number>\r\n\r\nexport function normalizeStyle(\r\n  value: unknown\r\n): NormalizedStyle | string | undefined {\r\n  if (isArray(value)) {\r\n    const res: NormalizedStyle = {}\r\n    for (let i = 0; i < value.length; i++) {\r\n      const item = value[i]\r\n      const normalized = isString(item)\r\n        ? parseStringStyle(item)\r\n        : (normalizeStyle(item) as NormalizedStyle)\r\n      if (normalized) {\r\n        for (const key in normalized) {\r\n          res[key] = normalized[key]\r\n        }\r\n      }\r\n    }\r\n    return res\r\n  } else if (isString(value)) {\r\n    return value\r\n  } else if (isObject(value)) {\r\n    return value\r\n  }\r\n}\r\n\r\nconst listDelimiterRE = /;(?![^(]*\\))/g\r\nconst propertyDelimiterRE = /:(.+)/\r\n\r\nexport function parseStringStyle(cssText: string): NormalizedStyle {\r\n  const ret: NormalizedStyle = {}\r\n  cssText.split(listDelimiterRE).forEach(item => {\r\n    if (item) {\r\n      const tmp = item.split(propertyDelimiterRE)\r\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())\r\n    }\r\n  })\r\n  return ret\r\n}\r\n\r\nexport function stringifyStyle(\r\n  styles: NormalizedStyle | string | undefined\r\n): string {\r\n  let ret = ''\r\n  if (!styles || isString(styles)) {\r\n    return ret\r\n  }\r\n  for (const key in styles) {\r\n    const value = styles[key]\r\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)\r\n    if (\r\n      isString(value) ||\r\n      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))\r\n    ) {\r\n      // only render valid values\r\n      ret += `${normalizedKey}:${value};`\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function normalizeClass(value: unknown): string {\r\n  let res = ''\r\n  if (isString(value)) {\r\n    res = value\r\n  } else if (isArray(value)) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      const normalized = normalizeClass(value[i])\r\n      if (normalized) {\r\n        res += normalized + ' '\r\n      }\r\n    }\r\n  } else if (isObject(value)) {\r\n    for (const name in value) {\r\n      if (value[name]) {\r\n        res += name + ' '\r\n      }\r\n    }\r\n  }\r\n  return res.trim()\r\n}\r\n\r\nexport function normalizeProps(props: Record<string, any> | null) {\r\n  if (!props) return null\r\n  let { class: klass, style } = props\r\n  if (klass && !isString(klass)) {\r\n    props.class = normalizeClass(klass)\r\n  }\r\n  if (style) {\r\n    props.style = normalizeStyle(style)\r\n  }\r\n  return props\r\n}\r\n","// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// must be extracted in shared to avoid creating a dependency between the two.\r\nimport { makeMap } from './makeMap'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS =\r\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n  'option,output,progress,select,textarea,details,dialog,menu,' +\r\n  'summary,template,blockquote,iframe,tfoot'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS =\r\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n  'text,textPath,title,tspan,unknown,use,view'\r\n\r\nconst VOID_TAGS =\r\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\r\n\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\r\n","import { makeMap } from './makeMap'\r\n\r\nexport { makeMap }\r\nexport * from './patchFlags'\r\nexport * from './shapeFlags'\r\nexport * from './slotFlags'\r\nexport * from './globalsWhitelist'\r\nexport * from './codeframe'\r\nexport * from './normalizeProp'\r\nexport * from './domTagConfig'\r\nexport * from './domAttrConfig'\r\nexport * from './escapeHtml'\r\nexport * from './looseEqual'\r\nexport * from './toDisplayString'\r\nexport * from './typeUtils'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nconst onRE = /^on[^a-z]/\r\nexport const isOn = (key: string) => onRE.test(key)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date => toTypeString(val) === '[object Date]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as any\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase()\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(\r\n  (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction((str: string) =>\r\n  str ? `on${capitalize(str)}` : ``\r\n)\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value\r\n  })\r\n}\r\n\r\nexport const toNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n        ? self\r\n        : typeof window !== 'undefined'\r\n        ? window\r\n        : typeof global !== 'undefined'\r\n        ? global\r\n        : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n","import { SourceLocation } from './ast'\r\n\r\nexport interface CompilerError extends SyntaxError {\r\n  code: number | string\r\n  loc?: SourceLocation\r\n}\r\n\r\nexport interface CoreCompilerError extends CompilerError {\r\n  code: ErrorCodes\r\n}\r\n\r\nexport function defaultOnError(error: CompilerError) {\r\n  throw error\r\n}\r\n\r\nexport function defaultOnWarn(msg: CompilerError) {\r\n  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)\r\n}\r\n\r\ntype InferCompilerError<T> = T extends ErrorCodes\r\n  ? CoreCompilerError\r\n  : CompilerError\r\n\r\nexport function createCompilerError<T extends number>(\r\n  code: T,\r\n  loc?: SourceLocation,\r\n  messages?: { [code: number]: string },\r\n  additionalMessage?: string\r\n): InferCompilerError<T> {\r\n  const msg =\r\n    __DEV__ || !__BROWSER__\r\n      ? (messages || errorMessages)[code] + (additionalMessage || ``)\r\n      : code\r\n  const error = new SyntaxError(String(msg)) as InferCompilerError<T>\r\n  error.code = code\r\n  error.loc = loc\r\n  return error\r\n}\r\n\r\nexport const enum ErrorCodes {\r\n  // parse errors\r\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\r\n  CDATA_IN_HTML_CONTENT,\r\n  DUPLICATE_ATTRIBUTE,\r\n  END_TAG_WITH_ATTRIBUTES,\r\n  END_TAG_WITH_TRAILING_SOLIDUS,\r\n  EOF_BEFORE_TAG_NAME,\r\n  EOF_IN_CDATA,\r\n  EOF_IN_COMMENT,\r\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\r\n  EOF_IN_TAG,\r\n  INCORRECTLY_CLOSED_COMMENT,\r\n  INCORRECTLY_OPENED_COMMENT,\r\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\r\n  MISSING_ATTRIBUTE_VALUE,\r\n  MISSING_END_TAG_NAME,\r\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\r\n  NESTED_COMMENT,\r\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\r\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\r\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\r\n  UNEXPECTED_NULL_CHARACTER,\r\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\r\n  UNEXPECTED_SOLIDUS_IN_TAG,\r\n\r\n  // Vue-specific parse errors\r\n  X_INVALID_END_TAG,\r\n  X_MISSING_END_TAG,\r\n  X_MISSING_INTERPOLATION_END,\r\n  X_MISSING_DIRECTIVE_NAME,\r\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\r\n\r\n  // transform errors\r\n  X_V_IF_NO_EXPRESSION,\r\n  X_V_IF_SAME_KEY,\r\n  X_V_ELSE_NO_ADJACENT_IF,\r\n  X_V_FOR_NO_EXPRESSION,\r\n  X_V_FOR_MALFORMED_EXPRESSION,\r\n  X_V_FOR_TEMPLATE_KEY_PLACEMENT,\r\n  X_V_BIND_NO_EXPRESSION,\r\n  X_V_ON_NO_EXPRESSION,\r\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\r\n  X_V_SLOT_MIXED_SLOT_USAGE,\r\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\r\n  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\r\n  X_V_SLOT_MISPLACED,\r\n  X_V_MODEL_NO_EXPRESSION,\r\n  X_V_MODEL_MALFORMED_EXPRESSION,\r\n  X_V_MODEL_ON_SCOPE_VARIABLE,\r\n  X_INVALID_EXPRESSION,\r\n  X_KEEP_ALIVE_INVALID_CHILDREN,\r\n\r\n  // generic errors\r\n  X_PREFIX_ID_NOT_SUPPORTED,\r\n  X_MODULE_MODE_NOT_SUPPORTED,\r\n  X_CACHE_HANDLER_NOT_SUPPORTED,\r\n  X_SCOPE_ID_NOT_SUPPORTED,\r\n\r\n  // Special value for higher-order compilers to pick up the last code\r\n  // to avoid collision of error codes. This should always be kept as the last\r\n  // item.\r\n  __EXTEND_POINT__\r\n}\r\n\r\nexport const errorMessages: Record<ErrorCodes, string> = {\r\n  // parse errors\r\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\r\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\r\n    'CDATA section is allowed only in XML context.',\r\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\r\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\r\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\r\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\r\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\r\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\r\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\r\n    'Unexpected EOF in script.',\r\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\r\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\r\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\r\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\r\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\r\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\r\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\r\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\r\n    'Whitespace was expected.',\r\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\r\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\r\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\r\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\r\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\r\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\r\n    \"Attribute name cannot start with '='.\",\r\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\r\n    \"'<?' is allowed only in XML context.\",\r\n  [ErrorCodes.UNEXPECTED_NULL_CHARACTER]: `Unexpected null character.`,\r\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\r\n\r\n  // Vue-specific parse errors\r\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\r\n  [ErrorCodes.X_MISSING_END_TAG]: 'Element is missing end tag.',\r\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\r\n    'Interpolation end sign was not found.',\r\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\r\n    'End bracket for dynamic directive argument was not found. ' +\r\n    'Note that dynamic directive argument cannot contain spaces.',\r\n  [ErrorCodes.X_MISSING_DIRECTIVE_NAME]: 'Legal directive name was expected.',\r\n\r\n  // transform errors\r\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\r\n  [ErrorCodes.X_V_IF_SAME_KEY]: `v-if/else branches must use unique keys.`,\r\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\r\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\r\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\r\n  [ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT]: `<template v-for> key should be placed on the <template> tag.`,\r\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\r\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\r\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\r\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\r\n    `Mixed v-slot usage on both the component and nested <template>.` +\r\n    `When there are multiple named slots, all slots should use <template> ` +\r\n    `syntax to avoid scope ambiguity.`,\r\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\r\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN]:\r\n    `Extraneous children found when component already has explicitly named ` +\r\n    `default slot. These children will be ignored.`,\r\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\r\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\r\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\r\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Error parsing JavaScript expression: `,\r\n  [ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN]: `<KeepAlive> expects exactly one child component.`,\r\n\r\n  // generic errors\r\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\r\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`,\r\n  [ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\r\n  [ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED]: `\"scopeId\" option is only supported in module mode.`,\r\n\r\n  // just to fulfill types\r\n  [ErrorCodes.__EXTEND_POINT__]: ``\r\n}\r\n","export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\r\nexport const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)\r\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\r\nexport const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)\r\nexport const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)\r\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\r\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\r\nexport const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)\r\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\r\nexport const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)\r\nexport const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)\r\nexport const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)\r\nexport const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)\r\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\r\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\r\n  __DEV__ ? `resolveDynamicComponent` : ``\r\n)\r\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\r\nexport const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)\r\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\r\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\r\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\r\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\r\nexport const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)\r\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\r\nexport const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)\r\nexport const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)\r\nexport const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)\r\nexport const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)\r\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\r\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\r\nexport const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)\r\nexport const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)\r\nexport const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)\r\nexport const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)\r\nexport const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)\r\nexport const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)\r\nexport const UNREF = Symbol(__DEV__ ? `unref` : ``)\r\nexport const IS_REF = Symbol(__DEV__ ? `isRef` : ``)\r\nexport const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)\r\nexport const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)\r\n\r\n// Name mapping for runtime helpers that need to be imported from 'vue' in\r\n// generated code. Make sure these are correctly exported in the runtime!\r\n// Using `any` here because TS doesn't allow symbols as index type.\r\nexport const helperNameMap: any = {\r\n  [FRAGMENT]: `Fragment`,\r\n  [TELEPORT]: `Teleport`,\r\n  [SUSPENSE]: `Suspense`,\r\n  [KEEP_ALIVE]: `KeepAlive`,\r\n  [BASE_TRANSITION]: `BaseTransition`,\r\n  [OPEN_BLOCK]: `openBlock`,\r\n  [CREATE_BLOCK]: `createBlock`,\r\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\r\n  [CREATE_VNODE]: `createVNode`,\r\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\r\n  [CREATE_COMMENT]: `createCommentVNode`,\r\n  [CREATE_TEXT]: `createTextVNode`,\r\n  [CREATE_STATIC]: `createStaticVNode`,\r\n  [RESOLVE_COMPONENT]: `resolveComponent`,\r\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n  [RESOLVE_FILTER]: `resolveFilter`,\r\n  [WITH_DIRECTIVES]: `withDirectives`,\r\n  [RENDER_LIST]: `renderList`,\r\n  [RENDER_SLOT]: `renderSlot`,\r\n  [CREATE_SLOTS]: `createSlots`,\r\n  [TO_DISPLAY_STRING]: `toDisplayString`,\r\n  [MERGE_PROPS]: `mergeProps`,\r\n  [NORMALIZE_CLASS]: `normalizeClass`,\r\n  [NORMALIZE_STYLE]: `normalizeStyle`,\r\n  [NORMALIZE_PROPS]: `normalizeProps`,\r\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\r\n  [TO_HANDLERS]: `toHandlers`,\r\n  [CAMELIZE]: `camelize`,\r\n  [CAPITALIZE]: `capitalize`,\r\n  [TO_HANDLER_KEY]: `toHandlerKey`,\r\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n  [PUSH_SCOPE_ID]: `pushScopeId`,\r\n  [POP_SCOPE_ID]: `popScopeId`,\r\n  [WITH_CTX]: `withCtx`,\r\n  [UNREF]: `unref`,\r\n  [IS_REF]: `isRef`,\r\n  [WITH_MEMO]: `withMemo`,\r\n  [IS_MEMO_SAME]: `isMemoSame`\r\n}\r\n\r\nexport function registerRuntimeHelpers(helpers: any) {\r\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n    helperNameMap[s] = helpers[s]\r\n  })\r\n}\r\n","import { isString } from '@vue/shared'\r\nimport { ForParseResult } from './transforms/vFor'\r\nimport {\r\n  RENDER_SLOT,\r\n  CREATE_SLOTS,\r\n  RENDER_LIST,\r\n  OPEN_BLOCK,\r\n  FRAGMENT,\r\n  WITH_DIRECTIVES,\r\n  WITH_MEMO\r\n} from './runtimeHelpers'\r\nimport { PropsExpression } from './transforms/transformElement'\r\nimport { ImportItem, TransformContext } from './transform'\r\nimport { getVNodeBlockHelper, getVNodeHelper } from './utils'\r\n\r\n// Vue template is a platform-agnostic superset of HTML (syntax only).\r\n// More namespaces like SVG and MathML are declared by platform specific\r\n// compilers.\r\nexport type Namespace = number\r\n\r\nexport const enum Namespaces {\r\n  HTML\r\n}\r\n\r\nexport const enum NodeTypes {\r\n  ROOT,\r\n  ELEMENT,\r\n  TEXT,\r\n  COMMENT,\r\n  SIMPLE_EXPRESSION,\r\n  INTERPOLATION,\r\n  ATTRIBUTE,\r\n  DIRECTIVE,\r\n  // containers\r\n  COMPOUND_EXPRESSION,\r\n  IF,\r\n  IF_BRANCH,\r\n  FOR,\r\n  TEXT_CALL,\r\n  // codegen\r\n  VNODE_CALL,\r\n  JS_CALL_EXPRESSION,\r\n  JS_OBJECT_EXPRESSION,\r\n  JS_PROPERTY,\r\n  JS_ARRAY_EXPRESSION,\r\n  JS_FUNCTION_EXPRESSION,\r\n  JS_CONDITIONAL_EXPRESSION,\r\n  JS_CACHE_EXPRESSION,\r\n\r\n  // ssr codegen\r\n  JS_BLOCK_STATEMENT,\r\n  JS_TEMPLATE_LITERAL,\r\n  JS_IF_STATEMENT,\r\n  JS_ASSIGNMENT_EXPRESSION,\r\n  JS_SEQUENCE_EXPRESSION,\r\n  JS_RETURN_STATEMENT\r\n}\r\n\r\nexport const enum ElementTypes {\r\n  ELEMENT,\r\n  COMPONENT,\r\n  SLOT,\r\n  TEMPLATE\r\n}\r\n\r\nexport interface Node {\r\n  type: NodeTypes\r\n  loc: SourceLocation\r\n}\r\n\r\n// The node's range. The `start` is inclusive and `end` is exclusive.\r\n// [start, end)\r\nexport interface SourceLocation {\r\n  start: Position\r\n  end: Position\r\n  source: string\r\n}\r\n\r\nexport interface Position {\r\n  offset: number // from start of file\r\n  line: number\r\n  column: number\r\n}\r\n\r\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\r\n\r\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\r\n\r\nexport type TemplateChildNode =\r\n  | ElementNode\r\n  | InterpolationNode\r\n  | CompoundExpressionNode\r\n  | TextNode\r\n  | CommentNode\r\n  | IfNode\r\n  | IfBranchNode\r\n  | ForNode\r\n  | TextCallNode\r\n\r\nexport interface RootNode extends Node {\r\n  type: NodeTypes.ROOT\r\n  children: TemplateChildNode[]\r\n  helpers: symbol[]\r\n  components: string[]\r\n  directives: string[]\r\n  hoists: (JSChildNode | null)[]\r\n  imports: ImportItem[]\r\n  cached: number\r\n  temps: number\r\n  ssrHelpers?: symbol[]\r\n  codegenNode?: TemplateChildNode | JSChildNode | BlockStatement\r\n\r\n  // v2 compat only\r\n  filters?: string[]\r\n}\r\n\r\nexport type ElementNode =\r\n  | PlainElementNode\r\n  | ComponentNode\r\n  | SlotOutletNode\r\n  | TemplateNode\r\n\r\nexport interface BaseElementNode extends Node {\r\n  type: NodeTypes.ELEMENT\r\n  ns: Namespace\r\n  tag: string\r\n  tagType: ElementTypes\r\n  isSelfClosing: boolean\r\n  props: Array<AttributeNode | DirectiveNode>\r\n  children: TemplateChildNode[]\r\n}\r\n\r\nexport interface PlainElementNode extends BaseElementNode {\r\n  tagType: ElementTypes.ELEMENT\r\n  codegenNode:\r\n    | VNodeCall\r\n    | SimpleExpressionNode // when hoisted\r\n    | CacheExpression // when cached by v-once\r\n    | MemoExpression // when cached by v-memo\r\n    | undefined\r\n  ssrCodegenNode?: TemplateLiteral\r\n}\r\n\r\nexport interface ComponentNode extends BaseElementNode {\r\n  tagType: ElementTypes.COMPONENT\r\n  codegenNode:\r\n    | VNodeCall\r\n    | CacheExpression // when cached by v-once\r\n    | MemoExpression // when cached by v-memo\r\n    | undefined\r\n  ssrCodegenNode?: CallExpression\r\n}\r\n\r\nexport interface SlotOutletNode extends BaseElementNode {\r\n  tagType: ElementTypes.SLOT\r\n  codegenNode:\r\n    | RenderSlotCall\r\n    | CacheExpression // when cached by v-once\r\n    | undefined\r\n  ssrCodegenNode?: CallExpression\r\n}\r\n\r\nexport interface TemplateNode extends BaseElementNode {\r\n  tagType: ElementTypes.TEMPLATE\r\n  // TemplateNode is a container type that always gets compiled away\r\n  codegenNode: undefined\r\n}\r\n\r\nexport interface TextNode extends Node {\r\n  type: NodeTypes.TEXT\r\n  content: string\r\n}\r\n\r\nexport interface CommentNode extends Node {\r\n  type: NodeTypes.COMMENT\r\n  content: string\r\n}\r\n\r\nexport interface AttributeNode extends Node {\r\n  type: NodeTypes.ATTRIBUTE\r\n  name: string\r\n  value: TextNode | undefined\r\n}\r\n\r\nexport interface DirectiveNode extends Node {\r\n  type: NodeTypes.DIRECTIVE\r\n  name: string\r\n  exp: ExpressionNode | undefined\r\n  arg: ExpressionNode | undefined\r\n  modifiers: string[]\r\n  /**\r\n   * optional property to cache the expression parse result for v-for\r\n   */\r\n  parseResult?: ForParseResult\r\n}\r\n\r\n/**\r\n * Static types have several levels.\r\n * Higher levels implies lower levels. e.g. a node that can be stringified\r\n * can always be hoisted and skipped for patch.\r\n */\r\nexport const enum ConstantTypes {\r\n  NOT_CONSTANT = 0,\r\n  CAN_SKIP_PATCH,\r\n  CAN_HOIST,\r\n  CAN_STRINGIFY\r\n}\r\n\r\nexport interface SimpleExpressionNode extends Node {\r\n  type: NodeTypes.SIMPLE_EXPRESSION\r\n  content: string\r\n  isStatic: boolean\r\n  constType: ConstantTypes\r\n  /**\r\n   * Indicates this is an identifier for a hoist vnode call and points to the\r\n   * hoisted node.\r\n   */\r\n  hoisted?: JSChildNode\r\n  /**\r\n   * an expression parsed as the params of a function will track\r\n   * the identifiers declared inside the function body.\r\n   */\r\n  identifiers?: string[]\r\n  isHandlerKey?: boolean\r\n}\r\n\r\nexport interface InterpolationNode extends Node {\r\n  type: NodeTypes.INTERPOLATION\r\n  content: ExpressionNode\r\n}\r\n\r\nexport interface CompoundExpressionNode extends Node {\r\n  type: NodeTypes.COMPOUND_EXPRESSION\r\n  children: (\r\n    | SimpleExpressionNode\r\n    | CompoundExpressionNode\r\n    | InterpolationNode\r\n    | TextNode\r\n    | string\r\n    | symbol\r\n  )[]\r\n\r\n  /**\r\n   * an expression parsed as the params of a function will track\r\n   * the identifiers declared inside the function body.\r\n   */\r\n  identifiers?: string[]\r\n  isHandlerKey?: boolean\r\n}\r\n\r\nexport interface IfNode extends Node {\r\n  type: NodeTypes.IF\r\n  branches: IfBranchNode[]\r\n  codegenNode?: IfConditionalExpression | CacheExpression // <div v-if v-once>\r\n}\r\n\r\nexport interface IfBranchNode extends Node {\r\n  type: NodeTypes.IF_BRANCH\r\n  condition: ExpressionNode | undefined // else\r\n  children: TemplateChildNode[]\r\n  userKey?: AttributeNode | DirectiveNode\r\n  isTemplateIf?: boolean\r\n}\r\n\r\nexport interface ForNode extends Node {\r\n  type: NodeTypes.FOR\r\n  source: ExpressionNode\r\n  valueAlias: ExpressionNode | undefined\r\n  keyAlias: ExpressionNode | undefined\r\n  objectIndexAlias: ExpressionNode | undefined\r\n  parseResult: ForParseResult\r\n  children: TemplateChildNode[]\r\n  codegenNode?: ForCodegenNode\r\n}\r\n\r\nexport interface TextCallNode extends Node {\r\n  type: NodeTypes.TEXT_CALL\r\n  content: TextNode | InterpolationNode | CompoundExpressionNode\r\n  codegenNode: CallExpression | SimpleExpressionNode // when hoisted\r\n}\r\n\r\nexport type TemplateTextChildNode =\r\n  | TextNode\r\n  | InterpolationNode\r\n  | CompoundExpressionNode\r\n\r\nexport interface VNodeCall extends Node {\r\n  type: NodeTypes.VNODE_CALL\r\n  tag: string | symbol | CallExpression\r\n  props: PropsExpression | undefined\r\n  children:\r\n    | TemplateChildNode[] // multiple children\r\n    | TemplateTextChildNode // single text child\r\n    | SlotsExpression // component slots\r\n    | ForRenderListExpression // v-for fragment call\r\n    | SimpleExpressionNode // hoisted\r\n    | undefined\r\n  patchFlag: string | undefined\r\n  dynamicProps: string | SimpleExpressionNode | undefined\r\n  directives: DirectiveArguments | undefined\r\n  isBlock: boolean\r\n  disableTracking: boolean\r\n  isComponent: boolean\r\n}\r\n\r\n// JS Node Types ---------------------------------------------------------------\r\n\r\n// We also include a number of JavaScript AST nodes for code generation.\r\n// The AST is an intentionally minimal subset just to meet the exact needs of\r\n// Vue render function generation.\r\n\r\nexport type JSChildNode =\r\n  | VNodeCall\r\n  | CallExpression\r\n  | ObjectExpression\r\n  | ArrayExpression\r\n  | ExpressionNode\r\n  | FunctionExpression\r\n  | ConditionalExpression\r\n  | CacheExpression\r\n  | AssignmentExpression\r\n  | SequenceExpression\r\n\r\nexport interface CallExpression extends Node {\r\n  type: NodeTypes.JS_CALL_EXPRESSION\r\n  callee: string | symbol\r\n  arguments: (\r\n    | string\r\n    | symbol\r\n    | JSChildNode\r\n    | SSRCodegenNode\r\n    | TemplateChildNode\r\n    | TemplateChildNode[]\r\n  )[]\r\n}\r\n\r\nexport interface ObjectExpression extends Node {\r\n  type: NodeTypes.JS_OBJECT_EXPRESSION\r\n  properties: Array<Property>\r\n}\r\n\r\nexport interface Property extends Node {\r\n  type: NodeTypes.JS_PROPERTY\r\n  key: ExpressionNode\r\n  value: JSChildNode\r\n}\r\n\r\nexport interface ArrayExpression extends Node {\r\n  type: NodeTypes.JS_ARRAY_EXPRESSION\r\n  elements: Array<string | Node>\r\n}\r\n\r\nexport interface FunctionExpression extends Node {\r\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\r\n  params: ExpressionNode | string | (ExpressionNode | string)[] | undefined\r\n  returns?: TemplateChildNode | TemplateChildNode[] | JSChildNode\r\n  body?: BlockStatement | IfStatement\r\n  newline: boolean\r\n  /**\r\n   * This flag is for codegen to determine whether it needs to generate the\r\n   * withScopeId() wrapper\r\n   */\r\n  isSlot: boolean\r\n  /**\r\n   * __COMPAT__ only, indicates a slot function that should be excluded from\r\n   * the legacy $scopedSlots instance property.\r\n   */\r\n  isNonScopedSlot?: boolean\r\n}\r\n\r\nexport interface ConditionalExpression extends Node {\r\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n  test: JSChildNode\r\n  consequent: JSChildNode\r\n  alternate: JSChildNode\r\n  newline: boolean\r\n}\r\n\r\nexport interface CacheExpression extends Node {\r\n  type: NodeTypes.JS_CACHE_EXPRESSION\r\n  index: number\r\n  value: JSChildNode\r\n  isVNode: boolean\r\n}\r\n\r\nexport interface MemoExpression extends CallExpression {\r\n  callee: typeof WITH_MEMO\r\n  arguments: [ExpressionNode, MemoFactory, string, string]\r\n}\r\n\r\ninterface MemoFactory extends FunctionExpression {\r\n  returns: BlockCodegenNode\r\n}\r\n\r\n// SSR-specific Node Types -----------------------------------------------------\r\n\r\nexport type SSRCodegenNode =\r\n  | BlockStatement\r\n  | TemplateLiteral\r\n  | IfStatement\r\n  | AssignmentExpression\r\n  | ReturnStatement\r\n  | SequenceExpression\r\n\r\nexport interface BlockStatement extends Node {\r\n  type: NodeTypes.JS_BLOCK_STATEMENT\r\n  body: (JSChildNode | IfStatement)[]\r\n}\r\n\r\nexport interface TemplateLiteral extends Node {\r\n  type: NodeTypes.JS_TEMPLATE_LITERAL\r\n  elements: (string | JSChildNode)[]\r\n}\r\n\r\nexport interface IfStatement extends Node {\r\n  type: NodeTypes.JS_IF_STATEMENT\r\n  test: ExpressionNode\r\n  consequent: BlockStatement\r\n  alternate: IfStatement | BlockStatement | ReturnStatement | undefined\r\n}\r\n\r\nexport interface AssignmentExpression extends Node {\r\n  type: NodeTypes.JS_ASSIGNMENT_EXPRESSION\r\n  left: SimpleExpressionNode\r\n  right: JSChildNode\r\n}\r\n\r\nexport interface SequenceExpression extends Node {\r\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\r\n  expressions: JSChildNode[]\r\n}\r\n\r\nexport interface ReturnStatement extends Node {\r\n  type: NodeTypes.JS_RETURN_STATEMENT\r\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\r\n}\r\n\r\n// Codegen Node Types ----------------------------------------------------------\r\n\r\nexport interface DirectiveArguments extends ArrayExpression {\r\n  elements: DirectiveArgumentNode[]\r\n}\r\n\r\nexport interface DirectiveArgumentNode extends ArrayExpression {\r\n  elements: // dir, exp, arg, modifiers\r\n  | [string]\r\n    | [string, ExpressionNode]\r\n    | [string, ExpressionNode, ExpressionNode]\r\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\r\n}\r\n\r\n// renderSlot(...)\r\nexport interface RenderSlotCall extends CallExpression {\r\n  callee: typeof RENDER_SLOT\r\n  arguments: // $slots, name, props, fallback\r\n  | [string, string | ExpressionNode]\r\n    | [string, string | ExpressionNode, PropsExpression]\r\n    | [\r\n        string,\r\n        string | ExpressionNode,\r\n        PropsExpression | '{}',\r\n        TemplateChildNode[]\r\n      ]\r\n}\r\n\r\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\r\n\r\n// { foo: () => [...] }\r\nexport interface SlotsObjectExpression extends ObjectExpression {\r\n  properties: SlotsObjectProperty[]\r\n}\r\n\r\nexport interface SlotsObjectProperty extends Property {\r\n  value: SlotFunctionExpression\r\n}\r\n\r\nexport interface SlotFunctionExpression extends FunctionExpression {\r\n  returns: TemplateChildNode[]\r\n}\r\n\r\n// createSlots({ ... }, [\r\n//    foo ? () => [] : undefined,\r\n//    renderList(list, i => () => [i])\r\n// ])\r\nexport interface DynamicSlotsExpression extends CallExpression {\r\n  callee: typeof CREATE_SLOTS\r\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\r\n}\r\n\r\nexport interface DynamicSlotEntries extends ArrayExpression {\r\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\r\n}\r\n\r\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\r\n  consequent: DynamicSlotNode\r\n  alternate: DynamicSlotNode | SimpleExpressionNode\r\n}\r\n\r\nexport interface ListDynamicSlotNode extends CallExpression {\r\n  callee: typeof RENDER_LIST\r\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\r\n}\r\n\r\nexport interface ListDynamicSlotIterator extends FunctionExpression {\r\n  returns: DynamicSlotNode\r\n}\r\n\r\nexport interface DynamicSlotNode extends ObjectExpression {\r\n  properties: [Property, DynamicSlotFnProperty]\r\n}\r\n\r\nexport interface DynamicSlotFnProperty extends Property {\r\n  value: SlotFunctionExpression\r\n}\r\n\r\nexport type BlockCodegenNode = VNodeCall | RenderSlotCall\r\n\r\nexport interface IfConditionalExpression extends ConditionalExpression {\r\n  consequent: BlockCodegenNode | MemoExpression\r\n  alternate: BlockCodegenNode | IfConditionalExpression | MemoExpression\r\n}\r\n\r\nexport interface ForCodegenNode extends VNodeCall {\r\n  isBlock: true\r\n  tag: typeof FRAGMENT\r\n  props: undefined\r\n  children: ForRenderListExpression\r\n  patchFlag: string\r\n  disableTracking: boolean\r\n}\r\n\r\nexport interface ForRenderListExpression extends CallExpression {\r\n  callee: typeof RENDER_LIST\r\n  arguments: [ExpressionNode, ForIteratorExpression]\r\n}\r\n\r\nexport interface ForIteratorExpression extends FunctionExpression {\r\n  returns: BlockCodegenNode\r\n}\r\n\r\n// AST Utilities ---------------------------------------------------------------\r\n\r\n// Some expressions, e.g. sequence and conditional expressions, are never\r\n// associated with template nodes, so their source locations are just a stub.\r\n// Container types like CompoundExpression also don't need a real location.\r\nexport const locStub: SourceLocation = {\r\n  source: '',\r\n  start: { line: 1, column: 1, offset: 0 },\r\n  end: { line: 1, column: 1, offset: 0 }\r\n}\r\n\r\nexport function createRoot(\r\n  children: TemplateChildNode[],\r\n  loc = locStub\r\n): RootNode {\r\n  return {\r\n    type: NodeTypes.ROOT,\r\n    children,\r\n    helpers: [],\r\n    components: [],\r\n    directives: [],\r\n    hoists: [],\r\n    imports: [],\r\n    cached: 0,\r\n    temps: 0,\r\n    codegenNode: undefined,\r\n    loc\r\n  }\r\n}\r\n\r\nexport function createVNodeCall(\r\n  context: TransformContext | null,\r\n  tag: VNodeCall['tag'],\r\n  props?: VNodeCall['props'],\r\n  children?: VNodeCall['children'],\r\n  patchFlag?: VNodeCall['patchFlag'],\r\n  dynamicProps?: VNodeCall['dynamicProps'],\r\n  directives?: VNodeCall['directives'],\r\n  isBlock: VNodeCall['isBlock'] = false,\r\n  disableTracking: VNodeCall['disableTracking'] = false,\r\n  isComponent: VNodeCall['isComponent'] = false,\r\n  loc = locStub\r\n): VNodeCall {\r\n  if (context) {\r\n    if (isBlock) {\r\n      context.helper(OPEN_BLOCK)\r\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))\r\n    } else {\r\n      context.helper(getVNodeHelper(context.inSSR, isComponent))\r\n    }\r\n    if (directives) {\r\n      context.helper(WITH_DIRECTIVES)\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.VNODE_CALL,\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isBlock,\r\n    disableTracking,\r\n    isComponent,\r\n    loc\r\n  }\r\n}\r\n\r\nexport function createArrayExpression(\r\n  elements: ArrayExpression['elements'],\r\n  loc: SourceLocation = locStub\r\n): ArrayExpression {\r\n  return {\r\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\r\n    loc,\r\n    elements\r\n  }\r\n}\r\n\r\nexport function createObjectExpression(\r\n  properties: ObjectExpression['properties'],\r\n  loc: SourceLocation = locStub\r\n): ObjectExpression {\r\n  return {\r\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\r\n    loc,\r\n    properties\r\n  }\r\n}\r\n\r\nexport function createObjectProperty(\r\n  key: Property['key'] | string,\r\n  value: Property['value']\r\n): Property {\r\n  return {\r\n    type: NodeTypes.JS_PROPERTY,\r\n    loc: locStub,\r\n    key: isString(key) ? createSimpleExpression(key, true) : key,\r\n    value\r\n  }\r\n}\r\n\r\nexport function createSimpleExpression(\r\n  content: SimpleExpressionNode['content'],\r\n  isStatic: SimpleExpressionNode['isStatic'] = false,\r\n  loc: SourceLocation = locStub,\r\n  constType: ConstantTypes = ConstantTypes.NOT_CONSTANT\r\n): SimpleExpressionNode {\r\n  return {\r\n    type: NodeTypes.SIMPLE_EXPRESSION,\r\n    loc,\r\n    content,\r\n    isStatic,\r\n    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType\r\n  }\r\n}\r\n\r\nexport function createInterpolation(\r\n  content: InterpolationNode['content'] | string,\r\n  loc: SourceLocation\r\n): InterpolationNode {\r\n  return {\r\n    type: NodeTypes.INTERPOLATION,\r\n    loc,\r\n    content: isString(content)\r\n      ? createSimpleExpression(content, false, loc)\r\n      : content\r\n  }\r\n}\r\n\r\nexport function createCompoundExpression(\r\n  children: CompoundExpressionNode['children'],\r\n  loc: SourceLocation = locStub\r\n): CompoundExpressionNode {\r\n  return {\r\n    type: NodeTypes.COMPOUND_EXPRESSION,\r\n    loc,\r\n    children\r\n  }\r\n}\r\n\r\ntype InferCodegenNodeType<T> = T extends typeof RENDER_SLOT\r\n  ? RenderSlotCall\r\n  : CallExpression\r\n\r\nexport function createCallExpression<T extends CallExpression['callee']>(\r\n  callee: T,\r\n  args: CallExpression['arguments'] = [],\r\n  loc: SourceLocation = locStub\r\n): InferCodegenNodeType<T> {\r\n  return {\r\n    type: NodeTypes.JS_CALL_EXPRESSION,\r\n    loc,\r\n    callee,\r\n    arguments: args\r\n  } as InferCodegenNodeType<T>\r\n}\r\n\r\nexport function createFunctionExpression(\r\n  params: FunctionExpression['params'],\r\n  returns: FunctionExpression['returns'] = undefined,\r\n  newline: boolean = false,\r\n  isSlot: boolean = false,\r\n  loc: SourceLocation = locStub\r\n): FunctionExpression {\r\n  return {\r\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\r\n    params,\r\n    returns,\r\n    newline,\r\n    isSlot,\r\n    loc\r\n  }\r\n}\r\n\r\nexport function createConditionalExpression(\r\n  test: ConditionalExpression['test'],\r\n  consequent: ConditionalExpression['consequent'],\r\n  alternate: ConditionalExpression['alternate'],\r\n  newline = true\r\n): ConditionalExpression {\r\n  return {\r\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\r\n    test,\r\n    consequent,\r\n    alternate,\r\n    newline,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createCacheExpression(\r\n  index: number,\r\n  value: JSChildNode,\r\n  isVNode: boolean = false\r\n): CacheExpression {\r\n  return {\r\n    type: NodeTypes.JS_CACHE_EXPRESSION,\r\n    index,\r\n    value,\r\n    isVNode,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createBlockStatement(\r\n  body: BlockStatement['body']\r\n): BlockStatement {\r\n  return {\r\n    type: NodeTypes.JS_BLOCK_STATEMENT,\r\n    body,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createTemplateLiteral(\r\n  elements: TemplateLiteral['elements']\r\n): TemplateLiteral {\r\n  return {\r\n    type: NodeTypes.JS_TEMPLATE_LITERAL,\r\n    elements,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createIfStatement(\r\n  test: IfStatement['test'],\r\n  consequent: IfStatement['consequent'],\r\n  alternate?: IfStatement['alternate']\r\n): IfStatement {\r\n  return {\r\n    type: NodeTypes.JS_IF_STATEMENT,\r\n    test,\r\n    consequent,\r\n    alternate,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createAssignmentExpression(\r\n  left: AssignmentExpression['left'],\r\n  right: AssignmentExpression['right']\r\n): AssignmentExpression {\r\n  return {\r\n    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,\r\n    left,\r\n    right,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createSequenceExpression(\r\n  expressions: SequenceExpression['expressions']\r\n): SequenceExpression {\r\n  return {\r\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\r\n    expressions,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createReturnStatement(\r\n  returns: ReturnStatement['returns']\r\n): ReturnStatement {\r\n  return {\r\n    type: NodeTypes.JS_RETURN_STATEMENT,\r\n    returns,\r\n    loc: locStub\r\n  }\r\n}\r\n","import {\r\n  SourceLocation,\r\n  Position,\r\n  ElementNode,\r\n  NodeTypes,\r\n  CallExpression,\r\n  createCallExpression,\r\n  DirectiveNode,\r\n  ElementTypes,\r\n  TemplateChildNode,\r\n  RootNode,\r\n  ObjectExpression,\r\n  Property,\r\n  JSChildNode,\r\n  createObjectExpression,\r\n  SlotOutletNode,\r\n  TemplateNode,\r\n  RenderSlotCall,\r\n  ExpressionNode,\r\n  IfBranchNode,\r\n  TextNode,\r\n  InterpolationNode,\r\n  VNodeCall,\r\n  SimpleExpressionNode,\r\n  BlockCodegenNode,\r\n  MemoExpression\r\n} from './ast'\r\nimport { TransformContext } from './transform'\r\nimport {\r\n  MERGE_PROPS,\r\n  TELEPORT,\r\n  SUSPENSE,\r\n  KEEP_ALIVE,\r\n  BASE_TRANSITION,\r\n  TO_HANDLERS,\r\n  NORMALIZE_PROPS,\r\n  GUARD_REACTIVE_PROPS,\r\n  CREATE_BLOCK,\r\n  CREATE_ELEMENT_BLOCK,\r\n  CREATE_VNODE,\r\n  CREATE_ELEMENT_VNODE,\r\n  WITH_MEMO,\r\n  OPEN_BLOCK\r\n} from './runtimeHelpers'\r\nimport { isString, isObject, hyphenate, extend, NOOP } from '@vue/shared'\r\nimport { PropsExpression } from './transforms/transformElement'\r\nimport { parseExpression } from '@babel/parser'\r\nimport { Expression } from '@babel/types'\r\n\r\nexport const isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\r\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\r\n\r\nexport const isBuiltInType = (tag: string, expected: string): boolean =>\r\n  tag === expected || tag === hyphenate(expected)\r\n\r\nexport function isCoreComponent(tag: string): symbol | void {\r\n  if (isBuiltInType(tag, 'Teleport')) {\r\n    return TELEPORT\r\n  } else if (isBuiltInType(tag, 'Suspense')) {\r\n    return SUSPENSE\r\n  } else if (isBuiltInType(tag, 'KeepAlive')) {\r\n    return KEEP_ALIVE\r\n  } else if (isBuiltInType(tag, 'BaseTransition')) {\r\n    return BASE_TRANSITION\r\n  }\r\n}\r\n\r\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\r\nexport const isSimpleIdentifier = (name: string): boolean =>\r\n  !nonIdentifierRE.test(name)\r\n\r\nconst enum MemberExpLexState {\r\n  inMemberExp,\r\n  inBrackets,\r\n  inParens,\r\n  inString\r\n}\r\n\r\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/\r\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/\r\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g\r\n\r\n/**\r\n * Simple lexer to check if an expression is a member expression. This is\r\n * lax and only checks validity at the root level (i.e. does not validate exps\r\n * inside square brackets), but it's ok since these are only used on template\r\n * expressions and false positives are invalid expressions in the first place.\r\n */\r\nexport const isMemberExpressionBrowser = (path: string): boolean => {\r\n  // remove whitespaces around . or [ first\r\n  path = path.trim().replace(whitespaceRE, s => s.trim())\r\n\r\n  let state = MemberExpLexState.inMemberExp\r\n  let stateStack: MemberExpLexState[] = []\r\n  let currentOpenBracketCount = 0\r\n  let currentOpenParensCount = 0\r\n  let currentStringType: \"'\" | '\"' | '`' | null = null\r\n\r\n  for (let i = 0; i < path.length; i++) {\r\n    const char = path.charAt(i)\r\n    switch (state) {\r\n      case MemberExpLexState.inMemberExp:\r\n        if (char === '[') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inBrackets\r\n          currentOpenBracketCount++\r\n        } else if (char === '(') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inParens\r\n          currentOpenParensCount++\r\n        } else if (\r\n          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)\r\n        ) {\r\n          return false\r\n        }\r\n        break\r\n      case MemberExpLexState.inBrackets:\r\n        if (char === `'` || char === `\"` || char === '`') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inString\r\n          currentStringType = char\r\n        } else if (char === `[`) {\r\n          currentOpenBracketCount++\r\n        } else if (char === `]`) {\r\n          if (!--currentOpenBracketCount) {\r\n            state = stateStack.pop()!\r\n          }\r\n        }\r\n        break\r\n      case MemberExpLexState.inParens:\r\n        if (char === `'` || char === `\"` || char === '`') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inString\r\n          currentStringType = char\r\n        } else if (char === `(`) {\r\n          currentOpenParensCount++\r\n        } else if (char === `)`) {\r\n          // if the exp ends as a call then it should not be considered valid\r\n          if (i === path.length - 1) {\r\n            return false\r\n          }\r\n          if (!--currentOpenParensCount) {\r\n            state = stateStack.pop()!\r\n          }\r\n        }\r\n        break\r\n      case MemberExpLexState.inString:\r\n        if (char === currentStringType) {\r\n          state = stateStack.pop()!\r\n          currentStringType = null\r\n        }\r\n        break\r\n    }\r\n  }\r\n  return !currentOpenBracketCount && !currentOpenParensCount\r\n}\r\n\r\nexport const isMemberExpressionNode = __BROWSER__\r\n  ? (NOOP as any as (path: string, context: TransformContext) => boolean)\r\n  : (path: string, context: TransformContext): boolean => {\r\n      try {\r\n        let ret: Expression = parseExpression(path, {\r\n          plugins: context.expressionPlugins\r\n        })\r\n        if (ret.type === 'TSAsExpression' || ret.type === 'TSTypeAssertion') {\r\n          ret = ret.expression\r\n        }\r\n        return (\r\n          ret.type === 'MemberExpression' ||\r\n          ret.type === 'OptionalMemberExpression' ||\r\n          ret.type === 'Identifier'\r\n        )\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\nexport const isMemberExpression = __BROWSER__\r\n  ? isMemberExpressionBrowser\r\n  : isMemberExpressionNode\r\n\r\nexport function getInnerRange(\r\n  loc: SourceLocation,\r\n  offset: number,\r\n  length: number\r\n): SourceLocation {\r\n  __TEST__ && assert(offset <= loc.source.length)\r\n  const source = loc.source.slice(offset, offset + length)\r\n  const newLoc: SourceLocation = {\r\n    source,\r\n    start: advancePositionWithClone(loc.start, loc.source, offset),\r\n    end: loc.end\r\n  }\r\n\r\n  if (length != null) {\r\n    __TEST__ && assert(offset + length <= loc.source.length)\r\n    newLoc.end = advancePositionWithClone(\r\n      loc.start,\r\n      loc.source,\r\n      offset + length\r\n    )\r\n  }\r\n\r\n  return newLoc\r\n}\r\n\r\nexport function advancePositionWithClone(\r\n  pos: Position,\r\n  source: string,\r\n  numberOfCharacters: number = source.length\r\n): Position {\r\n  return advancePositionWithMutation(\r\n    extend({}, pos),\r\n    source,\r\n    numberOfCharacters\r\n  )\r\n}\r\n\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nexport function advancePositionWithMutation(\r\n  pos: Position,\r\n  source: string,\r\n  numberOfCharacters: number = source.length\r\n): Position {\r\n  let linesCount = 0\r\n  let lastNewLinePos = -1\r\n  for (let i = 0; i < numberOfCharacters; i++) {\r\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n      linesCount++\r\n      lastNewLinePos = i\r\n    }\r\n  }\r\n\r\n  pos.offset += numberOfCharacters\r\n  pos.line += linesCount\r\n  pos.column =\r\n    lastNewLinePos === -1\r\n      ? pos.column + numberOfCharacters\r\n      : numberOfCharacters - lastNewLinePos\r\n\r\n  return pos\r\n}\r\n\r\nexport function assert(condition: boolean, msg?: string) {\r\n  /* istanbul ignore if */\r\n  if (!condition) {\r\n    throw new Error(msg || `unexpected compiler condition`)\r\n  }\r\n}\r\n\r\nexport function findDir(\r\n  node: ElementNode,\r\n  name: string | RegExp,\r\n  allowEmpty: boolean = false\r\n): DirectiveNode | undefined {\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (\r\n      p.type === NodeTypes.DIRECTIVE &&\r\n      (allowEmpty || p.exp) &&\r\n      (isString(name) ? p.name === name : name.test(p.name))\r\n    ) {\r\n      return p\r\n    }\r\n  }\r\n}\r\n\r\nexport function findProp(\r\n  node: ElementNode,\r\n  name: string,\r\n  dynamicOnly: boolean = false,\r\n  allowEmpty: boolean = false\r\n): ElementNode['props'][0] | undefined {\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (dynamicOnly) continue\r\n      if (p.name === name && (p.value || allowEmpty)) {\r\n        return p\r\n      }\r\n    } else if (\r\n      p.name === 'bind' &&\r\n      (p.exp || allowEmpty) &&\r\n      isStaticArgOf(p.arg, name)\r\n    ) {\r\n      return p\r\n    }\r\n  }\r\n}\r\n\r\nexport function isStaticArgOf(\r\n  arg: DirectiveNode['arg'],\r\n  name: string\r\n): boolean {\r\n  return !!(arg && isStaticExp(arg) && arg.content === name)\r\n}\r\n\r\nexport function hasDynamicKeyVBind(node: ElementNode): boolean {\r\n  return node.props.some(\r\n    p =>\r\n      p.type === NodeTypes.DIRECTIVE &&\r\n      p.name === 'bind' &&\r\n      (!p.arg || // v-bind=\"obj\"\r\n        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]\r\n        !p.arg.isStatic) // v-bind:[foo]\r\n  )\r\n}\r\n\r\nexport function isText(\r\n  node: TemplateChildNode\r\n): node is TextNode | InterpolationNode {\r\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\r\n}\r\n\r\nexport function isVSlot(p: ElementNode['props'][0]): p is DirectiveNode {\r\n  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\r\n}\r\n\r\nexport function isTemplateNode(\r\n  node: RootNode | TemplateChildNode\r\n): node is TemplateNode {\r\n  return (\r\n    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\r\n  )\r\n}\r\n\r\nexport function isSlotOutlet(\r\n  node: RootNode | TemplateChildNode\r\n): node is SlotOutletNode {\r\n  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\r\n}\r\n\r\nexport function getVNodeHelper(ssr: boolean, isComponent: boolean) {\r\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE\r\n}\r\n\r\nexport function getVNodeBlockHelper(ssr: boolean, isComponent: boolean) {\r\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK\r\n}\r\n\r\nconst propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])\r\n\r\nfunction getUnnormalizedProps(\r\n  props: PropsExpression | '{}',\r\n  callPath: CallExpression[] = []\r\n): [PropsExpression | '{}', CallExpression[]] {\r\n  if (\r\n    props &&\r\n    !isString(props) &&\r\n    props.type === NodeTypes.JS_CALL_EXPRESSION\r\n  ) {\r\n    const callee = props.callee\r\n    if (!isString(callee) && propsHelperSet.has(callee)) {\r\n      return getUnnormalizedProps(\r\n        props.arguments[0] as PropsExpression,\r\n        callPath.concat(props)\r\n      )\r\n    }\r\n  }\r\n  return [props, callPath]\r\n}\r\nexport function injectProp(\r\n  node: VNodeCall | RenderSlotCall,\r\n  prop: Property,\r\n  context: TransformContext\r\n) {\r\n  let propsWithInjection: ObjectExpression | CallExpression | undefined\r\n  /**\r\n   * 1. mergeProps(...)\r\n   * 2. toHandlers(...)\r\n   * 3. normalizeProps(...)\r\n   * 4. normalizeProps(guardReactiveProps(...))\r\n   *\r\n   * we need to get the real props before normalization\r\n   */\r\n  let props =\r\n    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]\r\n  let callPath: CallExpression[] = []\r\n  let parentCall: CallExpression | undefined\r\n  if (\r\n    props &&\r\n    !isString(props) &&\r\n    props.type === NodeTypes.JS_CALL_EXPRESSION\r\n  ) {\r\n    const ret = getUnnormalizedProps(props)\r\n    props = ret[0]\r\n    callPath = ret[1]\r\n    parentCall = callPath[callPath.length - 1]\r\n  }\r\n\r\n  if (props == null || isString(props)) {\r\n    propsWithInjection = createObjectExpression([prop])\r\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n    // merged props... add ours\r\n    // only inject key to object literal if it's the first argument so that\r\n    // if doesn't override user provided keys\r\n    const first = props.arguments[0] as string | JSChildNode\r\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n      first.properties.unshift(prop)\r\n    } else {\r\n      if (props.callee === TO_HANDLERS) {\r\n        // #2366\r\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n          createObjectExpression([prop]),\r\n          props\r\n        ])\r\n      } else {\r\n        props.arguments.unshift(createObjectExpression([prop]))\r\n      }\r\n    }\r\n    !propsWithInjection && (propsWithInjection = props)\r\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n    let alreadyExists = false\r\n    // check existing key to avoid overriding user provided keys\r\n    if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      const propKeyName = prop.key.content\r\n      alreadyExists = props.properties.some(\r\n        p =>\r\n          p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n          p.key.content === propKeyName\r\n      )\r\n    }\r\n    if (!alreadyExists) {\r\n      props.properties.unshift(prop)\r\n    }\r\n    propsWithInjection = props\r\n  } else {\r\n    // single v-bind with expression, return a merged replacement\r\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n      createObjectExpression([prop]),\r\n      props\r\n    ])\r\n    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\r\n    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\r\n    // the `guardReactiveProps` will no longer be needed\r\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\r\n      parentCall = callPath[callPath.length - 2]\r\n    }\r\n  }\r\n  if (node.type === NodeTypes.VNODE_CALL) {\r\n    if (parentCall) {\r\n      parentCall.arguments[0] = propsWithInjection\r\n    } else {\r\n      node.props = propsWithInjection\r\n    }\r\n  } else {\r\n    if (parentCall) {\r\n      parentCall.arguments[0] = propsWithInjection\r\n    } else {\r\n      node.arguments[2] = propsWithInjection\r\n    }\r\n  }\r\n}\r\n\r\nexport function toValidAssetId(\r\n  name: string,\r\n  type: 'component' | 'directive' | 'filter'\r\n): string {\r\n  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\r\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\r\n    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()\r\n  })}`\r\n}\r\n\r\n// Check if a node contains expressions that reference current context scope ids\r\nexport function hasScopeRef(\r\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\r\n  ids: TransformContext['identifiers']\r\n): boolean {\r\n  if (!node || Object.keys(ids).length === 0) {\r\n    return false\r\n  }\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n      for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i]\r\n        if (\r\n          p.type === NodeTypes.DIRECTIVE &&\r\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.FOR:\r\n      if (hasScopeRef(node.source, ids)) {\r\n        return true\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.IF:\r\n      return node.branches.some(b => hasScopeRef(b, ids))\r\n    case NodeTypes.IF_BRANCH:\r\n      if (hasScopeRef(node.condition, ids)) {\r\n        return true\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      return (\r\n        !node.isStatic &&\r\n        isSimpleIdentifier(node.content) &&\r\n        !!ids[node.content]\r\n      )\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\r\n    case NodeTypes.INTERPOLATION:\r\n    case NodeTypes.TEXT_CALL:\r\n      return hasScopeRef(node.content, ids)\r\n    case NodeTypes.TEXT:\r\n    case NodeTypes.COMMENT:\r\n      return false\r\n    default:\r\n      if (__DEV__) {\r\n        const exhaustiveCheck: never = node\r\n        exhaustiveCheck\r\n      }\r\n      return false\r\n  }\r\n}\r\n\r\nexport function getMemoedVNodeCall(node: BlockCodegenNode | MemoExpression) {\r\n  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {\r\n    return node.arguments[1].returns as VNodeCall\r\n  } else {\r\n    return node\r\n  }\r\n}\r\n\r\nexport function makeBlock(\r\n  node: VNodeCall,\r\n  { helper, removeHelper, inSSR }: TransformContext\r\n) {\r\n  if (!node.isBlock) {\r\n    node.isBlock = true\r\n    removeHelper(getVNodeHelper(inSSR, node.isComponent))\r\n    helper(OPEN_BLOCK)\r\n    helper(getVNodeBlockHelper(inSSR, node.isComponent))\r\n  }\r\n}\r\n","import { SourceLocation } from '../ast'\r\nimport { CompilerError } from '../errors'\r\nimport { ParserContext } from '../parse'\r\nimport { TransformContext } from '../transform'\r\n\r\nexport type CompilerCompatConfig = Partial<\r\n  Record<CompilerDeprecationTypes, boolean | 'suppress-warning'>\r\n> & {\r\n  MODE?: 2 | 3\r\n}\r\n\r\nexport interface CompilerCompatOptions {\r\n  compatConfig?: CompilerCompatConfig\r\n}\r\n\r\nexport const enum CompilerDeprecationTypes {\r\n  COMPILER_IS_ON_ELEMENT = 'COMPILER_IS_ON_ELEMENT',\r\n  COMPILER_V_BIND_SYNC = 'COMPILER_V_BIND_SYNC',\r\n  COMPILER_V_BIND_PROP = 'COMPILER_V_BIND_PROP',\r\n  COMPILER_V_BIND_OBJECT_ORDER = 'COMPILER_V_BIND_OBJECT_ORDER',\r\n  COMPILER_V_ON_NATIVE = 'COMPILER_V_ON_NATIVE',\r\n  COMPILER_V_IF_V_FOR_PRECEDENCE = 'COMPILER_V_IF_V_FOR_PRECEDENCE',\r\n  COMPILER_NATIVE_TEMPLATE = 'COMPILER_NATIVE_TEMPLATE',\r\n  COMPILER_INLINE_TEMPLATE = 'COMPILER_INLINE_TEMPLATE',\r\n  COMPILER_FILTERS = 'COMPILER_FILTER'\r\n}\r\n\r\ntype DeprecationData = {\r\n  message: string | ((...args: any[]) => string)\r\n  link?: string\r\n}\r\n\r\nconst deprecationData: Record<CompilerDeprecationTypes, DeprecationData> = {\r\n  [CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT]: {\r\n    message:\r\n      `Platform-native elements with \"is\" prop will no longer be ` +\r\n      `treated as components in Vue 3 unless the \"is\" value is explicitly ` +\r\n      `prefixed with \"vue:\".`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_BIND_SYNC]: {\r\n    message: key =>\r\n      `.sync modifier for v-bind has been removed. Use v-model with ` +\r\n      `argument instead. \\`v-bind:${key}.sync\\` should be changed to ` +\r\n      `\\`v-model:${key}\\`.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_BIND_PROP]: {\r\n    message:\r\n      `.prop modifier for v-bind has been removed and no longer necessary. ` +\r\n      `Vue 3 will automatically set a binding as DOM property when appropriate.`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER]: {\r\n    message:\r\n      `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript ` +\r\n      `object spread: it will now overwrite an existing non-mergeable attribute ` +\r\n      `that appears before v-bind in the case of conflict. ` +\r\n      `To retain 2.x behavior, move v-bind to make it the first attribute. ` +\r\n      `You can also suppress this warning if the usage is intended.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_ON_NATIVE]: {\r\n    message: `.native modifier for v-on has been removed as is no longer necessary.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE]: {\r\n    message:\r\n      `v-if / v-for precedence when used on the same element has changed ` +\r\n      `in Vue 3: v-if now takes higher precedence and will no longer have ` +\r\n      `access to v-for scope variables. It is best to avoid the ambiguity ` +\r\n      `with <template> tags or use a computed property that filters v-for ` +\r\n      `data source.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE]: {\r\n    message:\r\n      `<template> with no special directives will render as a native template ` +\r\n      `element instead of its inner content in Vue 3.`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE]: {\r\n    message: `\"inline-template\" has been removed in Vue 3.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_FILTERS]: {\r\n    message:\r\n      `filters have been removed in Vue 3. ` +\r\n      `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\r\n      `Use method calls or computed properties instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\r\n  }\r\n}\r\n\r\nfunction getCompatValue(\r\n  key: CompilerDeprecationTypes | 'MODE',\r\n  context: ParserContext | TransformContext\r\n) {\r\n  const config = (context as ParserContext).options\r\n    ? (context as ParserContext).options.compatConfig\r\n    : (context as TransformContext).compatConfig\r\n  const value = config && config[key]\r\n  if (key === 'MODE') {\r\n    return value || 3 // compiler defaults to v3 behavior\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nexport function isCompatEnabled(\r\n  key: CompilerDeprecationTypes,\r\n  context: ParserContext | TransformContext\r\n) {\r\n  const mode = getCompatValue('MODE', context)\r\n  const value = getCompatValue(key, context)\r\n  // in v3 mode, only enable if explicitly set to true\r\n  // otherwise enable for any non-false value\r\n  return mode === 3 ? value === true : value !== false\r\n}\r\n\r\nexport function checkCompatEnabled(\r\n  key: CompilerDeprecationTypes,\r\n  context: ParserContext | TransformContext,\r\n  loc: SourceLocation | null,\r\n  ...args: any[]\r\n): boolean {\r\n  const enabled = isCompatEnabled(key, context)\r\n  if (__DEV__ && enabled) {\r\n    warnDeprecation(key, context, loc, ...args)\r\n  }\r\n  return enabled\r\n}\r\n\r\nexport function warnDeprecation(\r\n  key: CompilerDeprecationTypes,\r\n  context: ParserContext | TransformContext,\r\n  loc: SourceLocation | null,\r\n  ...args: any[]\r\n) {\r\n  const val = getCompatValue(key, context)\r\n  if (val === 'suppress-warning') {\r\n    return\r\n  }\r\n  const { message, link } = deprecationData[key]\r\n  const msg = `(deprecation ${key}) ${\r\n    typeof message === 'function' ? message(...args) : message\r\n  }${link ? `\\n  Details: ${link}` : ``}`\r\n\r\n  const err = new SyntaxError(msg) as CompilerError\r\n  err.code = key\r\n  if (loc) err.loc = loc\r\n  context.onWarn(err)\r\n}\r\n","import { ErrorHandlingOptions, ParserOptions } from './options'\r\nimport { NO, isArray, makeMap, extend } from '@vue/shared'\r\nimport {\r\n  ErrorCodes,\r\n  createCompilerError,\r\n  defaultOnError,\r\n  defaultOnWarn\r\n} from './errors'\r\nimport {\r\n  assert,\r\n  advancePositionWithMutation,\r\n  advancePositionWithClone,\r\n  isCoreComponent,\r\n  isStaticArgOf\r\n} from './utils'\r\nimport {\r\n  Namespaces,\r\n  AttributeNode,\r\n  CommentNode,\r\n  DirectiveNode,\r\n  ElementNode,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  NodeTypes,\r\n  Position,\r\n  RootNode,\r\n  SourceLocation,\r\n  TextNode,\r\n  TemplateChildNode,\r\n  InterpolationNode,\r\n  createRoot,\r\n  ConstantTypes\r\n} from './ast'\r\nimport {\r\n  checkCompatEnabled,\r\n  CompilerCompatOptions,\r\n  CompilerDeprecationTypes,\r\n  isCompatEnabled,\r\n  warnDeprecation\r\n} from './compat/compatConfig'\r\n\r\ntype OptionalOptions =\r\n  | 'whitespace'\r\n  | 'isNativeTag'\r\n  | 'isBuiltInComponent'\r\n  | keyof CompilerCompatOptions\r\ntype MergedParserOptions = Omit<Required<ParserOptions>, OptionalOptions> &\r\n  Pick<ParserOptions, OptionalOptions>\r\ntype AttributeValue =\r\n  | {\r\n      content: string\r\n      isQuoted: boolean\r\n      loc: SourceLocation\r\n    }\r\n  | undefined\r\n\r\n// The default decoder only provides escapes for characters reserved as part of\r\n// the template syntax, and is only used if the custom renderer did not provide\r\n// a platform-specific decoder.\r\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g\r\nconst decodeMap: Record<string, string> = {\r\n  gt: '>',\r\n  lt: '<',\r\n  amp: '&',\r\n  apos: \"'\",\r\n  quot: '\"'\r\n}\r\n\r\nexport const defaultParserOptions: MergedParserOptions = {\r\n  delimiters: [`{{`, `}}`],\r\n  getNamespace: () => Namespaces.HTML,\r\n  getTextMode: () => TextModes.DATA,\r\n  isVoidTag: NO,\r\n  isPreTag: NO,\r\n  isCustomElement: NO,\r\n  decodeEntities: (rawText: string): string =>\r\n    rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\r\n  onError: defaultOnError,\r\n  onWarn: defaultOnWarn,\r\n  comments: __DEV__\r\n}\r\n\r\nexport const enum TextModes {\r\n  //          | Elements | Entities | End sign              | Inside of\r\n  DATA, //    |         |         | End tags of ancestors |\r\n  RCDATA, //  |         |         | End tag of the parent | <textarea>\r\n  RAWTEXT, // |         |         | End tag of the parent | <style>,<script>\r\n  CDATA,\r\n  ATTRIBUTE_VALUE\r\n}\r\n\r\nexport interface ParserContext {\r\n  options: MergedParserOptions\r\n  readonly originalSource: string\r\n  source: string\r\n  offset: number\r\n  line: number\r\n  column: number\r\n  inPre: boolean // HTML <pre> tag, preserve whitespaces\r\n  inVPre: boolean // v-pre, do not process directives and interpolations\r\n  onWarn: NonNullable<ErrorHandlingOptions['onWarn']>\r\n}\r\n\r\nexport function baseParse(\r\n  content: string,\r\n  options: ParserOptions = {}\r\n): RootNode {\r\n  const context = createParserContext(content, options)\r\n  const start = getCursor(context)\r\n  return createRoot(\r\n    parseChildren(context, TextModes.DATA, []),\r\n    getSelection(context, start)\r\n  )\r\n}\r\n\r\nfunction createParserContext(\r\n  content: string,\r\n  rawOptions: ParserOptions\r\n): ParserContext {\r\n  const options = extend({}, defaultParserOptions)\r\n\r\n  let key: keyof ParserOptions\r\n  for (key in rawOptions) {\r\n    // @ts-ignore\r\n    options[key] =\r\n      rawOptions[key] === undefined\r\n        ? defaultParserOptions[key]\r\n        : rawOptions[key]\r\n  }\r\n  return {\r\n    options,\r\n    column: 1,\r\n    line: 1,\r\n    offset: 0,\r\n    originalSource: content,\r\n    source: content,\r\n    inPre: false,\r\n    inVPre: false,\r\n    onWarn: options.onWarn\r\n  }\r\n}\r\n\r\nfunction parseChildren(\r\n  context: ParserContext,\r\n  mode: TextModes,\r\n  ancestors: ElementNode[]\r\n): TemplateChildNode[] {\r\n  const parent = last(ancestors)\r\n  const ns = parent ? parent.ns : Namespaces.HTML\r\n  const nodes: TemplateChildNode[] = []\r\n\r\n  while (!isEnd(context, mode, ancestors)) {\r\n    __TEST__ && assert(context.source.length > 0)\r\n    const s = context.source\r\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\r\n\r\n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\r\n      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\r\n        // '{{'\r\n        node = parseInterpolation(context, mode)\r\n      } else if (mode === TextModes.DATA && s[0] === '<') {\r\n        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n        if (s.length === 1) {\r\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\r\n        } else if (s[1] === '!') {\r\n          // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n          if (startsWith(s, '<!--')) {\r\n            node = parseComment(context)\r\n          } else if (startsWith(s, '<!DOCTYPE')) {\r\n            // Ignore DOCTYPE by a limitation.\r\n            node = parseBogusComment(context)\r\n          } else if (startsWith(s, '<![CDATA[')) {\r\n            if (ns !== Namespaces.HTML) {\r\n              node = parseCDATA(context, ancestors)\r\n            } else {\r\n              emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\r\n              node = parseBogusComment(context)\r\n            }\r\n          } else {\r\n            emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\r\n            node = parseBogusComment(context)\r\n          }\r\n        } else if (s[1] === '/') {\r\n          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n          if (s.length === 2) {\r\n            emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\r\n          } else if (s[2] === '>') {\r\n            emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\r\n            advanceBy(context, 3)\r\n            continue\r\n          } else if (/[a-z]/i.test(s[2])) {\r\n            emitError(context, ErrorCodes.X_INVALID_END_TAG)\r\n            parseTag(context, TagType.End, parent)\r\n            continue\r\n          } else {\r\n            emitError(\r\n              context,\r\n              ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,\r\n              2\r\n            )\r\n            node = parseBogusComment(context)\r\n          }\r\n        } else if (/[a-z]/i.test(s[1])) {\r\n          node = parseElement(context, ancestors)\r\n\r\n          // 2.x <template> with no directive compat\r\n          if (\r\n            __COMPAT__ &&\r\n            isCompatEnabled(\r\n              CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\r\n              context\r\n            ) &&\r\n            node &&\r\n            node.tag === 'template' &&\r\n            !node.props.some(\r\n              p =>\r\n                p.type === NodeTypes.DIRECTIVE &&\r\n                isSpecialTemplateDirective(p.name)\r\n            )\r\n          ) {\r\n            __DEV__ &&\r\n              warnDeprecation(\r\n                CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\r\n                context,\r\n                node.loc\r\n              )\r\n            node = node.children\r\n          }\r\n        } else if (s[1] === '?') {\r\n          emitError(\r\n            context,\r\n            ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\r\n            1\r\n          )\r\n          node = parseBogusComment(context)\r\n        } else {\r\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\r\n        }\r\n      }\r\n    }\r\n    if (!node) {\r\n      node = parseText(context, mode)\r\n    }\r\n\r\n    if (isArray(node)) {\r\n      for (let i = 0; i < node.length; i++) {\r\n        pushNode(nodes, node[i])\r\n      }\r\n    } else {\r\n      pushNode(nodes, node)\r\n    }\r\n  }\r\n\r\n  // Whitespace handling strategy like v2\r\n  let removedWhitespace = false\r\n  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {\r\n    const shouldCondense = context.options.whitespace !== 'preserve'\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i]\r\n      if (!context.inPre && node.type === NodeTypes.TEXT) {\r\n        if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n          const prev = nodes[i - 1]\r\n          const next = nodes[i + 1]\r\n          // Remove if:\r\n          // - the whitespace is the first or last node, or:\r\n          // - (condense mode) the whitespace is adjacent to a comment, or:\r\n          // - (condense mode) the whitespace is between two elements AND contains newline\r\n          if (\r\n            !prev ||\r\n            !next ||\r\n            (shouldCondense &&\r\n              (prev.type === NodeTypes.COMMENT ||\r\n                next.type === NodeTypes.COMMENT ||\r\n                (prev.type === NodeTypes.ELEMENT &&\r\n                  next.type === NodeTypes.ELEMENT &&\r\n                  /[\\r\\n]/.test(node.content))))\r\n          ) {\r\n            removedWhitespace = true\r\n            nodes[i] = null as any\r\n          } else {\r\n            // Otherwise, the whitespace is condensed into a single space\r\n            node.content = ' '\r\n          }\r\n        } else if (shouldCondense) {\r\n          // in condense mode, consecutive whitespaces in text are condensed\r\n          // down to a single space.\r\n          node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ')\r\n        }\r\n      }\r\n      // Remove comment nodes if desired by configuration.\r\n      else if (node.type === NodeTypes.COMMENT && !context.options.comments) {\r\n        removedWhitespace = true\r\n        nodes[i] = null as any\r\n      }\r\n    }\r\n    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\r\n      // remove leading newline per html spec\r\n      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n      const first = nodes[0]\r\n      if (first && first.type === NodeTypes.TEXT) {\r\n        first.content = first.content.replace(/^\\r?\\n/, '')\r\n      }\r\n    }\r\n  }\r\n\r\n  return removedWhitespace ? nodes.filter(Boolean) : nodes\r\n}\r\n\r\nfunction pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void {\r\n  if (node.type === NodeTypes.TEXT) {\r\n    const prev = last(nodes)\r\n    // Merge if both this and the previous node are text and those are\r\n    // consecutive. This happens for cases like \"a < b\".\r\n    if (\r\n      prev &&\r\n      prev.type === NodeTypes.TEXT &&\r\n      prev.loc.end.offset === node.loc.start.offset\r\n    ) {\r\n      prev.content += node.content\r\n      prev.loc.end = node.loc.end\r\n      prev.loc.source += node.loc.source\r\n      return\r\n    }\r\n  }\r\n\r\n  nodes.push(node)\r\n}\r\n\r\nfunction parseCDATA(\r\n  context: ParserContext,\r\n  ancestors: ElementNode[]\r\n): TemplateChildNode[] {\r\n  __TEST__ &&\r\n    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)\r\n  __TEST__ && assert(startsWith(context.source, '<![CDATA['))\r\n\r\n  advanceBy(context, 9)\r\n  const nodes = parseChildren(context, TextModes.CDATA, ancestors)\r\n  if (context.source.length === 0) {\r\n    emitError(context, ErrorCodes.EOF_IN_CDATA)\r\n  } else {\r\n    __TEST__ && assert(startsWith(context.source, ']]>'))\r\n    advanceBy(context, 3)\r\n  }\r\n\r\n  return nodes\r\n}\r\n\r\nfunction parseComment(context: ParserContext): CommentNode {\r\n  __TEST__ && assert(startsWith(context.source, '<!--'))\r\n\r\n  const start = getCursor(context)\r\n  let content: string\r\n\r\n  // Regular comment.\r\n  const match = /--(\\!)?>/.exec(context.source)\r\n  if (!match) {\r\n    content = context.source.slice(4)\r\n    advanceBy(context, context.source.length)\r\n    emitError(context, ErrorCodes.EOF_IN_COMMENT)\r\n  } else {\r\n    if (match.index <= 3) {\r\n      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)\r\n    }\r\n    if (match[1]) {\r\n      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)\r\n    }\r\n    content = context.source.slice(4, match.index)\r\n\r\n    // Advancing with reporting nested comments.\r\n    const s = context.source.slice(0, match.index)\r\n    let prevIndex = 1,\r\n      nestedIndex = 0\r\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\r\n      advanceBy(context, nestedIndex - prevIndex + 1)\r\n      if (nestedIndex + 4 < s.length) {\r\n        emitError(context, ErrorCodes.NESTED_COMMENT)\r\n      }\r\n      prevIndex = nestedIndex + 1\r\n    }\r\n    advanceBy(context, match.index + match[0].length - prevIndex + 1)\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.COMMENT,\r\n    content,\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\nfunction parseBogusComment(context: ParserContext): CommentNode | undefined {\r\n  __TEST__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source))\r\n\r\n  const start = getCursor(context)\r\n  const contentStart = context.source[1] === '?' ? 1 : 2\r\n  let content: string\r\n\r\n  const closeIndex = context.source.indexOf('>')\r\n  if (closeIndex === -1) {\r\n    content = context.source.slice(contentStart)\r\n    advanceBy(context, context.source.length)\r\n  } else {\r\n    content = context.source.slice(contentStart, closeIndex)\r\n    advanceBy(context, closeIndex + 1)\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.COMMENT,\r\n    content,\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\nfunction parseElement(\r\n  context: ParserContext,\r\n  ancestors: ElementNode[]\r\n): ElementNode | undefined {\r\n  __TEST__ && assert(/^<[a-z]/i.test(context.source))\r\n\r\n  // Start tag.\r\n  const wasInPre = context.inPre\r\n  const wasInVPre = context.inVPre\r\n  const parent = last(ancestors)\r\n  const element = parseTag(context, TagType.Start, parent)\r\n  const isPreBoundary = context.inPre && !wasInPre\r\n  const isVPreBoundary = context.inVPre && !wasInVPre\r\n\r\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n    // #4030 self-closing <pre> tag\r\n    if (isPreBoundary) {\r\n      context.inPre = false\r\n    }\r\n    if (isVPreBoundary) {\r\n      context.inVPre = false\r\n    }\r\n    return element\r\n  }\r\n\r\n  // Children.\r\n  ancestors.push(element)\r\n  const mode = context.options.getTextMode(element, parent)\r\n  const children = parseChildren(context, mode, ancestors)\r\n  ancestors.pop()\r\n\r\n  // 2.x inline-template compat\r\n  if (__COMPAT__) {\r\n    const inlineTemplateProp = element.props.find(\r\n      p => p.type === NodeTypes.ATTRIBUTE && p.name === 'inline-template'\r\n    ) as AttributeNode\r\n    if (\r\n      inlineTemplateProp &&\r\n      checkCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE,\r\n        context,\r\n        inlineTemplateProp.loc\r\n      )\r\n    ) {\r\n      const loc = getSelection(context, element.loc.end)\r\n      inlineTemplateProp.value = {\r\n        type: NodeTypes.TEXT,\r\n        content: loc.source,\r\n        loc\r\n      }\r\n    }\r\n  }\r\n\r\n  element.children = children\r\n\r\n  // End tag.\r\n  if (startsWithEndTagOpen(context.source, element.tag)) {\r\n    parseTag(context, TagType.End, parent)\r\n  } else {\r\n    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)\r\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\r\n      const first = children[0]\r\n      if (first && startsWith(first.loc.source, '<!--')) {\r\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\r\n      }\r\n    }\r\n  }\r\n\r\n  element.loc = getSelection(context, element.loc.start)\r\n\r\n  if (isPreBoundary) {\r\n    context.inPre = false\r\n  }\r\n  if (isVPreBoundary) {\r\n    context.inVPre = false\r\n  }\r\n  return element\r\n}\r\n\r\nconst enum TagType {\r\n  Start,\r\n  End\r\n}\r\n\r\nconst isSpecialTemplateDirective = /*#__PURE__*/ makeMap(\r\n  `if,else,else-if,for,slot`\r\n)\r\n\r\n/**\r\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\r\n */\r\nfunction parseTag(\r\n  context: ParserContext,\r\n  type: TagType.Start,\r\n  parent: ElementNode | undefined\r\n): ElementNode\r\nfunction parseTag(\r\n  context: ParserContext,\r\n  type: TagType.End,\r\n  parent: ElementNode | undefined\r\n): void\r\nfunction parseTag(\r\n  context: ParserContext,\r\n  type: TagType,\r\n  parent: ElementNode | undefined\r\n): ElementNode | undefined {\r\n  __TEST__ && assert(/^<\\/?[a-z]/i.test(context.source))\r\n  __TEST__ &&\r\n    assert(\r\n      type === (startsWith(context.source, '</') ? TagType.End : TagType.Start)\r\n    )\r\n\r\n  // Tag open.\r\n  const start = getCursor(context)\r\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\r\n  const tag = match[1]\r\n  const ns = context.options.getNamespace(tag, parent)\r\n\r\n  advanceBy(context, match[0].length)\r\n  advanceSpaces(context)\r\n\r\n  // save current state in case we need to re-parse attributes with v-pre\r\n  const cursor = getCursor(context)\r\n  const currentSource = context.source\r\n\r\n  // check <pre> tag\r\n  if (context.options.isPreTag(tag)) {\r\n    context.inPre = true\r\n  }\r\n\r\n  // Attributes.\r\n  let props = parseAttributes(context, type)\r\n\r\n  // check v-pre\r\n  if (\r\n    type === TagType.Start &&\r\n    !context.inVPre &&\r\n    props.some(p => p.type === NodeTypes.DIRECTIVE && p.name === 'pre')\r\n  ) {\r\n    context.inVPre = true\r\n    // reset context\r\n    extend(context, cursor)\r\n    context.source = currentSource\r\n    // re-parse attrs and filter out v-pre itself\r\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre')\r\n  }\r\n\r\n  // Tag close.\r\n  let isSelfClosing = false\r\n  if (context.source.length === 0) {\r\n    emitError(context, ErrorCodes.EOF_IN_TAG)\r\n  } else {\r\n    isSelfClosing = startsWith(context.source, '/>')\r\n    if (type === TagType.End && isSelfClosing) {\r\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\r\n    }\r\n    advanceBy(context, isSelfClosing ? 2 : 1)\r\n  }\r\n\r\n  if (type === TagType.End) {\r\n    return\r\n  }\r\n\r\n  // 2.x deprecation checks\r\n  if (\r\n    __COMPAT__ &&\r\n    __DEV__ &&\r\n    isCompatEnabled(\r\n      CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\r\n      context\r\n    )\r\n  ) {\r\n    let hasIf = false\r\n    let hasFor = false\r\n    for (let i = 0; i < props.length; i++) {\r\n      const p = props[i]\r\n      if (p.type === NodeTypes.DIRECTIVE) {\r\n        if (p.name === 'if') {\r\n          hasIf = true\r\n        } else if (p.name === 'for') {\r\n          hasFor = true\r\n        }\r\n      }\r\n      if (hasIf && hasFor) {\r\n        warnDeprecation(\r\n          CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\r\n          context,\r\n          getSelection(context, start)\r\n        )\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  let tagType = ElementTypes.ELEMENT\r\n  if (!context.inVPre) {\r\n    if (tag === 'slot') {\r\n      tagType = ElementTypes.SLOT\r\n    } else if (tag === 'template') {\r\n      if (\r\n        props.some(\r\n          p =>\r\n            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)\r\n        )\r\n      ) {\r\n        tagType = ElementTypes.TEMPLATE\r\n      }\r\n    } else if (isComponent(tag, props, context)) {\r\n      tagType = ElementTypes.COMPONENT\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.ELEMENT,\r\n    ns,\r\n    tag,\r\n    tagType,\r\n    props,\r\n    isSelfClosing,\r\n    children: [],\r\n    loc: getSelection(context, start),\r\n    codegenNode: undefined // to be created during transform phase\r\n  }\r\n}\r\n\r\nfunction isComponent(\r\n  tag: string,\r\n  props: (AttributeNode | DirectiveNode)[],\r\n  context: ParserContext\r\n) {\r\n  const options = context.options\r\n  if (options.isCustomElement(tag)) {\r\n    return false\r\n  }\r\n  if (\r\n    tag === 'component' ||\r\n    /^[A-Z]/.test(tag) ||\r\n    isCoreComponent(tag) ||\r\n    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\r\n    (options.isNativeTag && !options.isNativeTag(tag))\r\n  ) {\r\n    return true\r\n  }\r\n  // at this point the tag should be a native tag, but check for potential \"is\"\r\n  // casting\r\n  for (let i = 0; i < props.length; i++) {\r\n    const p = props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (p.name === 'is' && p.value) {\r\n        if (p.value.content.startsWith('vue:')) {\r\n          return true\r\n        } else if (\r\n          __COMPAT__ &&\r\n          checkCompatEnabled(\r\n            CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n            context,\r\n            p.loc\r\n          )\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n    } else {\r\n      // directive\r\n      // v-is (TODO Deprecate)\r\n      if (p.name === 'is') {\r\n        return true\r\n      } else if (\r\n        // :is on plain element - only treat as component in compat mode\r\n        p.name === 'bind' &&\r\n        isStaticArgOf(p.arg, 'is') &&\r\n        __COMPAT__ &&\r\n        checkCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n          context,\r\n          p.loc\r\n        )\r\n      ) {\r\n        return true\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction parseAttributes(\r\n  context: ParserContext,\r\n  type: TagType\r\n): (AttributeNode | DirectiveNode)[] {\r\n  const props = []\r\n  const attributeNames = new Set<string>()\r\n  while (\r\n    context.source.length > 0 &&\r\n    !startsWith(context.source, '>') &&\r\n    !startsWith(context.source, '/>')\r\n  ) {\r\n    if (startsWith(context.source, '/')) {\r\n      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)\r\n      advanceBy(context, 1)\r\n      advanceSpaces(context)\r\n      continue\r\n    }\r\n    if (type === TagType.End) {\r\n      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)\r\n    }\r\n\r\n    const attr = parseAttribute(context, attributeNames)\r\n\r\n    // Trim whitespace between class\r\n    // https://github.com/vuejs/core/issues/4251\r\n    if (\r\n      attr.type === NodeTypes.ATTRIBUTE &&\r\n      attr.value &&\r\n      attr.name === 'class'\r\n    ) {\r\n      attr.value.content = attr.value.content.replace(/\\s+/g, ' ').trim()\r\n    }\r\n\r\n    if (type === TagType.Start) {\r\n      props.push(attr)\r\n    }\r\n\r\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)\r\n    }\r\n    advanceSpaces(context)\r\n  }\r\n  return props\r\n}\r\n\r\nfunction parseAttribute(\r\n  context: ParserContext,\r\n  nameSet: Set<string>\r\n): AttributeNode | DirectiveNode {\r\n  __TEST__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source))\r\n\r\n  // Name.\r\n  const start = getCursor(context)\r\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)!\r\n  const name = match[0]\r\n\r\n  if (nameSet.has(name)) {\r\n    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)\r\n  }\r\n  nameSet.add(name)\r\n\r\n  if (name[0] === '=') {\r\n    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)\r\n  }\r\n  {\r\n    const pattern = /[\"'<]/g\r\n    let m: RegExpExecArray | null\r\n    while ((m = pattern.exec(name))) {\r\n      emitError(\r\n        context,\r\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\r\n        m.index\r\n      )\r\n    }\r\n  }\r\n\r\n  advanceBy(context, name.length)\r\n\r\n  // Value\r\n  let value: AttributeValue = undefined\r\n\r\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n    advanceSpaces(context)\r\n    advanceBy(context, 1)\r\n    advanceSpaces(context)\r\n    value = parseAttributeValue(context)\r\n    if (!value) {\r\n      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)\r\n    }\r\n  }\r\n  const loc = getSelection(context, start)\r\n\r\n  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\r\n    const match =\r\n      /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(\r\n        name\r\n      )!\r\n\r\n    let isPropShorthand = startsWith(name, '.')\r\n    let dirName =\r\n      match[1] ||\r\n      (isPropShorthand || startsWith(name, ':')\r\n        ? 'bind'\r\n        : startsWith(name, '@')\r\n        ? 'on'\r\n        : 'slot')\r\n    let arg: ExpressionNode | undefined\r\n\r\n    if (match[2]) {\r\n      const isSlot = dirName === 'slot'\r\n      const startOffset = name.lastIndexOf(match[2])\r\n      const loc = getSelection(\r\n        context,\r\n        getNewPosition(context, start, startOffset),\r\n        getNewPosition(\r\n          context,\r\n          start,\r\n          startOffset + match[2].length + ((isSlot && match[3]) || '').length\r\n        )\r\n      )\r\n      let content = match[2]\r\n      let isStatic = true\r\n\r\n      if (content.startsWith('[')) {\r\n        isStatic = false\r\n\r\n        if (!content.endsWith(']')) {\r\n          emitError(\r\n            context,\r\n            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\r\n          )\r\n          content = content.slice(1)\r\n        } else {\r\n          content = content.slice(1, content.length - 1)\r\n        }\r\n      } else if (isSlot) {\r\n        // #1241 special case for v-slot: vuetify relies extensively on slot\r\n        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\r\n        // supports such usage so we are keeping it consistent with 2.x.\r\n        content += match[3] || ''\r\n      }\r\n\r\n      arg = {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content,\r\n        isStatic,\r\n        constType: isStatic\r\n          ? ConstantTypes.CAN_STRINGIFY\r\n          : ConstantTypes.NOT_CONSTANT,\r\n        loc\r\n      }\r\n    }\r\n\r\n    if (value && value.isQuoted) {\r\n      const valueLoc = value.loc\r\n      valueLoc.start.offset++\r\n      valueLoc.start.column++\r\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)\r\n      valueLoc.source = valueLoc.source.slice(1, -1)\r\n    }\r\n\r\n    const modifiers = match[3] ? match[3].slice(1).split('.') : []\r\n    if (isPropShorthand) modifiers.push('prop')\r\n\r\n    // 2.x compat v-bind:foo.sync -> v-model:foo\r\n    if (__COMPAT__ && dirName === 'bind' && arg) {\r\n      if (\r\n        modifiers.includes('sync') &&\r\n        checkCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_V_BIND_SYNC,\r\n          context,\r\n          loc,\r\n          arg.loc.source\r\n        )\r\n      ) {\r\n        dirName = 'model'\r\n        modifiers.splice(modifiers.indexOf('sync'), 1)\r\n      }\r\n\r\n      if (__DEV__ && modifiers.includes('prop')) {\r\n        checkCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_V_BIND_PROP,\r\n          context,\r\n          loc\r\n        )\r\n      }\r\n    }\r\n\r\n    return {\r\n      type: NodeTypes.DIRECTIVE,\r\n      name: dirName,\r\n      exp: value && {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content: value.content,\r\n        isStatic: false,\r\n        // Treat as non-constant by default. This can be potentially set to\r\n        // other values by `transformExpression` to make it eligible for hoisting.\r\n        constType: ConstantTypes.NOT_CONSTANT,\r\n        loc: value.loc\r\n      },\r\n      arg,\r\n      modifiers,\r\n      loc\r\n    }\r\n  }\r\n\r\n  // missing directive name or illegal directive name\r\n  if (!context.inVPre && startsWith(name, 'v-')) {\r\n    emitError(context, ErrorCodes.X_MISSING_DIRECTIVE_NAME)\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.ATTRIBUTE,\r\n    name,\r\n    value: value && {\r\n      type: NodeTypes.TEXT,\r\n      content: value.content,\r\n      loc: value.loc\r\n    },\r\n    loc\r\n  }\r\n}\r\n\r\nfunction parseAttributeValue(context: ParserContext): AttributeValue {\r\n  const start = getCursor(context)\r\n  let content: string\r\n\r\n  const quote = context.source[0]\r\n  const isQuoted = quote === `\"` || quote === `'`\r\n  if (isQuoted) {\r\n    // Quoted value.\r\n    advanceBy(context, 1)\r\n\r\n    const endIndex = context.source.indexOf(quote)\r\n    if (endIndex === -1) {\r\n      content = parseTextData(\r\n        context,\r\n        context.source.length,\r\n        TextModes.ATTRIBUTE_VALUE\r\n      )\r\n    } else {\r\n      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)\r\n      advanceBy(context, 1)\r\n    }\r\n  } else {\r\n    // Unquoted\r\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source)\r\n    if (!match) {\r\n      return undefined\r\n    }\r\n    const unexpectedChars = /[\"'<=`]/g\r\n    let m: RegExpExecArray | null\r\n    while ((m = unexpectedChars.exec(match[0]))) {\r\n      emitError(\r\n        context,\r\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\r\n        m.index\r\n      )\r\n    }\r\n    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)\r\n  }\r\n\r\n  return { content, isQuoted, loc: getSelection(context, start) }\r\n}\r\n\r\nfunction parseInterpolation(\r\n  context: ParserContext,\r\n  mode: TextModes\r\n): InterpolationNode | undefined {\r\n  const [open, close] = context.options.delimiters\r\n  __TEST__ && assert(startsWith(context.source, open))\r\n\r\n  const closeIndex = context.source.indexOf(close, open.length)\r\n  if (closeIndex === -1) {\r\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\r\n    return undefined\r\n  }\r\n\r\n  const start = getCursor(context)\r\n  advanceBy(context, open.length)\r\n  const innerStart = getCursor(context)\r\n  const innerEnd = getCursor(context)\r\n  const rawContentLength = closeIndex - open.length\r\n  const rawContent = context.source.slice(0, rawContentLength)\r\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\r\n  const content = preTrimContent.trim()\r\n  const startOffset = preTrimContent.indexOf(content)\r\n  if (startOffset > 0) {\r\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\r\n  }\r\n  const endOffset =\r\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\r\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\r\n  advanceBy(context, close.length)\r\n\r\n  return {\r\n    type: NodeTypes.INTERPOLATION,\r\n    content: {\r\n      type: NodeTypes.SIMPLE_EXPRESSION,\r\n      isStatic: false,\r\n      // Set `isConstant` to false by default and will decide in transformExpression\r\n      constType: ConstantTypes.NOT_CONSTANT,\r\n      content,\r\n      loc: getSelection(context, innerStart, innerEnd)\r\n    },\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\nfunction parseText(context: ParserContext, mode: TextModes): TextNode {\r\n  __TEST__ && assert(context.source.length > 0)\r\n\r\n  const endTokens =\r\n    mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]\r\n\r\n  let endIndex = context.source.length\r\n  for (let i = 0; i < endTokens.length; i++) {\r\n    const index = context.source.indexOf(endTokens[i], 1)\r\n    if (index !== -1 && endIndex > index) {\r\n      endIndex = index\r\n    }\r\n  }\r\n\r\n  __TEST__ && assert(endIndex > 0)\r\n\r\n  const start = getCursor(context)\r\n  const content = parseTextData(context, endIndex, mode)\r\n\r\n  return {\r\n    type: NodeTypes.TEXT,\r\n    content,\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\n/**\r\n * Get text data with a given length from the current location.\r\n * This translates HTML entities in the text data.\r\n */\r\nfunction parseTextData(\r\n  context: ParserContext,\r\n  length: number,\r\n  mode: TextModes\r\n): string {\r\n  const rawText = context.source.slice(0, length)\r\n  advanceBy(context, length)\r\n  if (\r\n    mode === TextModes.RAWTEXT ||\r\n    mode === TextModes.CDATA ||\r\n    !rawText.includes('&')\r\n  ) {\r\n    return rawText\r\n  } else {\r\n    // DATA or RCDATA containing \"&\"\". Entity decoding required.\r\n    return context.options.decodeEntities(\r\n      rawText,\r\n      mode === TextModes.ATTRIBUTE_VALUE\r\n    )\r\n  }\r\n}\r\n\r\nfunction getCursor(context: ParserContext): Position {\r\n  const { column, line, offset } = context\r\n  return { column, line, offset }\r\n}\r\n\r\nfunction getSelection(\r\n  context: ParserContext,\r\n  start: Position,\r\n  end?: Position\r\n): SourceLocation {\r\n  end = end || getCursor(context)\r\n  return {\r\n    start,\r\n    end,\r\n    source: context.originalSource.slice(start.offset, end.offset)\r\n  }\r\n}\r\n\r\nfunction last<T>(xs: T[]): T | undefined {\r\n  return xs[xs.length - 1]\r\n}\r\n\r\nfunction startsWith(source: string, searchString: string): boolean {\r\n  return source.startsWith(searchString)\r\n}\r\n\r\nfunction advanceBy(context: ParserContext, numberOfCharacters: number): void {\r\n  const { source } = context\r\n  __TEST__ && assert(numberOfCharacters <= source.length)\r\n  advancePositionWithMutation(context, source, numberOfCharacters)\r\n  context.source = source.slice(numberOfCharacters)\r\n}\r\n\r\nfunction advanceSpaces(context: ParserContext): void {\r\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\r\n  if (match) {\r\n    advanceBy(context, match[0].length)\r\n  }\r\n}\r\n\r\nfunction getNewPosition(\r\n  context: ParserContext,\r\n  start: Position,\r\n  numberOfCharacters: number\r\n): Position {\r\n  return advancePositionWithClone(\r\n    start,\r\n    context.originalSource.slice(start.offset, numberOfCharacters),\r\n    numberOfCharacters\r\n  )\r\n}\r\n\r\nfunction emitError(\r\n  context: ParserContext,\r\n  code: ErrorCodes,\r\n  offset?: number,\r\n  loc: Position = getCursor(context)\r\n): void {\r\n  if (offset) {\r\n    loc.offset += offset\r\n    loc.column += offset\r\n  }\r\n  context.options.onError(\r\n    createCompilerError(code, {\r\n      start: loc,\r\n      end: loc,\r\n      source: ''\r\n    })\r\n  )\r\n}\r\n\r\nfunction isEnd(\r\n  context: ParserContext,\r\n  mode: TextModes,\r\n  ancestors: ElementNode[]\r\n): boolean {\r\n  const s = context.source\r\n\r\n  switch (mode) {\r\n    case TextModes.DATA:\r\n      if (startsWith(s, '</')) {\r\n        // TODO: probably bad performance\r\n        for (let i = ancestors.length - 1; i >= 0; --i) {\r\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n            return true\r\n          }\r\n        }\r\n      }\r\n      break\r\n\r\n    case TextModes.RCDATA:\r\n    case TextModes.RAWTEXT: {\r\n      const parent = last(ancestors)\r\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n        return true\r\n      }\r\n      break\r\n    }\r\n\r\n    case TextModes.CDATA:\r\n      if (startsWith(s, ']]>')) {\r\n        return true\r\n      }\r\n      break\r\n  }\r\n\r\n  return !s\r\n}\r\n\r\nfunction startsWithEndTagOpen(source: string, tag: string): boolean {\r\n  return (\r\n    startsWith(source, '</') &&\r\n    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&\r\n    /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>')\r\n  )\r\n}\r\n","import {\r\n  ConstantTypes,\r\n  RootNode,\r\n  NodeTypes,\r\n  TemplateChildNode,\r\n  SimpleExpressionNode,\r\n  ElementTypes,\r\n  PlainElementNode,\r\n  ComponentNode,\r\n  TemplateNode,\r\n  VNodeCall,\r\n  ParentNode,\r\n  JSChildNode,\r\n  CallExpression,\r\n  createArrayExpression\r\n} from '../ast'\r\nimport { TransformContext } from '../transform'\r\nimport { PatchFlags, isString, isSymbol, isArray } from '@vue/shared'\r\nimport { getVNodeBlockHelper, getVNodeHelper, isSlotOutlet } from '../utils'\r\nimport {\r\n  OPEN_BLOCK,\r\n  GUARD_REACTIVE_PROPS,\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_PROPS,\r\n  NORMALIZE_STYLE\r\n} from '../runtimeHelpers'\r\n\r\nexport function hoistStatic(root: RootNode, context: TransformContext) {\r\n  walk(\r\n    root,\r\n    context,\r\n    // Root node is unfortunately non-hoistable due to potential parent\r\n    // fallthrough attributes.\r\n    isSingleElementRoot(root, root.children[0])\r\n  )\r\n}\r\n\r\nexport function isSingleElementRoot(\r\n  root: RootNode,\r\n  child: TemplateChildNode\r\n): child is PlainElementNode | ComponentNode | TemplateNode {\r\n  const { children } = root\r\n  return (\r\n    children.length === 1 &&\r\n    child.type === NodeTypes.ELEMENT &&\r\n    !isSlotOutlet(child)\r\n  )\r\n}\r\n\r\nfunction walk(\r\n  node: ParentNode,\r\n  context: TransformContext,\r\n  doNotHoistNode: boolean = false\r\n) {\r\n  const { children } = node\r\n  const originalCount = children.length\r\n  let hoistedCount = 0\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    // only plain elements & text calls are eligible for hoisting.\r\n    if (\r\n      child.type === NodeTypes.ELEMENT &&\r\n      child.tagType === ElementTypes.ELEMENT\r\n    ) {\r\n      const constantType = doNotHoistNode\r\n        ? ConstantTypes.NOT_CONSTANT\r\n        : getConstantType(child, context)\r\n      if (constantType > ConstantTypes.NOT_CONSTANT) {\r\n        if (constantType >= ConstantTypes.CAN_HOIST) {\r\n          ;(child.codegenNode as VNodeCall).patchFlag =\r\n            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)\r\n          child.codegenNode = context.hoist(child.codegenNode!)\r\n          hoistedCount++\r\n          continue\r\n        }\r\n      } else {\r\n        // node may contain dynamic children, but its props may be eligible for\r\n        // hoisting.\r\n        const codegenNode = child.codegenNode!\r\n        if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n          const flag = getPatchFlag(codegenNode)\r\n          if (\r\n            (!flag ||\r\n              flag === PatchFlags.NEED_PATCH ||\r\n              flag === PatchFlags.TEXT) &&\r\n            getGeneratedPropsConstantType(child, context) >=\r\n              ConstantTypes.CAN_HOIST\r\n          ) {\r\n            const props = getNodeProps(child)\r\n            if (props) {\r\n              codegenNode.props = context.hoist(props)\r\n            }\r\n          }\r\n          if (codegenNode.dynamicProps) {\r\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)\r\n          }\r\n        }\r\n      }\r\n    } else if (\r\n      child.type === NodeTypes.TEXT_CALL &&\r\n      getConstantType(child.content, context) >= ConstantTypes.CAN_HOIST\r\n    ) {\r\n      child.codegenNode = context.hoist(child.codegenNode)\r\n      hoistedCount++\r\n    }\r\n\r\n    // walk further\r\n    if (child.type === NodeTypes.ELEMENT) {\r\n      const isComponent = child.tagType === ElementTypes.COMPONENT\r\n      if (isComponent) {\r\n        context.scopes.vSlot++\r\n      }\r\n      walk(child, context)\r\n      if (isComponent) {\r\n        context.scopes.vSlot--\r\n      }\r\n    } else if (child.type === NodeTypes.FOR) {\r\n      // Do not hoist v-for single child because it has to be a block\r\n      walk(child, context, child.children.length === 1)\r\n    } else if (child.type === NodeTypes.IF) {\r\n      for (let i = 0; i < child.branches.length; i++) {\r\n        // Do not hoist v-if single child because it has to be a block\r\n        walk(\r\n          child.branches[i],\r\n          context,\r\n          child.branches[i].children.length === 1\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (hoistedCount && context.transformHoist) {\r\n    context.transformHoist(children, context, node)\r\n  }\r\n\r\n  // all children were hoisted - the entire children array is hoistable.\r\n  if (\r\n    hoistedCount &&\r\n    hoistedCount === originalCount &&\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.ELEMENT &&\r\n    node.codegenNode &&\r\n    node.codegenNode.type === NodeTypes.VNODE_CALL &&\r\n    isArray(node.codegenNode.children)\r\n  ) {\r\n    node.codegenNode.children = context.hoist(\r\n      createArrayExpression(node.codegenNode.children)\r\n    )\r\n  }\r\n}\r\n\r\nexport function getConstantType(\r\n  node: TemplateChildNode | SimpleExpressionNode,\r\n  context: TransformContext\r\n): ConstantTypes {\r\n  const { constantCache } = context\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n      if (node.tagType !== ElementTypes.ELEMENT) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      const cached = constantCache.get(node)\r\n      if (cached !== undefined) {\r\n        return cached\r\n      }\r\n      const codegenNode = node.codegenNode!\r\n      if (codegenNode.type !== NodeTypes.VNODE_CALL) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      if (\r\n        codegenNode.isBlock &&\r\n        node.tag !== 'svg' &&\r\n        node.tag !== 'foreignObject'\r\n      ) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      const flag = getPatchFlag(codegenNode)\r\n      if (!flag) {\r\n        let returnType = ConstantTypes.CAN_STRINGIFY\r\n\r\n        // Element itself has no patch flag. However we still need to check:\r\n\r\n        // 1. Even for a node with no patch flag, it is possible for it to contain\r\n        // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n        // injected keys or cached event handlers. Therefore we need to always\r\n        // check the codegenNode's props to be sure.\r\n        const generatedPropsType = getGeneratedPropsConstantType(node, context)\r\n        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {\r\n          constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n          return ConstantTypes.NOT_CONSTANT\r\n        }\r\n        if (generatedPropsType < returnType) {\r\n          returnType = generatedPropsType\r\n        }\r\n\r\n        // 2. its children.\r\n        for (let i = 0; i < node.children.length; i++) {\r\n          const childType = getConstantType(node.children[i], context)\r\n          if (childType === ConstantTypes.NOT_CONSTANT) {\r\n            constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n            return ConstantTypes.NOT_CONSTANT\r\n          }\r\n          if (childType < returnType) {\r\n            returnType = childType\r\n          }\r\n        }\r\n\r\n        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n        // type, check if any of the props can cause the type to be lowered\r\n        // we can skip can_patch because it's guaranteed by the absence of a\r\n        // patchFlag.\r\n        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {\r\n          for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i]\r\n            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {\r\n              const expType = getConstantType(p.exp, context)\r\n              if (expType === ConstantTypes.NOT_CONSTANT) {\r\n                constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n                return ConstantTypes.NOT_CONSTANT\r\n              }\r\n              if (expType < returnType) {\r\n                returnType = expType\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // only svg/foreignObject could be block here, however if they are\r\n        // static then they don't need to be blocks since there will be no\r\n        // nested updates.\r\n        if (codegenNode.isBlock) {\r\n          // except set custom directives.\r\n          for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i]\r\n            if (p.type === NodeTypes.DIRECTIVE) {\r\n              constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n              return ConstantTypes.NOT_CONSTANT\r\n            }\r\n          }\r\n\r\n          context.removeHelper(OPEN_BLOCK)\r\n          context.removeHelper(\r\n            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)\r\n          )\r\n          codegenNode.isBlock = false\r\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))\r\n        }\r\n\r\n        constantCache.set(node, returnType)\r\n        return returnType\r\n      } else {\r\n        constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n    case NodeTypes.TEXT:\r\n    case NodeTypes.COMMENT:\r\n      return ConstantTypes.CAN_STRINGIFY\r\n    case NodeTypes.IF:\r\n    case NodeTypes.FOR:\r\n    case NodeTypes.IF_BRANCH:\r\n      return ConstantTypes.NOT_CONSTANT\r\n    case NodeTypes.INTERPOLATION:\r\n    case NodeTypes.TEXT_CALL:\r\n      return getConstantType(node.content, context)\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      return node.constType\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      let returnType = ConstantTypes.CAN_STRINGIFY\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i]\r\n        if (isString(child) || isSymbol(child)) {\r\n          continue\r\n        }\r\n        const childType = getConstantType(child, context)\r\n        if (childType === ConstantTypes.NOT_CONSTANT) {\r\n          return ConstantTypes.NOT_CONSTANT\r\n        } else if (childType < returnType) {\r\n          returnType = childType\r\n        }\r\n      }\r\n      return returnType\r\n    default:\r\n      if (__DEV__) {\r\n        const exhaustiveCheck: never = node\r\n        exhaustiveCheck\r\n      }\r\n      return ConstantTypes.NOT_CONSTANT\r\n  }\r\n}\r\n\r\nconst allowHoistedHelperSet = new Set([\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_STYLE,\r\n  NORMALIZE_PROPS,\r\n  GUARD_REACTIVE_PROPS\r\n])\r\n\r\nfunction getConstantTypeOfHelperCall(\r\n  value: CallExpression,\r\n  context: TransformContext\r\n): ConstantTypes {\r\n  if (\r\n    value.type === NodeTypes.JS_CALL_EXPRESSION &&\r\n    !isString(value.callee) &&\r\n    allowHoistedHelperSet.has(value.callee)\r\n  ) {\r\n    const arg = value.arguments[0] as JSChildNode\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      return getConstantType(arg, context)\r\n    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\r\n      return getConstantTypeOfHelperCall(arg, context)\r\n    }\r\n  }\r\n  return ConstantTypes.NOT_CONSTANT\r\n}\r\n\r\nfunction getGeneratedPropsConstantType(\r\n  node: PlainElementNode,\r\n  context: TransformContext\r\n): ConstantTypes {\r\n  let returnType = ConstantTypes.CAN_STRINGIFY\r\n  const props = getNodeProps(node)\r\n  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n    const { properties } = props\r\n    for (let i = 0; i < properties.length; i++) {\r\n      const { key, value } = properties[i]\r\n      const keyType = getConstantType(key, context)\r\n      if (keyType === ConstantTypes.NOT_CONSTANT) {\r\n        return keyType\r\n      }\r\n      if (keyType < returnType) {\r\n        returnType = keyType\r\n      }\r\n      let valueType: ConstantTypes\r\n      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n        valueType = getConstantType(value, context)\r\n      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n        // some helper calls can be hoisted,\r\n        // such as the `normalizeProps` generated by the compiler for pre-normalize class,\r\n        // in this case we need to respect the ConstantType of the helper's arguments\r\n        valueType = getConstantTypeOfHelperCall(value, context)\r\n      } else {\r\n        valueType = ConstantTypes.NOT_CONSTANT\r\n      }\r\n      if (valueType === ConstantTypes.NOT_CONSTANT) {\r\n        return valueType\r\n      }\r\n      if (valueType < returnType) {\r\n        returnType = valueType\r\n      }\r\n    }\r\n  }\r\n  return returnType\r\n}\r\n\r\nfunction getNodeProps(node: PlainElementNode) {\r\n  const codegenNode = node.codegenNode!\r\n  if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n    return codegenNode.props\r\n  }\r\n}\r\n\r\nfunction getPatchFlag(node: VNodeCall): number | undefined {\r\n  const flag = node.patchFlag\r\n  return flag ? parseInt(flag, 10) : undefined\r\n}\r\n","import { TransformOptions } from './options'\r\nimport {\r\n  RootNode,\r\n  NodeTypes,\r\n  ParentNode,\r\n  TemplateChildNode,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  Property,\r\n  ExpressionNode,\r\n  createSimpleExpression,\r\n  JSChildNode,\r\n  SimpleExpressionNode,\r\n  ElementTypes,\r\n  CacheExpression,\r\n  createCacheExpression,\r\n  TemplateLiteral,\r\n  createVNodeCall,\r\n  ConstantTypes,\r\n  ArrayExpression\r\n} from './ast'\r\nimport {\r\n  isString,\r\n  isArray,\r\n  NOOP,\r\n  PatchFlags,\r\n  PatchFlagNames,\r\n  EMPTY_OBJ,\r\n  capitalize,\r\n  camelize\r\n} from '@vue/shared'\r\nimport { defaultOnError, defaultOnWarn } from './errors'\r\nimport {\r\n  TO_DISPLAY_STRING,\r\n  FRAGMENT,\r\n  helperNameMap,\r\n  CREATE_COMMENT\r\n} from './runtimeHelpers'\r\nimport { isVSlot, makeBlock } from './utils'\r\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\r\nimport { CompilerCompatOptions } from './compat/compatConfig'\r\n\r\n// There are two types of transforms:\r\n//\r\n// - NodeTransform:\r\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\r\n//   replace or remove the node being processed.\r\nexport type NodeTransform = (\r\n  node: RootNode | TemplateChildNode,\r\n  context: TransformContext\r\n) => void | (() => void) | (() => void)[]\r\n\r\n// - DirectiveTransform:\r\n//   Transforms that handles a single directive attribute on an element.\r\n//   It translates the raw directive into actual props for the VNode.\r\nexport type DirectiveTransform = (\r\n  dir: DirectiveNode,\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  // a platform specific compiler can import the base transform and augment\r\n  // it by passing in this optional argument.\r\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult\r\n) => DirectiveTransformResult\r\n\r\nexport interface DirectiveTransformResult {\r\n  props: Property[]\r\n  needRuntime?: boolean | symbol\r\n  ssrTagParts?: TemplateLiteral['elements']\r\n}\r\n\r\n// A structural directive transform is technically also a NodeTransform;\r\n// Only v-if and v-for fall into this category.\r\nexport type StructuralDirectiveTransform = (\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext\r\n) => void | (() => void)\r\n\r\nexport interface ImportItem {\r\n  exp: string | ExpressionNode\r\n  path: string\r\n}\r\n\r\nexport interface TransformContext\r\n  extends Required<\r\n      Omit<TransformOptions, 'filename' | keyof CompilerCompatOptions>\r\n    >,\r\n    CompilerCompatOptions {\r\n  selfName: string | null\r\n  root: RootNode\r\n  helpers: Map<symbol, number>\r\n  components: Set<string>\r\n  directives: Set<string>\r\n  hoists: (JSChildNode | null)[]\r\n  imports: ImportItem[]\r\n  temps: number\r\n  cached: number\r\n  identifiers: { [name: string]: number | undefined }\r\n  scopes: {\r\n    vFor: number\r\n    vSlot: number\r\n    vPre: number\r\n    vOnce: number\r\n  }\r\n  parent: ParentNode | null\r\n  childIndex: number\r\n  currentNode: RootNode | TemplateChildNode | null\r\n  inVOnce: boolean\r\n  helper<T extends symbol>(name: T): T\r\n  removeHelper<T extends symbol>(name: T): void\r\n  helperString(name: symbol): string\r\n  replaceNode(node: TemplateChildNode): void\r\n  removeNode(node?: TemplateChildNode): void\r\n  onNodeRemoved(): void\r\n  addIdentifiers(exp: ExpressionNode | string): void\r\n  removeIdentifiers(exp: ExpressionNode | string): void\r\n  hoist(exp: string | JSChildNode | ArrayExpression): SimpleExpressionNode\r\n  cache<T extends JSChildNode>(exp: T, isVNode?: boolean): CacheExpression | T\r\n  constantCache: Map<TemplateChildNode, ConstantTypes>\r\n\r\n  // 2.x Compat only\r\n  filters?: Set<string>\r\n}\r\n\r\nexport function createTransformContext(\r\n  root: RootNode,\r\n  {\r\n    filename = '',\r\n    prefixIdentifiers = false,\r\n    hoistStatic = false,\r\n    cacheHandlers = false,\r\n    nodeTransforms = [],\r\n    directiveTransforms = {},\r\n    transformHoist = null,\r\n    isBuiltInComponent = NOOP,\r\n    isCustomElement = NOOP,\r\n    expressionPlugins = [],\r\n    scopeId = null,\r\n    slotted = true,\r\n    ssr = false,\r\n    inSSR = false,\r\n    ssrCssVars = ``,\r\n    bindingMetadata = EMPTY_OBJ,\r\n    inline = false,\r\n    isTS = false,\r\n    onError = defaultOnError,\r\n    onWarn = defaultOnWarn,\r\n    compatConfig\r\n  }: TransformOptions\r\n): TransformContext {\r\n  const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/)\r\n  const context: TransformContext = {\r\n    // options\r\n    selfName: nameMatch && capitalize(camelize(nameMatch[1])),\r\n    prefixIdentifiers,\r\n    hoistStatic,\r\n    cacheHandlers,\r\n    nodeTransforms,\r\n    directiveTransforms,\r\n    transformHoist,\r\n    isBuiltInComponent,\r\n    isCustomElement,\r\n    expressionPlugins,\r\n    scopeId,\r\n    slotted,\r\n    ssr,\r\n    inSSR,\r\n    ssrCssVars,\r\n    bindingMetadata,\r\n    inline,\r\n    isTS,\r\n    onError,\r\n    onWarn,\r\n    compatConfig,\r\n\r\n    // state\r\n    root,\r\n    helpers: new Map(),\r\n    components: new Set(),\r\n    directives: new Set(),\r\n    hoists: [],\r\n    imports: [],\r\n    constantCache: new Map(),\r\n    temps: 0,\r\n    cached: 0,\r\n    identifiers: Object.create(null),\r\n    scopes: {\r\n      vFor: 0,\r\n      vSlot: 0,\r\n      vPre: 0,\r\n      vOnce: 0\r\n    },\r\n    parent: null,\r\n    currentNode: root,\r\n    childIndex: 0,\r\n    inVOnce: false,\r\n\r\n    // methods\r\n    helper(name) {\r\n      const count = context.helpers.get(name) || 0\r\n      context.helpers.set(name, count + 1)\r\n      return name\r\n    },\r\n    removeHelper(name) {\r\n      const count = context.helpers.get(name)\r\n      if (count) {\r\n        const currentCount = count - 1\r\n        if (!currentCount) {\r\n          context.helpers.delete(name)\r\n        } else {\r\n          context.helpers.set(name, currentCount)\r\n        }\r\n      }\r\n    },\r\n    helperString(name) {\r\n      return `_${helperNameMap[context.helper(name)]}`\r\n    },\r\n    replaceNode(node) {\r\n      /* istanbul ignore if */\r\n      if (__DEV__) {\r\n        if (!context.currentNode) {\r\n          throw new Error(`Node being replaced is already removed.`)\r\n        }\r\n        if (!context.parent) {\r\n          throw new Error(`Cannot replace root node.`)\r\n        }\r\n      }\r\n      context.parent!.children[context.childIndex] = context.currentNode = node\r\n    },\r\n    removeNode(node) {\r\n      if (__DEV__ && !context.parent) {\r\n        throw new Error(`Cannot remove root node.`)\r\n      }\r\n      const list = context.parent!.children\r\n      const removalIndex = node\r\n        ? list.indexOf(node)\r\n        : context.currentNode\r\n        ? context.childIndex\r\n        : -1\r\n      /* istanbul ignore if */\r\n      if (__DEV__ && removalIndex < 0) {\r\n        throw new Error(`node being removed is not a child of current parent`)\r\n      }\r\n      if (!node || node === context.currentNode) {\r\n        // current node removed\r\n        context.currentNode = null\r\n        context.onNodeRemoved()\r\n      } else {\r\n        // sibling node removed\r\n        if (context.childIndex > removalIndex) {\r\n          context.childIndex--\r\n          context.onNodeRemoved()\r\n        }\r\n      }\r\n      context.parent!.children.splice(removalIndex, 1)\r\n    },\r\n    onNodeRemoved: () => {},\r\n    addIdentifiers(exp) {\r\n      // identifier tracking only happens in non-browser builds.\r\n      if (!__BROWSER__) {\r\n        if (isString(exp)) {\r\n          addId(exp)\r\n        } else if (exp.identifiers) {\r\n          exp.identifiers.forEach(addId)\r\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          addId(exp.content)\r\n        }\r\n      }\r\n    },\r\n    removeIdentifiers(exp) {\r\n      if (!__BROWSER__) {\r\n        if (isString(exp)) {\r\n          removeId(exp)\r\n        } else if (exp.identifiers) {\r\n          exp.identifiers.forEach(removeId)\r\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          removeId(exp.content)\r\n        }\r\n      }\r\n    },\r\n    hoist(exp) {\r\n      if (isString(exp)) exp = createSimpleExpression(exp)\r\n      context.hoists.push(exp)\r\n      const identifier = createSimpleExpression(\r\n        `_hoisted_${context.hoists.length}`,\r\n        false,\r\n        exp.loc,\r\n        ConstantTypes.CAN_HOIST\r\n      )\r\n      identifier.hoisted = exp\r\n      return identifier\r\n    },\r\n    cache(exp, isVNode = false) {\r\n      return createCacheExpression(context.cached++, exp, isVNode)\r\n    }\r\n  }\r\n\r\n  if (__COMPAT__) {\r\n    context.filters = new Set()\r\n  }\r\n\r\n  function addId(id: string) {\r\n    const { identifiers } = context\r\n    if (identifiers[id] === undefined) {\r\n      identifiers[id] = 0\r\n    }\r\n    identifiers[id]!++\r\n  }\r\n\r\n  function removeId(id: string) {\r\n    context.identifiers[id]!--\r\n  }\r\n\r\n  return context\r\n}\r\n\r\nexport function transform(root: RootNode, options: TransformOptions) {\r\n  const context = createTransformContext(root, options)\r\n  traverseNode(root, context)\r\n  if (options.hoistStatic) {\r\n    hoistStatic(root, context)\r\n  }\r\n  if (!options.ssr) {\r\n    createRootCodegen(root, context)\r\n  }\r\n  // finalize meta information\r\n  root.helpers = [...context.helpers.keys()]\r\n  root.components = [...context.components]\r\n  root.directives = [...context.directives]\r\n  root.imports = context.imports\r\n  root.hoists = context.hoists\r\n  root.temps = context.temps\r\n  root.cached = context.cached\r\n\r\n  if (__COMPAT__) {\r\n    root.filters = [...context.filters!]\r\n  }\r\n}\r\n\r\nfunction createRootCodegen(root: RootNode, context: TransformContext) {\r\n  const { helper } = context\r\n  const { children } = root\r\n  if (children.length === 1) {\r\n    const child = children[0]\r\n    // if the single child is an element, turn it into a block.\r\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n      // single element root is never hoisted so codegenNode will never be\r\n      // SimpleExpressionNode\r\n      const codegenNode = child.codegenNode\r\n      if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n        makeBlock(codegenNode, context)\r\n      }\r\n      root.codegenNode = codegenNode\r\n    } else {\r\n      // - single <slot/>, IfNode, ForNode: already blocks.\r\n      // - single text node: always patched.\r\n      // root codegen falls through via genNode()\r\n      root.codegenNode = child\r\n    }\r\n  } else if (children.length > 1) {\r\n    // root has multiple nodes - return a fragment block.\r\n    let patchFlag = PatchFlags.STABLE_FRAGMENT\r\n    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\r\n    // check if the fragment actually contains a single valid child with\r\n    // the rest being comments\r\n    if (\r\n      __DEV__ &&\r\n      children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\r\n    ) {\r\n      patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\r\n      patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\r\n    }\r\n    root.codegenNode = createVNodeCall(\r\n      context,\r\n      helper(FRAGMENT),\r\n      undefined,\r\n      root.children,\r\n      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\r\n      undefined,\r\n      undefined,\r\n      true,\r\n      undefined,\r\n      false /* isComponent */\r\n    )\r\n  } else {\r\n    // no children = noop. codegen will return null.\r\n  }\r\n}\r\n\r\nexport function traverseChildren(\r\n  parent: ParentNode,\r\n  context: TransformContext\r\n) {\r\n  let i = 0\r\n  const nodeRemoved = () => {\r\n    i--\r\n  }\r\n  for (; i < parent.children.length; i++) {\r\n    const child = parent.children[i]\r\n    if (isString(child)) continue\r\n    context.parent = parent\r\n    context.childIndex = i\r\n    context.onNodeRemoved = nodeRemoved\r\n    traverseNode(child, context)\r\n  }\r\n}\r\n\r\nexport function traverseNode(\r\n  node: RootNode | TemplateChildNode,\r\n  context: TransformContext\r\n) {\r\n  context.currentNode = node\r\n  // apply transform plugins\r\n  const { nodeTransforms } = context\r\n  const exitFns = []\r\n  for (let i = 0; i < nodeTransforms.length; i++) {\r\n    const onExit = nodeTransforms[i](node, context)\r\n    if (onExit) {\r\n      if (isArray(onExit)) {\r\n        exitFns.push(...onExit)\r\n      } else {\r\n        exitFns.push(onExit)\r\n      }\r\n    }\r\n    if (!context.currentNode) {\r\n      // node was removed\r\n      return\r\n    } else {\r\n      // node may have been replaced\r\n      node = context.currentNode\r\n    }\r\n  }\r\n\r\n  switch (node.type) {\r\n    case NodeTypes.COMMENT:\r\n      if (!context.ssr) {\r\n        // inject import for the Comment symbol, which is needed for creating\r\n        // comment nodes with `createVNode`\r\n        context.helper(CREATE_COMMENT)\r\n      }\r\n      break\r\n    case NodeTypes.INTERPOLATION:\r\n      // no need to traverse, but we need to inject toString helper\r\n      if (!context.ssr) {\r\n        context.helper(TO_DISPLAY_STRING)\r\n      }\r\n      break\r\n\r\n    // for container types, further traverse downwards\r\n    case NodeTypes.IF:\r\n      for (let i = 0; i < node.branches.length; i++) {\r\n        traverseNode(node.branches[i], context)\r\n      }\r\n      break\r\n    case NodeTypes.IF_BRANCH:\r\n    case NodeTypes.FOR:\r\n    case NodeTypes.ELEMENT:\r\n    case NodeTypes.ROOT:\r\n      traverseChildren(node, context)\r\n      break\r\n  }\r\n\r\n  // exit transforms\r\n  context.currentNode = node\r\n  let i = exitFns.length\r\n  while (i--) {\r\n    exitFns[i]()\r\n  }\r\n}\r\n\r\nexport function createStructuralDirectiveTransform(\r\n  name: string | RegExp,\r\n  fn: StructuralDirectiveTransform\r\n): NodeTransform {\r\n  const matches = isString(name)\r\n    ? (n: string) => n === name\r\n    : (n: string) => name.test(n)\r\n\r\n  return (node, context) => {\r\n    if (node.type === NodeTypes.ELEMENT) {\r\n      const { props } = node\r\n      // structural directive transforms are not concerned with slots\r\n      // as they are handled separately in vSlot.ts\r\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\r\n        return\r\n      }\r\n      const exitFns = []\r\n      for (let i = 0; i < props.length; i++) {\r\n        const prop = props[i]\r\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\r\n          // structural directives are removed to avoid infinite recursion\r\n          // also we remove them *before* applying so that it can further\r\n          // traverse itself in case it moves the node around\r\n          props.splice(i, 1)\r\n          i--\r\n          const onExit = fn(node, prop, context)\r\n          if (onExit) exitFns.push(onExit)\r\n        }\r\n      }\r\n      return exitFns\r\n    }\r\n  }\r\n}\r\n","import { CodegenOptions } from './options'\r\nimport {\r\n  RootNode,\r\n  TemplateChildNode,\r\n  TextNode,\r\n  CommentNode,\r\n  ExpressionNode,\r\n  NodeTypes,\r\n  JSChildNode,\r\n  CallExpression,\r\n  ArrayExpression,\r\n  ObjectExpression,\r\n  Position,\r\n  InterpolationNode,\r\n  CompoundExpressionNode,\r\n  SimpleExpressionNode,\r\n  FunctionExpression,\r\n  ConditionalExpression,\r\n  CacheExpression,\r\n  locStub,\r\n  SSRCodegenNode,\r\n  TemplateLiteral,\r\n  IfStatement,\r\n  AssignmentExpression,\r\n  ReturnStatement,\r\n  VNodeCall,\r\n  SequenceExpression\r\n} from './ast'\r\nimport { SourceMapGenerator, RawSourceMap } from 'source-map'\r\nimport {\r\n  advancePositionWithMutation,\r\n  assert,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper,\r\n  isSimpleIdentifier,\r\n  toValidAssetId\r\n} from './utils'\r\nimport { isString, isArray, isSymbol } from '@vue/shared'\r\nimport {\r\n  helperNameMap,\r\n  TO_DISPLAY_STRING,\r\n  CREATE_VNODE,\r\n  RESOLVE_COMPONENT,\r\n  RESOLVE_DIRECTIVE,\r\n  SET_BLOCK_TRACKING,\r\n  CREATE_COMMENT,\r\n  CREATE_TEXT,\r\n  PUSH_SCOPE_ID,\r\n  POP_SCOPE_ID,\r\n  WITH_DIRECTIVES,\r\n  CREATE_ELEMENT_VNODE,\r\n  OPEN_BLOCK,\r\n  CREATE_STATIC,\r\n  WITH_CTX,\r\n  RESOLVE_FILTER\r\n} from './runtimeHelpers'\r\nimport { ImportItem } from './transform'\r\n\r\nconst PURE_ANNOTATION = `/*#__PURE__*/`\r\n\r\nconst aliasHelper = (s: symbol) => `${helperNameMap[s]}: _${helperNameMap[s]}`\r\n\r\ntype CodegenNode = TemplateChildNode | JSChildNode | SSRCodegenNode\r\n\r\nexport interface CodegenResult {\r\n  code: string\r\n  preamble: string\r\n  ast: RootNode\r\n  map?: RawSourceMap\r\n}\r\n\r\nexport interface CodegenContext\r\n  extends Omit<Required<CodegenOptions>, 'bindingMetadata' | 'inline'> {\r\n  source: string\r\n  code: string\r\n  line: number\r\n  column: number\r\n  offset: number\r\n  indentLevel: number\r\n  pure: boolean\r\n  map?: SourceMapGenerator\r\n  helper(key: symbol): string\r\n  push(code: string, node?: CodegenNode): void\r\n  indent(): void\r\n  deindent(withoutNewLine?: boolean): void\r\n  newline(): void\r\n}\r\n\r\nfunction createCodegenContext(\r\n  ast: RootNode,\r\n  {\r\n    mode = 'function',\r\n    prefixIdentifiers = mode === 'module',\r\n    sourceMap = false,\r\n    filename = `template.vue.html`,\r\n    scopeId = null,\r\n    optimizeImports = false,\r\n    runtimeGlobalName = `Vue`,\r\n    runtimeModuleName = `vue`,\r\n    ssrRuntimeModuleName = 'vue/server-renderer',\r\n    ssr = false,\r\n    isTS = false,\r\n    inSSR = false\r\n  }: CodegenOptions\r\n): CodegenContext {\r\n  const context: CodegenContext = {\r\n    mode,\r\n    prefixIdentifiers,\r\n    sourceMap,\r\n    filename,\r\n    scopeId,\r\n    optimizeImports,\r\n    runtimeGlobalName,\r\n    runtimeModuleName,\r\n    ssrRuntimeModuleName,\r\n    ssr,\r\n    isTS,\r\n    inSSR,\r\n    source: ast.loc.source,\r\n    code: ``,\r\n    column: 1,\r\n    line: 1,\r\n    offset: 0,\r\n    indentLevel: 0,\r\n    pure: false,\r\n    map: undefined,\r\n    helper(key) {\r\n      return `_${helperNameMap[key]}`\r\n    },\r\n    push(code, node) {\r\n      context.code += code\r\n      if (!__BROWSER__ && context.map) {\r\n        if (node) {\r\n          let name\r\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\r\n            const content = node.content.replace(/^_ctx\\./, '')\r\n            if (content !== node.content && isSimpleIdentifier(content)) {\r\n              name = content\r\n            }\r\n          }\r\n          addMapping(node.loc.start, name)\r\n        }\r\n        advancePositionWithMutation(context, code)\r\n        if (node && node.loc !== locStub) {\r\n          addMapping(node.loc.end)\r\n        }\r\n      }\r\n    },\r\n    indent() {\r\n      newline(++context.indentLevel)\r\n    },\r\n    deindent(withoutNewLine = false) {\r\n      if (withoutNewLine) {\r\n        --context.indentLevel\r\n      } else {\r\n        newline(--context.indentLevel)\r\n      }\r\n    },\r\n    newline() {\r\n      newline(context.indentLevel)\r\n    }\r\n  }\r\n\r\n  function newline(n: number) {\r\n    context.push('\\n' + `  `.repeat(n))\r\n  }\r\n\r\n  function addMapping(loc: Position, name?: string) {\r\n    context.map!.addMapping({\r\n      name,\r\n      source: context.filename,\r\n      original: {\r\n        line: loc.line,\r\n        column: loc.column - 1 // source-map column is 0 based\r\n      },\r\n      generated: {\r\n        line: context.line,\r\n        column: context.column - 1\r\n      }\r\n    })\r\n  }\r\n\r\n  if (!__BROWSER__ && sourceMap) {\r\n    // lazy require source-map implementation, only in non-browser builds\r\n    context.map = new SourceMapGenerator()\r\n    context.map!.setSourceContent(filename, context.source)\r\n  }\r\n\r\n  return context\r\n}\r\n\r\nexport function generate(\r\n  ast: RootNode,\r\n  options: CodegenOptions & {\r\n    onContextCreated?: (context: CodegenContext) => void\r\n  } = {}\r\n): CodegenResult {\r\n  const context = createCodegenContext(ast, options)\r\n  if (options.onContextCreated) options.onContextCreated(context)\r\n  const {\r\n    mode,\r\n    push,\r\n    prefixIdentifiers,\r\n    indent,\r\n    deindent,\r\n    newline,\r\n    scopeId,\r\n    ssr\r\n  } = context\r\n\r\n  const hasHelpers = ast.helpers.length > 0\r\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\r\n  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'\r\n  const isSetupInlined = !__BROWSER__ && !!options.inline\r\n\r\n  // preambles\r\n  // in setup() inline mode, the preamble is generated in a sub context\r\n  // and returned separately.\r\n  const preambleContext = isSetupInlined\r\n    ? createCodegenContext(ast, options)\r\n    : context\r\n  if (!__BROWSER__ && mode === 'module') {\r\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\r\n  } else {\r\n    genFunctionPreamble(ast, preambleContext)\r\n  }\r\n  // enter render function\r\n  const functionName = ssr ? `ssrRender` : `render`\r\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']\r\n  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {\r\n    // binding optimization args\r\n    args.push('$props', '$setup', '$data', '$options')\r\n  }\r\n  const signature =\r\n    !__BROWSER__ && options.isTS\r\n      ? args.map(arg => `${arg}: any`).join(',')\r\n      : args.join(', ')\r\n\r\n  if (isSetupInlined) {\r\n    push(`(${signature}) => {`)\r\n  } else {\r\n    push(`function ${functionName}(${signature}) {`)\r\n  }\r\n  indent()\r\n\r\n  if (useWithBlock) {\r\n    push(`with (_ctx) {`)\r\n    indent()\r\n    // function mode const declarations should be inside with block\r\n    // also they should be renamed to avoid collision with user properties\r\n    if (hasHelpers) {\r\n      push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`)\r\n      push(`\\n`)\r\n      newline()\r\n    }\r\n  }\r\n\r\n  // generate asset resolution statements\r\n  if (ast.components.length) {\r\n    genAssets(ast.components, 'component', context)\r\n    if (ast.directives.length || ast.temps > 0) {\r\n      newline()\r\n    }\r\n  }\r\n  if (ast.directives.length) {\r\n    genAssets(ast.directives, 'directive', context)\r\n    if (ast.temps > 0) {\r\n      newline()\r\n    }\r\n  }\r\n  if (__COMPAT__ && ast.filters && ast.filters.length) {\r\n    newline()\r\n    genAssets(ast.filters, 'filter', context)\r\n    newline()\r\n  }\r\n\r\n  if (ast.temps > 0) {\r\n    push(`let `)\r\n    for (let i = 0; i < ast.temps; i++) {\r\n      push(`${i > 0 ? `, ` : ``}_temp${i}`)\r\n    }\r\n  }\r\n  if (ast.components.length || ast.directives.length || ast.temps) {\r\n    push(`\\n`)\r\n    newline()\r\n  }\r\n\r\n  // generate the VNode tree expression\r\n  if (!ssr) {\r\n    push(`return `)\r\n  }\r\n  if (ast.codegenNode) {\r\n    genNode(ast.codegenNode, context)\r\n  } else {\r\n    push(`null`)\r\n  }\r\n\r\n  if (useWithBlock) {\r\n    deindent()\r\n    push(`}`)\r\n  }\r\n\r\n  deindent()\r\n  push(`}`)\r\n\r\n  return {\r\n    ast,\r\n    code: context.code,\r\n    preamble: isSetupInlined ? preambleContext.code : ``,\r\n    // SourceMapGenerator does have toJSON() method but it's not in the types\r\n    map: context.map ? (context.map as any).toJSON() : undefined\r\n  }\r\n}\r\n\r\nfunction genFunctionPreamble(ast: RootNode, context: CodegenContext) {\r\n  const {\r\n    ssr,\r\n    prefixIdentifiers,\r\n    push,\r\n    newline,\r\n    runtimeModuleName,\r\n    runtimeGlobalName,\r\n    ssrRuntimeModuleName\r\n  } = context\r\n  const VueBinding =\r\n    !__BROWSER__ && ssr\r\n      ? `require(${JSON.stringify(runtimeModuleName)})`\r\n      : runtimeGlobalName\r\n  // Generate const declaration for helpers\r\n  // In prefix mode, we place the const declaration at top so it's done\r\n  // only once; But if we not prefixing, we place the declaration inside the\r\n  // with block so it doesn't incur the `in` check cost for every helper access.\r\n  if (ast.helpers.length > 0) {\r\n    if (!__BROWSER__ && prefixIdentifiers) {\r\n      push(\r\n        `const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\\n`\r\n      )\r\n    } else {\r\n      // \"with\" mode.\r\n      // save Vue in a separate variable to avoid collision\r\n      push(`const _Vue = ${VueBinding}\\n`)\r\n      // in \"with\" mode, helpers are declared inside the with block to avoid\r\n      // has check cost, but hoists are lifted out of the function - we need\r\n      // to provide the helper here.\r\n      if (ast.hoists.length) {\r\n        const staticHelpers = [\r\n          CREATE_VNODE,\r\n          CREATE_ELEMENT_VNODE,\r\n          CREATE_COMMENT,\r\n          CREATE_TEXT,\r\n          CREATE_STATIC\r\n        ]\r\n          .filter(helper => ast.helpers.includes(helper))\r\n          .map(aliasHelper)\r\n          .join(', ')\r\n        push(`const { ${staticHelpers} } = _Vue\\n`)\r\n      }\r\n    }\r\n  }\r\n  // generate variables for ssr helpers\r\n  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {\r\n    // ssr guarantees prefixIdentifier: true\r\n    push(\r\n      `const { ${ast.ssrHelpers\r\n        .map(aliasHelper)\r\n        .join(', ')} } = require(\"${ssrRuntimeModuleName}\")\\n`\r\n    )\r\n  }\r\n  genHoists(ast.hoists, context)\r\n  newline()\r\n  push(`return `)\r\n}\r\n\r\nfunction genModulePreamble(\r\n  ast: RootNode,\r\n  context: CodegenContext,\r\n  genScopeId: boolean,\r\n  inline?: boolean\r\n) {\r\n  const {\r\n    push,\r\n    newline,\r\n    optimizeImports,\r\n    runtimeModuleName,\r\n    ssrRuntimeModuleName\r\n  } = context\r\n\r\n  if (genScopeId && ast.hoists.length) {\r\n    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)\r\n  }\r\n\r\n  // generate import statements for helpers\r\n  if (ast.helpers.length) {\r\n    if (optimizeImports) {\r\n      // when bundled with webpack with code-split, calling an import binding\r\n      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,\r\n      // incurring both payload size increase and potential perf overhead.\r\n      // therefore we assign the imports to variables (which is a constant ~50b\r\n      // cost per-component instead of scaling with template size)\r\n      push(\r\n        `import { ${ast.helpers\r\n          .map(s => helperNameMap[s])\r\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\r\n      )\r\n      push(\r\n        `\\n// Binding optimization for webpack code-split\\nconst ${ast.helpers\r\n          .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)\r\n          .join(', ')}\\n`\r\n      )\r\n    } else {\r\n      push(\r\n        `import { ${ast.helpers\r\n          .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\r\n      )\r\n    }\r\n  }\r\n\r\n  if (ast.ssrHelpers && ast.ssrHelpers.length) {\r\n    push(\r\n      `import { ${ast.ssrHelpers\r\n        .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n        .join(', ')} } from \"${ssrRuntimeModuleName}\"\\n`\r\n    )\r\n  }\r\n\r\n  if (ast.imports.length) {\r\n    genImports(ast.imports, context)\r\n    newline()\r\n  }\r\n\r\n  genHoists(ast.hoists, context)\r\n  newline()\r\n\r\n  if (!inline) {\r\n    push(`export `)\r\n  }\r\n}\r\n\r\nfunction genAssets(\r\n  assets: string[],\r\n  type: 'component' | 'directive' | 'filter',\r\n  { helper, push, newline, isTS }: CodegenContext\r\n) {\r\n  const resolver = helper(\r\n    __COMPAT__ && type === 'filter'\r\n      ? RESOLVE_FILTER\r\n      : type === 'component'\r\n      ? RESOLVE_COMPONENT\r\n      : RESOLVE_DIRECTIVE\r\n  )\r\n  for (let i = 0; i < assets.length; i++) {\r\n    let id = assets[i]\r\n    // potential component implicit self-reference inferred from SFC filename\r\n    const maybeSelfReference = id.endsWith('__self')\r\n    if (maybeSelfReference) {\r\n      id = id.slice(0, -6)\r\n    }\r\n    push(\r\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${\r\n        maybeSelfReference ? `, true` : ``\r\n      })${isTS ? `!` : ``}`\r\n    )\r\n    if (i < assets.length - 1) {\r\n      newline()\r\n    }\r\n  }\r\n}\r\n\r\nfunction genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {\r\n  if (!hoists.length) {\r\n    return\r\n  }\r\n  context.pure = true\r\n  const { push, newline, helper, scopeId, mode } = context\r\n  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'\r\n  newline()\r\n\r\n  // generate inlined withScopeId helper\r\n  if (genScopeId) {\r\n    push(\r\n      `const _withScopeId = n => (${helper(\r\n        PUSH_SCOPE_ID\r\n      )}(\"${scopeId}\"),n=n(),${helper(POP_SCOPE_ID)}(),n)`\r\n    )\r\n    newline()\r\n  }\r\n\r\n  for (let i = 0; i < hoists.length; i++) {\r\n    const exp = hoists[i]\r\n    if (exp) {\r\n      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL\r\n      push(\r\n        `const _hoisted_${i + 1} = ${\r\n          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``\r\n        }`\r\n      )\r\n      genNode(exp, context)\r\n      if (needScopeIdWrapper) {\r\n        push(`)`)\r\n      }\r\n      newline()\r\n    }\r\n  }\r\n\r\n  context.pure = false\r\n}\r\n\r\nfunction genImports(importsOptions: ImportItem[], context: CodegenContext) {\r\n  if (!importsOptions.length) {\r\n    return\r\n  }\r\n  importsOptions.forEach(imports => {\r\n    context.push(`import `)\r\n    genNode(imports.exp, context)\r\n    context.push(` from '${imports.path}'`)\r\n    context.newline()\r\n  })\r\n}\r\n\r\nfunction isText(n: string | CodegenNode) {\r\n  return (\r\n    isString(n) ||\r\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\r\n    n.type === NodeTypes.TEXT ||\r\n    n.type === NodeTypes.INTERPOLATION ||\r\n    n.type === NodeTypes.COMPOUND_EXPRESSION\r\n  )\r\n}\r\n\r\nfunction genNodeListAsArray(\r\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\r\n  context: CodegenContext\r\n) {\r\n  const multilines =\r\n    nodes.length > 3 ||\r\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\r\n  context.push(`[`)\r\n  multilines && context.indent()\r\n  genNodeList(nodes, context, multilines)\r\n  multilines && context.deindent()\r\n  context.push(`]`)\r\n}\r\n\r\nfunction genNodeList(\r\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\r\n  context: CodegenContext,\r\n  multilines: boolean = false,\r\n  comma: boolean = true\r\n) {\r\n  const { push, newline } = context\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i]\r\n    if (isString(node)) {\r\n      push(node)\r\n    } else if (isArray(node)) {\r\n      genNodeListAsArray(node, context)\r\n    } else {\r\n      genNode(node, context)\r\n    }\r\n    if (i < nodes.length - 1) {\r\n      if (multilines) {\r\n        comma && push(',')\r\n        newline()\r\n      } else {\r\n        comma && push(', ')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\r\n  if (isString(node)) {\r\n    context.push(node)\r\n    return\r\n  }\r\n  if (isSymbol(node)) {\r\n    context.push(context.helper(node))\r\n    return\r\n  }\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n    case NodeTypes.IF:\r\n    case NodeTypes.FOR:\r\n      __DEV__ &&\r\n        assert(\r\n          node.codegenNode != null,\r\n          `Codegen node is missing for element/if/for node. ` +\r\n            `Apply appropriate transforms first.`\r\n        )\r\n      genNode(node.codegenNode!, context)\r\n      break\r\n    case NodeTypes.TEXT:\r\n      genText(node, context)\r\n      break\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      genExpression(node, context)\r\n      break\r\n    case NodeTypes.INTERPOLATION:\r\n      genInterpolation(node, context)\r\n      break\r\n    case NodeTypes.TEXT_CALL:\r\n      genNode(node.codegenNode, context)\r\n      break\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      genCompoundExpression(node, context)\r\n      break\r\n    case NodeTypes.COMMENT:\r\n      genComment(node, context)\r\n      break\r\n    case NodeTypes.VNODE_CALL:\r\n      genVNodeCall(node, context)\r\n      break\r\n\r\n    case NodeTypes.JS_CALL_EXPRESSION:\r\n      genCallExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_OBJECT_EXPRESSION:\r\n      genObjectExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_ARRAY_EXPRESSION:\r\n      genArrayExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\r\n      genFunctionExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\r\n      genConditionalExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_CACHE_EXPRESSION:\r\n      genCacheExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_BLOCK_STATEMENT:\r\n      genNodeList(node.body, context, true, false)\r\n      break\r\n\r\n    // SSR only types\r\n    case NodeTypes.JS_TEMPLATE_LITERAL:\r\n      !__BROWSER__ && genTemplateLiteral(node, context)\r\n      break\r\n    case NodeTypes.JS_IF_STATEMENT:\r\n      !__BROWSER__ && genIfStatement(node, context)\r\n      break\r\n    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:\r\n      !__BROWSER__ && genAssignmentExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\r\n      !__BROWSER__ && genSequenceExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_RETURN_STATEMENT:\r\n      !__BROWSER__ && genReturnStatement(node, context)\r\n      break\r\n\r\n    /* istanbul ignore next */\r\n    case NodeTypes.IF_BRANCH:\r\n      // noop\r\n      break\r\n    default:\r\n      if (__DEV__) {\r\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\r\n        // make sure we exhaust all possible types\r\n        const exhaustiveCheck: never = node\r\n        return exhaustiveCheck\r\n      }\r\n  }\r\n}\r\n\r\nfunction genText(\r\n  node: TextNode | SimpleExpressionNode,\r\n  context: CodegenContext\r\n) {\r\n  context.push(JSON.stringify(node.content), node)\r\n}\r\n\r\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\r\n  const { content, isStatic } = node\r\n  context.push(isStatic ? JSON.stringify(content) : content, node)\r\n}\r\n\r\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  if (pure) push(PURE_ANNOTATION)\r\n  push(`${helper(TO_DISPLAY_STRING)}(`)\r\n  genNode(node.content, context)\r\n  push(`)`)\r\n}\r\n\r\nfunction genCompoundExpression(\r\n  node: CompoundExpressionNode,\r\n  context: CodegenContext\r\n) {\r\n  for (let i = 0; i < node.children!.length; i++) {\r\n    const child = node.children![i]\r\n    if (isString(child)) {\r\n      context.push(child)\r\n    } else {\r\n      genNode(child, context)\r\n    }\r\n  }\r\n}\r\n\r\nfunction genExpressionAsPropertyKey(\r\n  node: ExpressionNode,\r\n  context: CodegenContext\r\n) {\r\n  const { push } = context\r\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n    push(`[`)\r\n    genCompoundExpression(node, context)\r\n    push(`]`)\r\n  } else if (node.isStatic) {\r\n    // only quote keys if necessary\r\n    const text = isSimpleIdentifier(node.content)\r\n      ? node.content\r\n      : JSON.stringify(node.content)\r\n    push(text, node)\r\n  } else {\r\n    push(`[${node.content}]`, node)\r\n  }\r\n}\r\n\r\nfunction genComment(node: CommentNode, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node)\r\n}\r\n\r\nfunction genVNodeCall(node: VNodeCall, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  const {\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isBlock,\r\n    disableTracking,\r\n    isComponent\r\n  } = node\r\n  if (directives) {\r\n    push(helper(WITH_DIRECTIVES) + `(`)\r\n  }\r\n  if (isBlock) {\r\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)\r\n  }\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  const callHelper: symbol = isBlock\r\n    ? getVNodeBlockHelper(context.inSSR, isComponent)\r\n    : getVNodeHelper(context.inSSR, isComponent)\r\n  push(helper(callHelper) + `(`, node)\r\n  genNodeList(\r\n    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),\r\n    context\r\n  )\r\n  push(`)`)\r\n  if (isBlock) {\r\n    push(`)`)\r\n  }\r\n  if (directives) {\r\n    push(`, `)\r\n    genNode(directives, context)\r\n    push(`)`)\r\n  }\r\n}\r\n\r\nfunction genNullableArgs(args: any[]): CallExpression['arguments'] {\r\n  let i = args.length\r\n  while (i--) {\r\n    if (args[i] != null) break\r\n  }\r\n  return args.slice(0, i + 1).map(arg => arg || `null`)\r\n}\r\n\r\n// JavaScript\r\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  const callee = isString(node.callee) ? node.callee : helper(node.callee)\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  push(callee + `(`, node)\r\n  genNodeList(node.arguments, context)\r\n  push(`)`)\r\n}\r\n\r\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\r\n  const { push, indent, deindent, newline } = context\r\n  const { properties } = node\r\n  if (!properties.length) {\r\n    push(`{}`, node)\r\n    return\r\n  }\r\n  const multilines =\r\n    properties.length > 1 ||\r\n    ((!__BROWSER__ || __DEV__) &&\r\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\r\n  push(multilines ? `{` : `{ `)\r\n  multilines && indent()\r\n  for (let i = 0; i < properties.length; i++) {\r\n    const { key, value } = properties[i]\r\n    // key\r\n    genExpressionAsPropertyKey(key, context)\r\n    push(`: `)\r\n    // value\r\n    genNode(value, context)\r\n    if (i < properties.length - 1) {\r\n      // will only reach this if it's multilines\r\n      push(`,`)\r\n      newline()\r\n    }\r\n  }\r\n  multilines && deindent()\r\n  push(multilines ? `}` : ` }`)\r\n}\r\n\r\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\r\n  genNodeListAsArray(node.elements as CodegenNode[], context)\r\n}\r\n\r\nfunction genFunctionExpression(\r\n  node: FunctionExpression,\r\n  context: CodegenContext\r\n) {\r\n  const { push, indent, deindent } = context\r\n  const { params, returns, body, newline, isSlot } = node\r\n  if (isSlot) {\r\n    // wrap slot functions with owner context\r\n    push(`_${helperNameMap[WITH_CTX]}(`)\r\n  }\r\n  push(`(`, node)\r\n  if (isArray(params)) {\r\n    genNodeList(params, context)\r\n  } else if (params) {\r\n    genNode(params, context)\r\n  }\r\n  push(`) => `)\r\n  if (newline || body) {\r\n    push(`{`)\r\n    indent()\r\n  }\r\n  if (returns) {\r\n    if (newline) {\r\n      push(`return `)\r\n    }\r\n    if (isArray(returns)) {\r\n      genNodeListAsArray(returns, context)\r\n    } else {\r\n      genNode(returns, context)\r\n    }\r\n  } else if (body) {\r\n    genNode(body, context)\r\n  }\r\n  if (newline || body) {\r\n    deindent()\r\n    push(`}`)\r\n  }\r\n  if (isSlot) {\r\n    if (__COMPAT__ && node.isNonScopedSlot) {\r\n      push(`, undefined, true`)\r\n    }\r\n    push(`)`)\r\n  }\r\n}\r\n\r\nfunction genConditionalExpression(\r\n  node: ConditionalExpression,\r\n  context: CodegenContext\r\n) {\r\n  const { test, consequent, alternate, newline: needNewline } = node\r\n  const { push, indent, deindent, newline } = context\r\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    const needsParens = !isSimpleIdentifier(test.content)\r\n    needsParens && push(`(`)\r\n    genExpression(test, context)\r\n    needsParens && push(`)`)\r\n  } else {\r\n    push(`(`)\r\n    genNode(test, context)\r\n    push(`)`)\r\n  }\r\n  needNewline && indent()\r\n  context.indentLevel++\r\n  needNewline || push(` `)\r\n  push(`? `)\r\n  genNode(consequent, context)\r\n  context.indentLevel--\r\n  needNewline && newline()\r\n  needNewline || push(` `)\r\n  push(`: `)\r\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n  if (!isNested) {\r\n    context.indentLevel++\r\n  }\r\n  genNode(alternate, context)\r\n  if (!isNested) {\r\n    context.indentLevel--\r\n  }\r\n  needNewline && deindent(true /* without newline */)\r\n}\r\n\r\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\r\n  const { push, helper, indent, deindent, newline } = context\r\n  push(`_cache[${node.index}] || (`)\r\n  if (node.isVNode) {\r\n    indent()\r\n    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)\r\n    newline()\r\n  }\r\n  push(`_cache[${node.index}] = `)\r\n  genNode(node.value, context)\r\n  if (node.isVNode) {\r\n    push(`,`)\r\n    newline()\r\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`)\r\n    newline()\r\n    push(`_cache[${node.index}]`)\r\n    deindent()\r\n  }\r\n  push(`)`)\r\n}\r\n\r\nfunction genTemplateLiteral(node: TemplateLiteral, context: CodegenContext) {\r\n  const { push, indent, deindent } = context\r\n  push('`')\r\n  const l = node.elements.length\r\n  const multilines = l > 3\r\n  for (let i = 0; i < l; i++) {\r\n    const e = node.elements[i]\r\n    if (isString(e)) {\r\n      push(e.replace(/(`|\\$|\\\\)/g, '\\\\$1'))\r\n    } else {\r\n      push('${')\r\n      if (multilines) indent()\r\n      genNode(e, context)\r\n      if (multilines) deindent()\r\n      push('}')\r\n    }\r\n  }\r\n  push('`')\r\n}\r\n\r\nfunction genIfStatement(node: IfStatement, context: CodegenContext) {\r\n  const { push, indent, deindent } = context\r\n  const { test, consequent, alternate } = node\r\n  push(`if (`)\r\n  genNode(test, context)\r\n  push(`) {`)\r\n  indent()\r\n  genNode(consequent, context)\r\n  deindent()\r\n  push(`}`)\r\n  if (alternate) {\r\n    push(` else `)\r\n    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {\r\n      genIfStatement(alternate, context)\r\n    } else {\r\n      push(`{`)\r\n      indent()\r\n      genNode(alternate, context)\r\n      deindent()\r\n      push(`}`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction genAssignmentExpression(\r\n  node: AssignmentExpression,\r\n  context: CodegenContext\r\n) {\r\n  genNode(node.left, context)\r\n  context.push(` = `)\r\n  genNode(node.right, context)\r\n}\r\n\r\nfunction genSequenceExpression(\r\n  node: SequenceExpression,\r\n  context: CodegenContext\r\n) {\r\n  context.push(`(`)\r\n  genNodeList(node.expressions, context)\r\n  context.push(`)`)\r\n}\r\n\r\nfunction genReturnStatement(\r\n  { returns }: ReturnStatement,\r\n  context: CodegenContext\r\n) {\r\n  context.push(`return `)\r\n  if (isArray(returns)) {\r\n    genNodeListAsArray(returns, context)\r\n  } else {\r\n    genNode(returns, context)\r\n  }\r\n}\r\n","// should only use types from @babel/types\r\n// do not import runtime methods\r\nimport type {\r\n  Identifier,\r\n  Node,\r\n  Function,\r\n  ObjectProperty,\r\n  BlockStatement,\r\n  Program\r\n} from '@babel/types'\r\nimport { walk } from 'estree-walker'\r\n\r\nexport function walkIdentifiers(\r\n  root: Node,\r\n  onIdentifier: (\r\n    node: Identifier,\r\n    parent: Node,\r\n    parentStack: Node[],\r\n    isReference: boolean,\r\n    isLocal: boolean\r\n  ) => void,\r\n  includeAll = false,\r\n  parentStack: Node[] = [],\r\n  knownIds: Record<string, number> = Object.create(null)\r\n) {\r\n  if (__BROWSER__) {\r\n    return\r\n  }\r\n\r\n  const rootExp =\r\n    root.type === 'Program' &&\r\n    root.body[0].type === 'ExpressionStatement' &&\r\n    root.body[0].expression\r\n\r\n  ;(walk as any)(root, {\r\n    enter(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\r\n      parent && parentStack.push(parent)\r\n      if (\r\n        parent &&\r\n        parent.type.startsWith('TS') &&\r\n        parent.type !== 'TSAsExpression' &&\r\n        parent.type !== 'TSNonNullExpression' &&\r\n        parent.type !== 'TSTypeAssertion'\r\n      ) {\r\n        return this.skip()\r\n      }\r\n      if (node.type === 'Identifier') {\r\n        const isLocal = !!knownIds[node.name]\r\n        const isRefed = isReferencedIdentifier(node, parent!, parentStack)\r\n        if (includeAll || (isRefed && !isLocal)) {\r\n          onIdentifier(node, parent!, parentStack, isRefed, isLocal)\r\n        }\r\n      } else if (\r\n        node.type === 'ObjectProperty' &&\r\n        parent!.type === 'ObjectPattern'\r\n      ) {\r\n        // mark property in destructure pattern\r\n        ;(node as any).inPattern = true\r\n      } else if (isFunctionType(node)) {\r\n        // walk function expressions and add its arguments to known identifiers\r\n        // so that we don't prefix them\r\n        walkFunctionParams(node, id => markScopeIdentifier(node, id, knownIds))\r\n      } else if (node.type === 'BlockStatement') {\r\n        // #3445 record block-level local variables\r\n        walkBlockDeclarations(node, id =>\r\n          markScopeIdentifier(node, id, knownIds)\r\n        )\r\n      }\r\n    },\r\n    leave(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\r\n      parent && parentStack.pop()\r\n      if (node !== rootExp && node.scopeIds) {\r\n        for (const id of node.scopeIds) {\r\n          knownIds[id]--\r\n          if (knownIds[id] === 0) {\r\n            delete knownIds[id]\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nexport function isReferencedIdentifier(\r\n  id: Identifier,\r\n  parent: Node | null,\r\n  parentStack: Node[]\r\n) {\r\n  if (__BROWSER__) {\r\n    return false\r\n  }\r\n\r\n  if (!parent) {\r\n    return true\r\n  }\r\n\r\n  // is a special keyword but parsed as identifier\r\n  if (id.name === 'arguments') {\r\n    return false\r\n  }\r\n\r\n  if (isReferenced(id, parent)) {\r\n    return true\r\n  }\r\n\r\n  // babel's isReferenced check returns false for ids being assigned to, so we\r\n  // need to cover those cases here\r\n  switch (parent.type) {\r\n    case 'AssignmentExpression':\r\n    case 'AssignmentPattern':\r\n      return true\r\n    case 'ObjectPattern':\r\n    case 'ArrayPattern':\r\n      return isInDestructureAssignment(parent, parentStack)\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nexport function isInDestructureAssignment(\r\n  parent: Node,\r\n  parentStack: Node[]\r\n): boolean {\r\n  if (\r\n    parent &&\r\n    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')\r\n  ) {\r\n    let i = parentStack.length\r\n    while (i--) {\r\n      const p = parentStack[i]\r\n      if (p.type === 'AssignmentExpression') {\r\n        return true\r\n      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\r\n        break\r\n      }\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nexport function walkFunctionParams(\r\n  node: Function,\r\n  onIdent: (id: Identifier) => void\r\n) {\r\n  for (const p of node.params) {\r\n    for (const id of extractIdentifiers(p)) {\r\n      onIdent(id)\r\n    }\r\n  }\r\n}\r\n\r\nexport function walkBlockDeclarations(\r\n  block: BlockStatement | Program,\r\n  onIdent: (node: Identifier) => void\r\n) {\r\n  for (const stmt of block.body) {\r\n    if (stmt.type === 'VariableDeclaration') {\r\n      if (stmt.declare) continue\r\n      for (const decl of stmt.declarations) {\r\n        for (const id of extractIdentifiers(decl.id)) {\r\n          onIdent(id)\r\n        }\r\n      }\r\n    } else if (\r\n      stmt.type === 'FunctionDeclaration' ||\r\n      stmt.type === 'ClassDeclaration'\r\n    ) {\r\n      if (stmt.declare || !stmt.id) continue\r\n      onIdent(stmt.id)\r\n    }\r\n  }\r\n}\r\n\r\nexport function extractIdentifiers(\r\n  param: Node,\r\n  nodes: Identifier[] = []\r\n): Identifier[] {\r\n  switch (param.type) {\r\n    case 'Identifier':\r\n      nodes.push(param)\r\n      break\r\n\r\n    case 'MemberExpression':\r\n      let object: any = param\r\n      while (object.type === 'MemberExpression') {\r\n        object = object.object\r\n      }\r\n      nodes.push(object)\r\n      break\r\n\r\n    case 'ObjectPattern':\r\n      for (const prop of param.properties) {\r\n        if (prop.type === 'RestElement') {\r\n          extractIdentifiers(prop.argument, nodes)\r\n        } else {\r\n          extractIdentifiers(prop.value, nodes)\r\n        }\r\n      }\r\n      break\r\n\r\n    case 'ArrayPattern':\r\n      param.elements.forEach(element => {\r\n        if (element) extractIdentifiers(element, nodes)\r\n      })\r\n      break\r\n\r\n    case 'RestElement':\r\n      extractIdentifiers(param.argument, nodes)\r\n      break\r\n\r\n    case 'AssignmentPattern':\r\n      extractIdentifiers(param.left, nodes)\r\n      break\r\n  }\r\n\r\n  return nodes\r\n}\r\n\r\nfunction markScopeIdentifier(\r\n  node: Node & { scopeIds?: Set<string> },\r\n  child: Identifier,\r\n  knownIds: Record<string, number>\r\n) {\r\n  const { name } = child\r\n  if (node.scopeIds && node.scopeIds.has(name)) {\r\n    return\r\n  }\r\n  if (name in knownIds) {\r\n    knownIds[name]++\r\n  } else {\r\n    knownIds[name] = 1\r\n  }\r\n  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)\r\n}\r\n\r\nexport const isFunctionType = (node: Node): node is Function => {\r\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)\r\n}\r\n\r\nexport const isStaticProperty = (node: Node): node is ObjectProperty =>\r\n  node &&\r\n  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\r\n  !node.computed\r\n\r\nexport const isStaticPropertyKey = (node: Node, parent: Node) =>\r\n  isStaticProperty(parent) && parent.key === node\r\n\r\n/**\r\n * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts\r\n * To avoid runtime dependency on @babel/types (which includes process references)\r\n * This file should not change very often in babel but we may need to keep it\r\n * up-to-date from time to time.\r\n *\r\n * https://github.com/babel/babel/blob/main/LICENSE\r\n *\r\n */\r\nfunction isReferenced(node: Node, parent: Node, grandparent?: Node): boolean {\r\n  switch (parent.type) {\r\n    // yes: PARENT[NODE]\r\n    // yes: NODE.child\r\n    // no: parent.NODE\r\n    case 'MemberExpression':\r\n    case 'OptionalMemberExpression':\r\n      if (parent.property === node) {\r\n        return !!parent.computed\r\n      }\r\n      return parent.object === node\r\n\r\n    case 'JSXMemberExpression':\r\n      return parent.object === node\r\n    // no: let NODE = init;\r\n    // yes: let id = NODE;\r\n    case 'VariableDeclarator':\r\n      return parent.init === node\r\n\r\n    // yes: () => NODE\r\n    // no: (NODE) => {}\r\n    case 'ArrowFunctionExpression':\r\n      return parent.body === node\r\n\r\n    // no: class { #NODE; }\r\n    // no: class { get #NODE() {} }\r\n    // no: class { #NODE() {} }\r\n    // no: class { fn() { return this.#NODE; } }\r\n    case 'PrivateName':\r\n      return false\r\n\r\n    // no: class { NODE() {} }\r\n    // yes: class { [NODE]() {} }\r\n    // no: class { foo(NODE) {} }\r\n    case 'ClassMethod':\r\n    case 'ClassPrivateMethod':\r\n    case 'ObjectMethod':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      return false\r\n\r\n    // yes: { [NODE]: \"\" }\r\n    // no: { NODE: \"\" }\r\n    // depends: { NODE }\r\n    // depends: { key: NODE }\r\n    case 'ObjectProperty':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      // parent.value === node\r\n      return !grandparent || grandparent.type !== 'ObjectPattern'\r\n    // no: class { NODE = value; }\r\n    // yes: class { [NODE] = value; }\r\n    // yes: class { key = NODE; }\r\n    case 'ClassProperty':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      return true\r\n    case 'ClassPrivateProperty':\r\n      return parent.key !== node\r\n\r\n    // no: class NODE {}\r\n    // yes: class Foo extends NODE {}\r\n    case 'ClassDeclaration':\r\n    case 'ClassExpression':\r\n      return parent.superClass === node\r\n\r\n    // yes: left = NODE;\r\n    // no: NODE = right;\r\n    case 'AssignmentExpression':\r\n      return parent.right === node\r\n\r\n    // no: [NODE = foo] = [];\r\n    // yes: [foo = NODE] = [];\r\n    case 'AssignmentPattern':\r\n      return parent.right === node\r\n\r\n    // no: NODE: for (;;) {}\r\n    case 'LabeledStatement':\r\n      return false\r\n\r\n    // no: try {} catch (NODE) {}\r\n    case 'CatchClause':\r\n      return false\r\n\r\n    // no: function foo(...NODE) {}\r\n    case 'RestElement':\r\n      return false\r\n\r\n    case 'BreakStatement':\r\n    case 'ContinueStatement':\r\n      return false\r\n\r\n    // no: function NODE() {}\r\n    // no: function foo(NODE) {}\r\n    case 'FunctionDeclaration':\r\n    case 'FunctionExpression':\r\n      return false\r\n\r\n    // no: export NODE from \"foo\";\r\n    // no: export * as NODE from \"foo\";\r\n    case 'ExportNamespaceSpecifier':\r\n    case 'ExportDefaultSpecifier':\r\n      return false\r\n\r\n    // no: export { foo as NODE };\r\n    // yes: export { NODE as foo };\r\n    // no: export { NODE as foo } from \"foo\";\r\n    case 'ExportSpecifier':\r\n      // @ts-expect-error\r\n      if (grandparent?.source) {\r\n        return false\r\n      }\r\n      return parent.local === node\r\n\r\n    // no: import NODE from \"foo\";\r\n    // no: import * as NODE from \"foo\";\r\n    // no: import { NODE as foo } from \"foo\";\r\n    // no: import { foo as NODE } from \"foo\";\r\n    // no: import NODE from \"bar\";\r\n    case 'ImportDefaultSpecifier':\r\n    case 'ImportNamespaceSpecifier':\r\n    case 'ImportSpecifier':\r\n      return false\r\n\r\n    // no: import \"foo\" assert { NODE: \"json\" }\r\n    case 'ImportAttribute':\r\n      return false\r\n\r\n    // no: <div NODE=\"foo\" />\r\n    case 'JSXAttribute':\r\n      return false\r\n\r\n    // no: [NODE] = [];\r\n    // no: ({ NODE }) = [];\r\n    case 'ObjectPattern':\r\n    case 'ArrayPattern':\r\n      return false\r\n\r\n    // no: new.NODE\r\n    // no: NODE.target\r\n    case 'MetaProperty':\r\n      return false\r\n\r\n    // yes: type X = { someProperty: NODE }\r\n    // no: type X = { NODE: OtherType }\r\n    case 'ObjectTypeProperty':\r\n      return parent.key !== node\r\n\r\n    // yes: enum X { Foo = NODE }\r\n    // no: enum X { NODE }\r\n    case 'TSEnumMember':\r\n      return parent.id !== node\r\n\r\n    // yes: { [NODE]: value }\r\n    // no: { NODE: value }\r\n    case 'TSPropertySignature':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n\r\n      return true\r\n  }\r\n\r\n  return true\r\n}\r\n","// - Parse expressions in templates into compound expressions so that each\r\n//   identifier gets more accurate source-map locations.\r\n//\r\n// - Prefix identifiers with `_ctx.` or `$xxx` (for known binding types) so that\r\n//   they are accessed from the right source\r\n//\r\n// - This transform is only applied in non-browser builds because it relies on\r\n//   an additional JavaScript parser. In the browser, there is no source-map\r\n//   support and the code is wrapped in `with (this) { ... }`.\r\nimport { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  createSimpleExpression,\r\n  ExpressionNode,\r\n  SimpleExpressionNode,\r\n  CompoundExpressionNode,\r\n  createCompoundExpression,\r\n  ConstantTypes\r\n} from '../ast'\r\nimport {\r\n  isInDestructureAssignment,\r\n  isStaticProperty,\r\n  isStaticPropertyKey,\r\n  walkIdentifiers\r\n} from '../babelUtils'\r\nimport { advancePositionWithClone, isSimpleIdentifier } from '../utils'\r\nimport {\r\n  isGloballyWhitelisted,\r\n  makeMap,\r\n  hasOwn,\r\n  isString,\r\n  genPropsAccessExp\r\n} from '@vue/shared'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  Node,\r\n  Identifier,\r\n  AssignmentExpression,\r\n  UpdateExpression\r\n} from '@babel/types'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { parse } from '@babel/parser'\r\nimport { IS_REF, UNREF } from '../runtimeHelpers'\r\nimport { BindingTypes } from '../options'\r\n\r\nconst isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')\r\n\r\nexport const transformExpression: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.INTERPOLATION) {\r\n    node.content = processExpression(\r\n      node.content as SimpleExpressionNode,\r\n      context\r\n    )\r\n  } else if (node.type === NodeTypes.ELEMENT) {\r\n    // handle directives on element\r\n    for (let i = 0; i < node.props.length; i++) {\r\n      const dir = node.props[i]\r\n      // do not process for v-on & v-for since they are special handled\r\n      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {\r\n        const exp = dir.exp\r\n        const arg = dir.arg\r\n        // do not process exp if this is v-on:arg - we need special handling\r\n        // for wrapping inline statements.\r\n        if (\r\n          exp &&\r\n          exp.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n          !(dir.name === 'on' && arg)\r\n        ) {\r\n          dir.exp = processExpression(\r\n            exp,\r\n            context,\r\n            // slot args must be processed as function params\r\n            dir.name === 'slot'\r\n          )\r\n        }\r\n        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {\r\n          dir.arg = processExpression(arg, context)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface PrefixMeta {\r\n  prefix?: string\r\n  isConstant: boolean\r\n  start: number\r\n  end: number\r\n  scopeIds?: Set<string>\r\n}\r\n\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !__BROWSER__ check so that it can be\r\n// tree-shaken from the browser build.\r\nexport function processExpression(\r\n  node: SimpleExpressionNode,\r\n  context: TransformContext,\r\n  // some expressions like v-slot props & v-for aliases should be parsed as\r\n  // function params\r\n  asParams = false,\r\n  // v-on handler values may contain multiple statements\r\n  asRawStatements = false,\r\n  localVars: Record<string, number> = Object.create(context.identifiers)\r\n): ExpressionNode {\r\n  if (__BROWSER__) {\r\n    if (__DEV__) {\r\n      // simple in-browser validation (same logic in 2.x)\r\n      validateBrowserExpression(node, context, asParams, asRawStatements)\r\n    }\r\n    return node\r\n  }\r\n\r\n  if (!context.prefixIdentifiers || !node.content.trim()) {\r\n    return node\r\n  }\r\n\r\n  const { inline, bindingMetadata } = context\r\n  const rewriteIdentifier = (raw: string, parent?: Node, id?: Identifier) => {\r\n    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]\r\n    if (inline) {\r\n      // x = y\r\n      const isAssignmentLVal =\r\n        parent && parent.type === 'AssignmentExpression' && parent.left === id\r\n      // x++\r\n      const isUpdateArg =\r\n        parent && parent.type === 'UpdateExpression' && parent.argument === id\r\n      // ({ x } = y)\r\n      const isDestructureAssignment =\r\n        parent && isInDestructureAssignment(parent, parentStack)\r\n\r\n      if (\r\n        type === BindingTypes.SETUP_CONST ||\r\n        type === BindingTypes.SETUP_REACTIVE_CONST ||\r\n        localVars[raw]\r\n      ) {\r\n        return raw\r\n      } else if (type === BindingTypes.SETUP_REF) {\r\n        return `${raw}.value`\r\n      } else if (type === BindingTypes.SETUP_MAYBE_REF) {\r\n        // const binding that may or may not be ref\r\n        // if it's not a ref, then assignments don't make sense -\r\n        // so we ignore the non-ref assignment case and generate code\r\n        // that assumes the value to be a ref for more efficiency\r\n        return isAssignmentLVal || isUpdateArg || isDestructureAssignment\r\n          ? `${raw}.value`\r\n          : `${context.helperString(UNREF)}(${raw})`\r\n      } else if (type === BindingTypes.SETUP_LET) {\r\n        if (isAssignmentLVal) {\r\n          // let binding.\r\n          // this is a bit more tricky as we need to cover the case where\r\n          // let is a local non-ref value, and we need to replicate the\r\n          // right hand side value.\r\n          // x = y --> isRef(x) ? x.value = y : x = y\r\n          const { right: rVal, operator } = parent as AssignmentExpression\r\n          const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1)\r\n          const rExpString = stringifyExpression(\r\n            processExpression(\r\n              createSimpleExpression(rExp, false),\r\n              context,\r\n              false,\r\n              false,\r\n              knownIds\r\n            )\r\n          )\r\n          return `${context.helperString(IS_REF)}(${raw})${\r\n            context.isTS ? ` //@ts-ignore\\n` : ``\r\n          } ? ${raw}.value ${operator} ${rExpString} : ${raw}`\r\n        } else if (isUpdateArg) {\r\n          // make id replace parent in the code range so the raw update operator\r\n          // is removed\r\n          id!.start = parent!.start\r\n          id!.end = parent!.end\r\n          const { prefix: isPrefix, operator } = parent as UpdateExpression\r\n          const prefix = isPrefix ? operator : ``\r\n          const postfix = isPrefix ? `` : operator\r\n          // let binding.\r\n          // x++ --> isRef(a) ? a.value++ : a++\r\n          return `${context.helperString(IS_REF)}(${raw})${\r\n            context.isTS ? ` //@ts-ignore\\n` : ``\r\n          } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`\r\n        } else if (isDestructureAssignment) {\r\n          // TODO\r\n          // let binding in a destructure assignment - it's very tricky to\r\n          // handle both possible cases here without altering the original\r\n          // structure of the code, so we just assume it's not a ref here\r\n          // for now\r\n          return raw\r\n        } else {\r\n          return `${context.helperString(UNREF)}(${raw})`\r\n        }\r\n      } else if (type === BindingTypes.PROPS) {\r\n        // use __props which is generated by compileScript so in ts mode\r\n        // it gets correct type\r\n        return genPropsAccessExp(raw)\r\n      } else if (type === BindingTypes.PROPS_ALIASED) {\r\n        // prop with a different local alias (from defineProps() destructure)\r\n        return genPropsAccessExp(bindingMetadata.__propsAliases![raw])\r\n      }\r\n    } else {\r\n      if (type && type.startsWith('setup')) {\r\n        // setup bindings in non-inline mode\r\n        return `$setup.${raw}`\r\n      } else if (type === BindingTypes.PROPS_ALIASED) {\r\n        return `$props['${bindingMetadata.__propsAliases![raw]}']`\r\n      } else if (type) {\r\n        return `$${type}.${raw}`\r\n      }\r\n    }\r\n\r\n    // fallback to ctx\r\n    return `_ctx.${raw}`\r\n  }\r\n\r\n  // fast path if expression is a simple identifier.\r\n  const rawExp = node.content\r\n  // bail constant on parens (function invocation) and dot (member access)\r\n  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0\r\n\r\n  if (isSimpleIdentifier(rawExp)) {\r\n    const isScopeVarReference = context.identifiers[rawExp]\r\n    const isAllowedGlobal = isGloballyWhitelisted(rawExp)\r\n    const isLiteral = isLiteralWhitelisted(rawExp)\r\n    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {\r\n      // const bindings exposed from setup can be skipped for patching but\r\n      // cannot be hoisted to module scope\r\n      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {\r\n        node.constType = ConstantTypes.CAN_SKIP_PATCH\r\n      }\r\n      node.content = rewriteIdentifier(rawExp)\r\n    } else if (!isScopeVarReference) {\r\n      if (isLiteral) {\r\n        node.constType = ConstantTypes.CAN_STRINGIFY\r\n      } else {\r\n        node.constType = ConstantTypes.CAN_HOIST\r\n      }\r\n    }\r\n    return node\r\n  }\r\n\r\n  let ast: any\r\n  // exp needs to be parsed differently:\r\n  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw\r\n  //    exp, but make sure to pad with spaces for consistent ranges\r\n  // 2. Expressions: wrap with parens (for e.g. object expressions)\r\n  // 3. Function arguments (v-for, v-slot): place in a function argument position\r\n  const source = asRawStatements\r\n    ? ` ${rawExp} `\r\n    : `(${rawExp})${asParams ? `=>{}` : ``}`\r\n  try {\r\n    ast = parse(source, {\r\n      plugins: context.expressionPlugins\r\n    }).program\r\n  } catch (e: any) {\r\n    context.onError(\r\n      createCompilerError(\r\n        ErrorCodes.X_INVALID_EXPRESSION,\r\n        node.loc,\r\n        undefined,\r\n        e.message\r\n      )\r\n    )\r\n    return node\r\n  }\r\n\r\n  type QualifiedId = Identifier & PrefixMeta\r\n  const ids: QualifiedId[] = []\r\n  const parentStack: Node[] = []\r\n  const knownIds: Record<string, number> = Object.create(context.identifiers)\r\n\r\n  walkIdentifiers(\r\n    ast,\r\n    (node, parent, _, isReferenced, isLocal) => {\r\n      if (isStaticPropertyKey(node, parent!)) {\r\n        return\r\n      }\r\n      // v2 wrapped filter call\r\n      if (__COMPAT__ && node.name.startsWith('_filter_')) {\r\n        return\r\n      }\r\n\r\n      const needPrefix = isReferenced && canPrefix(node)\r\n      if (needPrefix && !isLocal) {\r\n        if (isStaticProperty(parent!) && parent.shorthand) {\r\n          // property shorthand like { foo }, we need to add the key since\r\n          // we rewrite the value\r\n          ;(node as QualifiedId).prefix = `${node.name}: `\r\n        }\r\n        node.name = rewriteIdentifier(node.name, parent, node)\r\n        ids.push(node as QualifiedId)\r\n      } else {\r\n        // The identifier is considered constant unless it's pointing to a\r\n        // local scope variable (a v-for alias, or a v-slot prop)\r\n        if (!(needPrefix && isLocal) && !bailConstant) {\r\n          ;(node as QualifiedId).isConstant = true\r\n        }\r\n        // also generate sub-expressions for other identifiers for better\r\n        // source map support. (except for property keys which are static)\r\n        ids.push(node as QualifiedId)\r\n      }\r\n    },\r\n    true, // invoke on ALL identifiers\r\n    parentStack,\r\n    knownIds\r\n  )\r\n\r\n  // We break up the compound expression into an array of strings and sub\r\n  // expressions (for identifiers that have been prefixed). In codegen, if\r\n  // an ExpressionNode has the `.children` property, it will be used instead of\r\n  // `.content`.\r\n  const children: CompoundExpressionNode['children'] = []\r\n  ids.sort((a, b) => a.start - b.start)\r\n  ids.forEach((id, i) => {\r\n    // range is offset by -1 due to the wrapping parens when parsed\r\n    const start = id.start - 1\r\n    const end = id.end - 1\r\n    const last = ids[i - 1]\r\n    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)\r\n    if (leadingText.length || id.prefix) {\r\n      children.push(leadingText + (id.prefix || ``))\r\n    }\r\n    const source = rawExp.slice(start, end)\r\n    children.push(\r\n      createSimpleExpression(\r\n        id.name,\r\n        false,\r\n        {\r\n          source,\r\n          start: advancePositionWithClone(node.loc.start, source, start),\r\n          end: advancePositionWithClone(node.loc.start, source, end)\r\n        },\r\n        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT\r\n      )\r\n    )\r\n    if (i === ids.length - 1 && end < rawExp.length) {\r\n      children.push(rawExp.slice(end))\r\n    }\r\n  })\r\n\r\n  let ret\r\n  if (children.length) {\r\n    ret = createCompoundExpression(children, node.loc)\r\n  } else {\r\n    ret = node\r\n    ret.constType = bailConstant\r\n      ? ConstantTypes.NOT_CONSTANT\r\n      : ConstantTypes.CAN_STRINGIFY\r\n  }\r\n  ret.identifiers = Object.keys(knownIds)\r\n  return ret\r\n}\r\n\r\nfunction canPrefix(id: Identifier) {\r\n  // skip whitelisted globals\r\n  if (isGloballyWhitelisted(id.name)) {\r\n    return false\r\n  }\r\n  // special case for webpack compilation\r\n  if (id.name === 'require') {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction stringifyExpression(exp: ExpressionNode | string): string {\r\n  if (isString(exp)) {\r\n    return exp\r\n  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    return exp.content\r\n  } else {\r\n    return (exp.children as (ExpressionNode | string)[])\r\n      .map(stringifyExpression)\r\n      .join('')\r\n  }\r\n}\r\n","import {\r\n  createStructuralDirectiveTransform,\r\n  TransformContext,\r\n  traverseNode\r\n} from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  ElementTypes,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  IfBranchNode,\r\n  SimpleExpressionNode,\r\n  createCallExpression,\r\n  createConditionalExpression,\r\n  createSimpleExpression,\r\n  createObjectProperty,\r\n  createObjectExpression,\r\n  IfConditionalExpression,\r\n  BlockCodegenNode,\r\n  IfNode,\r\n  createVNodeCall,\r\n  AttributeNode,\r\n  locStub,\r\n  CacheExpression,\r\n  ConstantTypes,\r\n  MemoExpression\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { FRAGMENT, CREATE_COMMENT } from '../runtimeHelpers'\r\nimport {\r\n  injectProp,\r\n  findDir,\r\n  findProp,\r\n  isBuiltInType,\r\n  makeBlock\r\n} from '../utils'\r\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\r\nimport { getMemoedVNodeCall } from '..'\r\n\r\nexport const transformIf = createStructuralDirectiveTransform(\r\n  /^(if|else|else-if)$/,\r\n  (node, dir, context) => {\r\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n      // #1587: We need to dynamically increment the key based on the current\r\n      // node's sibling nodes, since chained v-if/else branches are\r\n      // rendered at the same depth\r\n      const siblings = context.parent!.children\r\n      let i = siblings.indexOf(ifNode)\r\n      let key = 0\r\n      while (i-- >= 0) {\r\n        const sibling = siblings[i]\r\n        if (sibling && sibling.type === NodeTypes.IF) {\r\n          key += sibling.branches.length\r\n        }\r\n      }\r\n\r\n      // Exit callback. Complete the codegenNode when all children have been\r\n      // transformed.\r\n      return () => {\r\n        if (isRoot) {\r\n          ifNode.codegenNode = createCodegenNodeForBranch(\r\n            branch,\r\n            key,\r\n            context\r\n          ) as IfConditionalExpression\r\n        } else {\r\n          // attach this branch's codegen node to the v-if root.\r\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\r\n          parentCondition.alternate = createCodegenNodeForBranch(\r\n            branch,\r\n            key + ifNode.branches.length - 1,\r\n            context\r\n          )\r\n        }\r\n      }\r\n    })\r\n  }\r\n)\r\n\r\n// target-agnostic transform used for both Client and SSR\r\nexport function processIf(\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n  processCodegen?: (\r\n    node: IfNode,\r\n    branch: IfBranchNode,\r\n    isRoot: boolean\r\n  ) => (() => void) | undefined\r\n) {\r\n  if (\r\n    dir.name !== 'else' &&\r\n    (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\r\n  ) {\r\n    const loc = dir.exp ? dir.exp.loc : node.loc\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc)\r\n    )\r\n    dir.exp = createSimpleExpression(`true`, false, loc)\r\n  }\r\n\r\n  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\r\n    // dir.exp can only be simple expression because vIf transform is applied\r\n    // before expression transform.\r\n    dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\r\n  }\r\n\r\n  if (__DEV__ && __BROWSER__ && dir.exp) {\r\n    validateBrowserExpression(dir.exp as SimpleExpressionNode, context)\r\n  }\r\n\r\n  if (dir.name === 'if') {\r\n    const branch = createIfBranch(node, dir)\r\n    const ifNode: IfNode = {\r\n      type: NodeTypes.IF,\r\n      loc: node.loc,\r\n      branches: [branch]\r\n    }\r\n    context.replaceNode(ifNode)\r\n    if (processCodegen) {\r\n      return processCodegen(ifNode, branch, true)\r\n    }\r\n  } else {\r\n    // locate the adjacent v-if\r\n    const siblings = context.parent!.children\r\n    const comments = []\r\n    let i = siblings.indexOf(node)\r\n    while (i-- >= -1) {\r\n      const sibling = siblings[i]\r\n      if (__DEV__ && sibling && sibling.type === NodeTypes.COMMENT) {\r\n        context.removeNode(sibling)\r\n        comments.unshift(sibling)\r\n        continue\r\n      }\r\n\r\n      if (\r\n        sibling &&\r\n        sibling.type === NodeTypes.TEXT &&\r\n        !sibling.content.trim().length\r\n      ) {\r\n        context.removeNode(sibling)\r\n        continue\r\n      }\r\n\r\n      if (sibling && sibling.type === NodeTypes.IF) {\r\n        // Check if v-else was followed by v-else-if\r\n        if (\r\n          dir.name === 'else-if' &&\r\n          sibling.branches[sibling.branches.length - 1].condition === undefined\r\n        ) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\r\n          )\r\n        }\r\n\r\n        // move the node to the if node's branches\r\n        context.removeNode()\r\n        const branch = createIfBranch(node, dir)\r\n        if (\r\n          __DEV__ &&\r\n          comments.length &&\r\n          // #3619 ignore comments if the v-if is direct child of <transition>\r\n          !(\r\n            context.parent &&\r\n            context.parent.type === NodeTypes.ELEMENT &&\r\n            isBuiltInType(context.parent.tag, 'transition')\r\n          )\r\n        ) {\r\n          branch.children = [...comments, ...branch.children]\r\n        }\r\n\r\n        // check if user is forcing same key on different branches\r\n        if (__DEV__ || !__BROWSER__) {\r\n          const key = branch.userKey\r\n          if (key) {\r\n            sibling.branches.forEach(({ userKey }) => {\r\n              if (isSameKey(userKey, key)) {\r\n                context.onError(\r\n                  createCompilerError(\r\n                    ErrorCodes.X_V_IF_SAME_KEY,\r\n                    branch.userKey!.loc\r\n                  )\r\n                )\r\n              }\r\n            })\r\n          }\r\n        }\r\n\r\n        sibling.branches.push(branch)\r\n        const onExit = processCodegen && processCodegen(sibling, branch, false)\r\n        // since the branch was removed, it will not be traversed.\r\n        // make sure to traverse here.\r\n        traverseNode(branch, context)\r\n        // call on exit\r\n        if (onExit) onExit()\r\n        // make sure to reset currentNode after traversal to indicate this\r\n        // node has been removed.\r\n        context.currentNode = null\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\r\n        )\r\n      }\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\r\n  const isTemplateIf = node.tagType === ElementTypes.TEMPLATE\r\n  return {\r\n    type: NodeTypes.IF_BRANCH,\r\n    loc: node.loc,\r\n    condition: dir.name === 'else' ? undefined : dir.exp,\r\n    children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],\r\n    userKey: findProp(node, `key`),\r\n    isTemplateIf\r\n  }\r\n}\r\n\r\nfunction createCodegenNodeForBranch(\r\n  branch: IfBranchNode,\r\n  keyIndex: number,\r\n  context: TransformContext\r\n): IfConditionalExpression | BlockCodegenNode | MemoExpression {\r\n  if (branch.condition) {\r\n    return createConditionalExpression(\r\n      branch.condition,\r\n      createChildrenCodegenNode(branch, keyIndex, context),\r\n      // make sure to pass in asBlock: true so that the comment node call\r\n      // closes the current block.\r\n      createCallExpression(context.helper(CREATE_COMMENT), [\r\n        __DEV__ ? '\"v-if\"' : '\"\"',\r\n        'true'\r\n      ])\r\n    ) as IfConditionalExpression\r\n  } else {\r\n    return createChildrenCodegenNode(branch, keyIndex, context)\r\n  }\r\n}\r\n\r\nfunction createChildrenCodegenNode(\r\n  branch: IfBranchNode,\r\n  keyIndex: number,\r\n  context: TransformContext\r\n): BlockCodegenNode | MemoExpression {\r\n  const { helper } = context\r\n  const keyProperty = createObjectProperty(\r\n    `key`,\r\n    createSimpleExpression(\r\n      `${keyIndex}`,\r\n      false,\r\n      locStub,\r\n      ConstantTypes.CAN_HOIST\r\n    )\r\n  )\r\n  const { children } = branch\r\n  const firstChild = children[0]\r\n  const needFragmentWrapper =\r\n    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT\r\n  if (needFragmentWrapper) {\r\n    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {\r\n      // optimize away nested fragments when child is a ForNode\r\n      const vnodeCall = firstChild.codegenNode!\r\n      injectProp(vnodeCall, keyProperty, context)\r\n      return vnodeCall\r\n    } else {\r\n      let patchFlag = PatchFlags.STABLE_FRAGMENT\r\n      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\r\n      // check if the fragment actually contains a single valid child with\r\n      // the rest being comments\r\n      if (\r\n        __DEV__ &&\r\n        !branch.isTemplateIf &&\r\n        children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\r\n      ) {\r\n        patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\r\n        patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\r\n      }\r\n\r\n      return createVNodeCall(\r\n        context,\r\n        helper(FRAGMENT),\r\n        createObjectExpression([keyProperty]),\r\n        children,\r\n        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\r\n        undefined,\r\n        undefined,\r\n        true,\r\n        false,\r\n        false /* isComponent */,\r\n        branch.loc\r\n      )\r\n    }\r\n  } else {\r\n    const ret = (firstChild as ElementNode).codegenNode as\r\n      | BlockCodegenNode\r\n      | MemoExpression\r\n    const vnodeCall = getMemoedVNodeCall(ret)\r\n    // Change createVNode to createBlock.\r\n    if (vnodeCall.type === NodeTypes.VNODE_CALL) {\r\n      makeBlock(vnodeCall, context)\r\n    }\r\n    // inject branch key\r\n    injectProp(vnodeCall, keyProperty, context)\r\n    return ret\r\n  }\r\n}\r\n\r\nfunction isSameKey(\r\n  a: AttributeNode | DirectiveNode | undefined,\r\n  b: AttributeNode | DirectiveNode\r\n): boolean {\r\n  if (!a || a.type !== b.type) {\r\n    return false\r\n  }\r\n  if (a.type === NodeTypes.ATTRIBUTE) {\r\n    if (a.value!.content !== (b as AttributeNode).value!.content) {\r\n      return false\r\n    }\r\n  } else {\r\n    // directive\r\n    const exp = a.exp!\r\n    const branchExp = (b as DirectiveNode).exp!\r\n    if (exp.type !== branchExp.type) {\r\n      return false\r\n    }\r\n    if (\r\n      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||\r\n      exp.isStatic !== (branchExp as SimpleExpressionNode).isStatic ||\r\n      exp.content !== (branchExp as SimpleExpressionNode).content\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction getParentCondition(\r\n  node: IfConditionalExpression | CacheExpression\r\n): IfConditionalExpression {\r\n  while (true) {\r\n    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\r\n      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\r\n        node = node.alternate\r\n      } else {\r\n        return node\r\n      }\r\n    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {\r\n      node = node.value as IfConditionalExpression\r\n    }\r\n  }\r\n}\r\n","import {\r\n  createStructuralDirectiveTransform,\r\n  TransformContext\r\n} from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  ExpressionNode,\r\n  createSimpleExpression,\r\n  SourceLocation,\r\n  SimpleExpressionNode,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  ForCodegenNode,\r\n  RenderSlotCall,\r\n  SlotOutletNode,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  ForNode,\r\n  PlainElementNode,\r\n  createVNodeCall,\r\n  VNodeCall,\r\n  ForRenderListExpression,\r\n  BlockCodegenNode,\r\n  ForIteratorExpression,\r\n  ConstantTypes,\r\n  createBlockStatement,\r\n  createCompoundExpression\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  getInnerRange,\r\n  findProp,\r\n  isTemplateNode,\r\n  isSlotOutlet,\r\n  injectProp,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper,\r\n  findDir\r\n} from '../utils'\r\nimport {\r\n  RENDER_LIST,\r\n  OPEN_BLOCK,\r\n  FRAGMENT,\r\n  IS_MEMO_SAME\r\n} from '../runtimeHelpers'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\r\n\r\nexport const transformFor = createStructuralDirectiveTransform(\r\n  'for',\r\n  (node, dir, context) => {\r\n    const { helper, removeHelper } = context\r\n    return processFor(node, dir, context, forNode => {\r\n      // create the loop render function expression now, and add the\r\n      // iterator on exit after all children have been traversed\r\n      const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n        forNode.source\r\n      ]) as ForRenderListExpression\r\n      const isTemplate = isTemplateNode(node)\r\n      const memo = findDir(node, 'memo')\r\n      const keyProp = findProp(node, `key`)\r\n      const keyExp =\r\n        keyProp &&\r\n        (keyProp.type === NodeTypes.ATTRIBUTE\r\n          ? createSimpleExpression(keyProp.value!.content, true)\r\n          : keyProp.exp!)\r\n      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp!) : null\r\n\r\n      if (!__BROWSER__ && isTemplate) {\r\n        // #2085 / #5288 process :key and v-memo expressions need to be\r\n        // processed on `<template v-for>`. In this case the node is discarded\r\n        // and never traversed so its binding expressions won't be processed\r\n        // by the normal transforms.\r\n        if (memo) {\r\n          memo.exp = processExpression(\r\n            memo.exp! as SimpleExpressionNode,\r\n            context\r\n          )\r\n        }\r\n        if (keyProperty && keyProp!.type !== NodeTypes.ATTRIBUTE) {\r\n          keyProperty.value = processExpression(\r\n            keyProperty.value as SimpleExpressionNode,\r\n            context\r\n          )\r\n        }\r\n      }\r\n\r\n      const isStableFragment =\r\n        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        forNode.source.constType > ConstantTypes.NOT_CONSTANT\r\n      const fragmentFlag = isStableFragment\r\n        ? PatchFlags.STABLE_FRAGMENT\r\n        : keyProp\r\n        ? PatchFlags.KEYED_FRAGMENT\r\n        : PatchFlags.UNKEYED_FRAGMENT\r\n\r\n      forNode.codegenNode = createVNodeCall(\r\n        context,\r\n        helper(FRAGMENT),\r\n        undefined,\r\n        renderExp,\r\n        fragmentFlag +\r\n          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),\r\n        undefined,\r\n        undefined,\r\n        true /* isBlock */,\r\n        !isStableFragment /* disableTracking */,\r\n        false /* isComponent */,\r\n        node.loc\r\n      ) as ForCodegenNode\r\n\r\n      return () => {\r\n        // finish the codegen now that all children have been traversed\r\n        let childBlock: BlockCodegenNode\r\n        const { children } = forNode\r\n\r\n        // check <template v-for> key placement\r\n        if ((__DEV__ || !__BROWSER__) && isTemplate) {\r\n          node.children.some(c => {\r\n            if (c.type === NodeTypes.ELEMENT) {\r\n              const key = findProp(c, 'key')\r\n              if (key) {\r\n                context.onError(\r\n                  createCompilerError(\r\n                    ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT,\r\n                    key.loc\r\n                  )\r\n                )\r\n                return true\r\n              }\r\n            }\r\n          })\r\n        }\r\n\r\n        const needFragmentWrapper =\r\n          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT\r\n        const slotOutlet = isSlotOutlet(node)\r\n          ? node\r\n          : isTemplate &&\r\n            node.children.length === 1 &&\r\n            isSlotOutlet(node.children[0])\r\n          ? (node.children[0] as SlotOutletNode) // api-extractor somehow fails to infer this\r\n          : null\r\n\r\n        if (slotOutlet) {\r\n          // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\r\n          childBlock = slotOutlet.codegenNode as RenderSlotCall\r\n          if (isTemplate && keyProperty) {\r\n            // <template v-for=\"...\" :key=\"...\"><slot/></template>\r\n            // we need to inject the key to the renderSlot() call.\r\n            // the props for renderSlot is passed as the 3rd argument.\r\n            injectProp(childBlock, keyProperty, context)\r\n          }\r\n        } else if (needFragmentWrapper) {\r\n          // <template v-for=\"...\"> with text or multi-elements\r\n          // should generate a fragment block for each loop\r\n          childBlock = createVNodeCall(\r\n            context,\r\n            helper(FRAGMENT),\r\n            keyProperty ? createObjectExpression([keyProperty]) : undefined,\r\n            node.children,\r\n            PatchFlags.STABLE_FRAGMENT +\r\n              (__DEV__\r\n                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`\r\n                : ``),\r\n            undefined,\r\n            undefined,\r\n            true,\r\n            undefined,\r\n            false /* isComponent */\r\n          )\r\n        } else {\r\n          // Normal element v-for. Directly use the child's codegenNode\r\n          // but mark it as a block.\r\n          childBlock = (children[0] as PlainElementNode)\r\n            .codegenNode as VNodeCall\r\n          if (isTemplate && keyProperty) {\r\n            injectProp(childBlock, keyProperty, context)\r\n          }\r\n          if (childBlock.isBlock !== !isStableFragment) {\r\n            if (childBlock.isBlock) {\r\n              // switch from block to vnode\r\n              removeHelper(OPEN_BLOCK)\r\n              removeHelper(\r\n                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)\r\n              )\r\n            } else {\r\n              // switch from vnode to block\r\n              removeHelper(\r\n                getVNodeHelper(context.inSSR, childBlock.isComponent)\r\n              )\r\n            }\r\n          }\r\n          childBlock.isBlock = !isStableFragment\r\n          if (childBlock.isBlock) {\r\n            helper(OPEN_BLOCK)\r\n            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))\r\n          } else {\r\n            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))\r\n          }\r\n        }\r\n\r\n        if (memo) {\r\n          const loop = createFunctionExpression(\r\n            createForLoopParams(forNode.parseResult, [\r\n              createSimpleExpression(`_cached`)\r\n            ])\r\n          )\r\n          loop.body = createBlockStatement([\r\n            createCompoundExpression([`const _memo = (`, memo.exp!, `)`]),\r\n            createCompoundExpression([\r\n              `if (_cached`,\r\n              ...(keyExp ? [` && _cached.key === `, keyExp] : []),\r\n              ` && ${context.helperString(\r\n                IS_MEMO_SAME\r\n              )}(_cached, _memo)) return _cached`\r\n            ]),\r\n            createCompoundExpression([`const _item = `, childBlock as any]),\r\n            createSimpleExpression(`_item.memo = _memo`),\r\n            createSimpleExpression(`return _item`)\r\n          ])\r\n          renderExp.arguments.push(\r\n            loop as ForIteratorExpression,\r\n            createSimpleExpression(`_cache`),\r\n            createSimpleExpression(String(context.cached++))\r\n          )\r\n        } else {\r\n          renderExp.arguments.push(\r\n            createFunctionExpression(\r\n              createForLoopParams(forNode.parseResult),\r\n              childBlock,\r\n              true /* force newline */\r\n            ) as ForIteratorExpression\r\n          )\r\n        }\r\n      }\r\n    })\r\n  }\r\n)\r\n\r\n// target-agnostic transform used for both Client and SSR\r\nexport function processFor(\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n  processCodegen?: (forNode: ForNode) => (() => void) | undefined\r\n) {\r\n  if (!dir.exp) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc)\r\n    )\r\n    return\r\n  }\r\n\r\n  const parseResult = parseForExpression(\r\n    // can only be simple expression because vFor transform is applied\r\n    // before expression transform.\r\n    dir.exp as SimpleExpressionNode,\r\n    context\r\n  )\r\n\r\n  if (!parseResult) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc)\r\n    )\r\n    return\r\n  }\r\n\r\n  const { addIdentifiers, removeIdentifiers, scopes } = context\r\n  const { source, value, key, index } = parseResult\r\n\r\n  const forNode: ForNode = {\r\n    type: NodeTypes.FOR,\r\n    loc: dir.loc,\r\n    source,\r\n    valueAlias: value,\r\n    keyAlias: key,\r\n    objectIndexAlias: index,\r\n    parseResult,\r\n    children: isTemplateNode(node) ? node.children : [node]\r\n  }\r\n\r\n  context.replaceNode(forNode)\r\n\r\n  // bookkeeping\r\n  scopes.vFor++\r\n  if (!__BROWSER__ && context.prefixIdentifiers) {\r\n    // scope management\r\n    // inject identifiers to context\r\n    value && addIdentifiers(value)\r\n    key && addIdentifiers(key)\r\n    index && addIdentifiers(index)\r\n  }\r\n\r\n  const onExit = processCodegen && processCodegen(forNode)\r\n\r\n  return () => {\r\n    scopes.vFor--\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      value && removeIdentifiers(value)\r\n      key && removeIdentifiers(key)\r\n      index && removeIdentifiers(index)\r\n    }\r\n    if (onExit) onExit()\r\n  }\r\n}\r\n\r\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\r\n// This regex doesn't cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\r\nconst stripParensRE = /^\\(|\\)$/g\r\n\r\nexport interface ForParseResult {\r\n  source: ExpressionNode\r\n  value: ExpressionNode | undefined\r\n  key: ExpressionNode | undefined\r\n  index: ExpressionNode | undefined\r\n}\r\n\r\nexport function parseForExpression(\r\n  input: SimpleExpressionNode,\r\n  context: TransformContext\r\n): ForParseResult | undefined {\r\n  const loc = input.loc\r\n  const exp = input.content\r\n  const inMatch = exp.match(forAliasRE)\r\n  if (!inMatch) return\r\n\r\n  const [, LHS, RHS] = inMatch\r\n\r\n  const result: ForParseResult = {\r\n    source: createAliasExpression(\r\n      loc,\r\n      RHS.trim(),\r\n      exp.indexOf(RHS, LHS.length)\r\n    ),\r\n    value: undefined,\r\n    key: undefined,\r\n    index: undefined\r\n  }\r\n  if (!__BROWSER__ && context.prefixIdentifiers) {\r\n    result.source = processExpression(\r\n      result.source as SimpleExpressionNode,\r\n      context\r\n    )\r\n  }\r\n  if (__DEV__ && __BROWSER__) {\r\n    validateBrowserExpression(result.source as SimpleExpressionNode, context)\r\n  }\r\n\r\n  let valueContent = LHS.trim().replace(stripParensRE, '').trim()\r\n  const trimmedOffset = LHS.indexOf(valueContent)\r\n\r\n  const iteratorMatch = valueContent.match(forIteratorRE)\r\n  if (iteratorMatch) {\r\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\r\n\r\n    const keyContent = iteratorMatch[1].trim()\r\n    let keyOffset: number | undefined\r\n    if (keyContent) {\r\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\r\n      result.key = createAliasExpression(loc, keyContent, keyOffset)\r\n      if (!__BROWSER__ && context.prefixIdentifiers) {\r\n        result.key = processExpression(result.key, context, true)\r\n      }\r\n      if (__DEV__ && __BROWSER__) {\r\n        validateBrowserExpression(\r\n          result.key as SimpleExpressionNode,\r\n          context,\r\n          true\r\n        )\r\n      }\r\n    }\r\n\r\n    if (iteratorMatch[2]) {\r\n      const indexContent = iteratorMatch[2].trim()\r\n\r\n      if (indexContent) {\r\n        result.index = createAliasExpression(\r\n          loc,\r\n          indexContent,\r\n          exp.indexOf(\r\n            indexContent,\r\n            result.key\r\n              ? keyOffset! + keyContent.length\r\n              : trimmedOffset + valueContent.length\r\n          )\r\n        )\r\n        if (!__BROWSER__ && context.prefixIdentifiers) {\r\n          result.index = processExpression(result.index, context, true)\r\n        }\r\n        if (__DEV__ && __BROWSER__) {\r\n          validateBrowserExpression(\r\n            result.index as SimpleExpressionNode,\r\n            context,\r\n            true\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (valueContent) {\r\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset)\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      result.value = processExpression(result.value, context, true)\r\n    }\r\n    if (__DEV__ && __BROWSER__) {\r\n      validateBrowserExpression(\r\n        result.value as SimpleExpressionNode,\r\n        context,\r\n        true\r\n      )\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction createAliasExpression(\r\n  range: SourceLocation,\r\n  content: string,\r\n  offset: number\r\n): SimpleExpressionNode {\r\n  return createSimpleExpression(\r\n    content,\r\n    false,\r\n    getInnerRange(range, offset, content.length)\r\n  )\r\n}\r\n\r\nexport function createForLoopParams(\r\n  { value, key, index }: ForParseResult,\r\n  memoArgs: ExpressionNode[] = []\r\n): ExpressionNode[] {\r\n  return createParamsList([value, key, index, ...memoArgs])\r\n}\r\n\r\nfunction createParamsList(\r\n  args: (ExpressionNode | undefined)[]\r\n): ExpressionNode[] {\r\n  let i = args.length\r\n  while (i--) {\r\n    if (args[i]) break\r\n  }\r\n  return args\r\n    .slice(0, i + 1)\r\n    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))\r\n}\r\n","import {\r\n  ElementNode,\r\n  ObjectExpression,\r\n  createObjectExpression,\r\n  NodeTypes,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createFunctionExpression,\r\n  DirectiveNode,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  Property,\r\n  TemplateChildNode,\r\n  SourceLocation,\r\n  createConditionalExpression,\r\n  ConditionalExpression,\r\n  SimpleExpressionNode,\r\n  FunctionExpression,\r\n  CallExpression,\r\n  createCallExpression,\r\n  createArrayExpression,\r\n  SlotsExpression\r\n} from '../ast'\r\nimport { TransformContext, NodeTransform } from '../transform'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  findDir,\r\n  isTemplateNode,\r\n  assert,\r\n  isVSlot,\r\n  hasScopeRef,\r\n  isStaticExp\r\n} from '../utils'\r\nimport { CREATE_SLOTS, RENDER_LIST, WITH_CTX } from '../runtimeHelpers'\r\nimport { parseForExpression, createForLoopParams } from './vFor'\r\nimport { SlotFlags, slotFlagsText } from '@vue/shared'\r\n\r\nconst defaultFallback = createSimpleExpression(`undefined`, false)\r\n\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nexport const trackSlotScopes: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    (node.tagType === ElementTypes.COMPONENT ||\r\n      node.tagType === ElementTypes.TEMPLATE)\r\n  ) {\r\n    // We are only checking non-empty v-slot here\r\n    // since we only care about slots that introduce scope variables.\r\n    const vSlot = findDir(node, 'slot')\r\n    if (vSlot) {\r\n      const slotProps = vSlot.exp\r\n      if (!__BROWSER__ && context.prefixIdentifiers) {\r\n        slotProps && context.addIdentifiers(slotProps)\r\n      }\r\n      context.scopes.vSlot++\r\n      return () => {\r\n        if (!__BROWSER__ && context.prefixIdentifiers) {\r\n          slotProps && context.removeIdentifiers(slotProps)\r\n        }\r\n        context.scopes.vSlot--\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\r\n  let vFor\r\n  if (\r\n    isTemplateNode(node) &&\r\n    node.props.some(isVSlot) &&\r\n    (vFor = findDir(node, 'for'))\r\n  ) {\r\n    const result = (vFor.parseResult = parseForExpression(\r\n      vFor.exp as SimpleExpressionNode,\r\n      context\r\n    ))\r\n    if (result) {\r\n      const { value, key, index } = result\r\n      const { addIdentifiers, removeIdentifiers } = context\r\n      value && addIdentifiers(value)\r\n      key && addIdentifiers(key)\r\n      index && addIdentifiers(index)\r\n\r\n      return () => {\r\n        value && removeIdentifiers(value)\r\n        key && removeIdentifiers(key)\r\n        index && removeIdentifiers(index)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport type SlotFnBuilder = (\r\n  slotProps: ExpressionNode | undefined,\r\n  slotChildren: TemplateChildNode[],\r\n  loc: SourceLocation\r\n) => FunctionExpression\r\n\r\nconst buildClientSlotFn: SlotFnBuilder = (props, children, loc) =>\r\n  createFunctionExpression(\r\n    props,\r\n    children,\r\n    false /* newline */,\r\n    true /* isSlot */,\r\n    children.length ? children[0].loc : loc\r\n  )\r\n\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nexport function buildSlots(\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  buildSlotFn: SlotFnBuilder = buildClientSlotFn\r\n): {\r\n  slots: SlotsExpression\r\n  hasDynamicSlots: boolean\r\n} {\r\n  context.helper(WITH_CTX)\r\n\r\n  const { children, loc } = node\r\n  const slotsProperties: Property[] = []\r\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\r\n\r\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n  // since it likely uses a scope variable.\r\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\r\n  // with `prefixIdentifiers: true`, this can be further optimized to make\r\n  // it dynamic only when the slot actually uses the scope variables.\r\n  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {\r\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\r\n  }\r\n\r\n  // 1. Check for slot with slotProps on component itself.\r\n  //    <Comp v-slot=\"{ prop }\"/>\r\n  const onComponentSlot = findDir(node, 'slot', true)\r\n  if (onComponentSlot) {\r\n    const { arg, exp } = onComponentSlot\r\n    if (arg && !isStaticExp(arg)) {\r\n      hasDynamicSlots = true\r\n    }\r\n    slotsProperties.push(\r\n      createObjectProperty(\r\n        arg || createSimpleExpression('default', true),\r\n        buildSlotFn(exp, children, loc)\r\n      )\r\n    )\r\n  }\r\n\r\n  // 2. Iterate through children and check for template slots\r\n  //    <template v-slot:foo=\"{ prop }\">\r\n  let hasTemplateSlots = false\r\n  let hasNamedDefaultSlot = false\r\n  const implicitDefaultChildren: TemplateChildNode[] = []\r\n  const seenSlotNames = new Set<string>()\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const slotElement = children[i]\r\n    let slotDir\r\n\r\n    if (\r\n      !isTemplateNode(slotElement) ||\r\n      !(slotDir = findDir(slotElement, 'slot', true))\r\n    ) {\r\n      // not a <template v-slot>, skip.\r\n      if (slotElement.type !== NodeTypes.COMMENT) {\r\n        implicitDefaultChildren.push(slotElement)\r\n      }\r\n      continue\r\n    }\r\n\r\n    if (onComponentSlot) {\r\n      // already has on-component slot - this is incorrect usage.\r\n      context.onError(\r\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc)\r\n      )\r\n      break\r\n    }\r\n\r\n    hasTemplateSlots = true\r\n    const { children: slotChildren, loc: slotLoc } = slotElement\r\n    const {\r\n      arg: slotName = createSimpleExpression(`default`, true),\r\n      exp: slotProps,\r\n      loc: dirLoc\r\n    } = slotDir\r\n\r\n    // check if name is dynamic.\r\n    let staticSlotName: string | undefined\r\n    if (isStaticExp(slotName)) {\r\n      staticSlotName = slotName ? slotName.content : `default`\r\n    } else {\r\n      hasDynamicSlots = true\r\n    }\r\n\r\n    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc)\r\n    // check if this slot is conditional (v-if/v-for)\r\n    let vIf: DirectiveNode | undefined\r\n    let vElse: DirectiveNode | undefined\r\n    let vFor: DirectiveNode | undefined\r\n    if ((vIf = findDir(slotElement, 'if'))) {\r\n      hasDynamicSlots = true\r\n      dynamicSlots.push(\r\n        createConditionalExpression(\r\n          vIf.exp!,\r\n          buildDynamicSlot(slotName, slotFunction),\r\n          defaultFallback\r\n        )\r\n      )\r\n    } else if (\r\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\r\n    ) {\r\n      // find adjacent v-if\r\n      let j = i\r\n      let prev\r\n      while (j--) {\r\n        prev = children[j]\r\n        if (prev.type !== NodeTypes.COMMENT) {\r\n          break\r\n        }\r\n      }\r\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n        // remove node\r\n        children.splice(i, 1)\r\n        i--\r\n        __TEST__ && assert(dynamicSlots.length > 0)\r\n        // attach this slot to previous conditional\r\n        let conditional = dynamicSlots[\r\n          dynamicSlots.length - 1\r\n        ] as ConditionalExpression\r\n        while (\r\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n        ) {\r\n          conditional = conditional.alternate\r\n        }\r\n        conditional.alternate = vElse.exp\r\n          ? createConditionalExpression(\r\n              vElse.exp,\r\n              buildDynamicSlot(slotName, slotFunction),\r\n              defaultFallback\r\n            )\r\n          : buildDynamicSlot(slotName, slotFunction)\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)\r\n        )\r\n      }\r\n    } else if ((vFor = findDir(slotElement, 'for'))) {\r\n      hasDynamicSlots = true\r\n      const parseResult =\r\n        vFor.parseResult ||\r\n        parseForExpression(vFor.exp as SimpleExpressionNode, context)\r\n      if (parseResult) {\r\n        // Render the dynamic slots as an array and add it to the createSlot()\r\n        // args. The runtime knows how to handle it appropriately.\r\n        dynamicSlots.push(\r\n          createCallExpression(context.helper(RENDER_LIST), [\r\n            parseResult.source,\r\n            createFunctionExpression(\r\n              createForLoopParams(parseResult),\r\n              buildDynamicSlot(slotName, slotFunction),\r\n              true /* force newline */\r\n            )\r\n          ])\r\n        )\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, vFor.loc)\r\n        )\r\n      }\r\n    } else {\r\n      // check duplicate static names\r\n      if (staticSlotName) {\r\n        if (seenSlotNames.has(staticSlotName)) {\r\n          context.onError(\r\n            createCompilerError(\r\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\r\n              dirLoc\r\n            )\r\n          )\r\n          continue\r\n        }\r\n        seenSlotNames.add(staticSlotName)\r\n        if (staticSlotName === 'default') {\r\n          hasNamedDefaultSlot = true\r\n        }\r\n      }\r\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\r\n    }\r\n  }\r\n\r\n  if (!onComponentSlot) {\r\n    const buildDefaultSlotProperty = (\r\n      props: ExpressionNode | undefined,\r\n      children: TemplateChildNode[]\r\n    ) => {\r\n      const fn = buildSlotFn(props, children, loc)\r\n      if (__COMPAT__ && context.compatConfig) {\r\n        fn.isNonScopedSlot = true\r\n      }\r\n      return createObjectProperty(`default`, fn)\r\n    }\r\n\r\n    if (!hasTemplateSlots) {\r\n      // implicit default slot (on component)\r\n      slotsProperties.push(buildDefaultSlotProperty(undefined, children))\r\n    } else if (\r\n      implicitDefaultChildren.length &&\r\n      // #3766\r\n      // with whitespace: 'preserve', whitespaces between slots will end up in\r\n      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\r\n      implicitDefaultChildren.some(node => isNonWhitespaceContent(node))\r\n    ) {\r\n      // implicit default slot (mixed with named slots)\r\n      if (hasNamedDefaultSlot) {\r\n        context.onError(\r\n          createCompilerError(\r\n            ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\r\n            implicitDefaultChildren[0].loc\r\n          )\r\n        )\r\n      } else {\r\n        slotsProperties.push(\r\n          buildDefaultSlotProperty(undefined, implicitDefaultChildren)\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const slotFlag = hasDynamicSlots\r\n    ? SlotFlags.DYNAMIC\r\n    : hasForwardedSlots(node.children)\r\n    ? SlotFlags.FORWARDED\r\n    : SlotFlags.STABLE\r\n\r\n  let slots = createObjectExpression(\r\n    slotsProperties.concat(\r\n      createObjectProperty(\r\n        `_`,\r\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n        // 1 = compiled and static = can skip normalization AND diff as optimized\r\n        createSimpleExpression(\r\n          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),\r\n          false\r\n        )\r\n      )\r\n    ),\r\n    loc\r\n  ) as SlotsExpression\r\n  if (dynamicSlots.length) {\r\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n      slots,\r\n      createArrayExpression(dynamicSlots)\r\n    ]) as SlotsExpression\r\n  }\r\n\r\n  return {\r\n    slots,\r\n    hasDynamicSlots\r\n  }\r\n}\r\n\r\nfunction buildDynamicSlot(\r\n  name: ExpressionNode,\r\n  fn: FunctionExpression\r\n): ObjectExpression {\r\n  return createObjectExpression([\r\n    createObjectProperty(`name`, name),\r\n    createObjectProperty(`fn`, fn)\r\n  ])\r\n}\r\n\r\nfunction hasForwardedSlots(children: TemplateChildNode[]): boolean {\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    switch (child.type) {\r\n      case NodeTypes.ELEMENT:\r\n        if (\r\n          child.tagType === ElementTypes.SLOT ||\r\n          hasForwardedSlots(child.children)\r\n        ) {\r\n          return true\r\n        }\r\n        break\r\n      case NodeTypes.IF:\r\n        if (hasForwardedSlots(child.branches)) return true\r\n        break\r\n      case NodeTypes.IF_BRANCH:\r\n      case NodeTypes.FOR:\r\n        if (hasForwardedSlots(child.children)) return true\r\n        break\r\n      default:\r\n        break\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction isNonWhitespaceContent(node: TemplateChildNode): boolean {\r\n  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)\r\n    return true\r\n  return node.type === NodeTypes.TEXT\r\n    ? !!node.content.trim()\r\n    : isNonWhitespaceContent(node.content)\r\n}\r\n","import { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  ElementTypes,\r\n  CallExpression,\r\n  ObjectExpression,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  ExpressionNode,\r\n  ArrayExpression,\r\n  createCallExpression,\r\n  createArrayExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createObjectExpression,\r\n  Property,\r\n  ComponentNode,\r\n  VNodeCall,\r\n  TemplateTextChildNode,\r\n  DirectiveArguments,\r\n  createVNodeCall,\r\n  ConstantTypes\r\n} from '../ast'\r\nimport {\r\n  PatchFlags,\r\n  PatchFlagNames,\r\n  isSymbol,\r\n  isOn,\r\n  isObject,\r\n  isReservedProp,\r\n  capitalize,\r\n  camelize,\r\n  isBuiltInDirective\r\n} from '@vue/shared'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  RESOLVE_DIRECTIVE,\r\n  RESOLVE_COMPONENT,\r\n  RESOLVE_DYNAMIC_COMPONENT,\r\n  MERGE_PROPS,\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_STYLE,\r\n  NORMALIZE_PROPS,\r\n  TO_HANDLERS,\r\n  TELEPORT,\r\n  KEEP_ALIVE,\r\n  SUSPENSE,\r\n  UNREF,\r\n  GUARD_REACTIVE_PROPS\r\n} from '../runtimeHelpers'\r\nimport {\r\n  getInnerRange,\r\n  toValidAssetId,\r\n  findProp,\r\n  isCoreComponent,\r\n  isStaticArgOf,\r\n  findDir,\r\n  isStaticExp\r\n} from '../utils'\r\nimport { buildSlots } from './vSlot'\r\nimport { getConstantType } from './hoistStatic'\r\nimport { BindingTypes } from '../options'\r\nimport {\r\n  checkCompatEnabled,\r\n  CompilerDeprecationTypes,\r\n  isCompatEnabled\r\n} from '../compat/compatConfig'\r\n\r\n// some directive transforms (e.g. v-model) may return a symbol for runtime\r\n// import, which should be used instead of a resolveDirective call.\r\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\r\n\r\n// generate a JavaScript AST for this element's codegen\r\nexport const transformElement: NodeTransform = (node, context) => {\r\n  // perform the work on exit, after all child expressions have been\r\n  // processed and merged.\r\n  return function postTransformElement() {\r\n    node = context.currentNode!\r\n\r\n    if (\r\n      !(\r\n        node.type === NodeTypes.ELEMENT &&\r\n        (node.tagType === ElementTypes.ELEMENT ||\r\n          node.tagType === ElementTypes.COMPONENT)\r\n      )\r\n    ) {\r\n      return\r\n    }\r\n\r\n    const { tag, props } = node\r\n    const isComponent = node.tagType === ElementTypes.COMPONENT\r\n\r\n    // The goal of the transform is to create a codegenNode implementing the\r\n    // VNodeCall interface.\r\n    let vnodeTag = isComponent\r\n      ? resolveComponentType(node as ComponentNode, context)\r\n      : `\"${tag}\"`\r\n\r\n    const isDynamicComponent =\r\n      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT\r\n\r\n    let vnodeProps: VNodeCall['props']\r\n    let vnodeChildren: VNodeCall['children']\r\n    let vnodePatchFlag: VNodeCall['patchFlag']\r\n    let patchFlag: number = 0\r\n    let vnodeDynamicProps: VNodeCall['dynamicProps']\r\n    let dynamicPropNames: string[] | undefined\r\n    let vnodeDirectives: VNodeCall['directives']\r\n\r\n    let shouldUseBlock =\r\n      // dynamic component may resolve to plain elements\r\n      isDynamicComponent ||\r\n      vnodeTag === TELEPORT ||\r\n      vnodeTag === SUSPENSE ||\r\n      (!isComponent &&\r\n        // <svg> and <foreignObject> must be forced into blocks so that block\r\n        // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n        // This is technically web-specific, but splitting the logic out of core\r\n        // leads to too much unnecessary complexity.\r\n        (tag === 'svg' || tag === 'foreignObject'))\r\n\r\n    // props\r\n    if (props.length > 0) {\r\n      const propsBuildResult = buildProps(\r\n        node,\r\n        context,\r\n        undefined,\r\n        isComponent,\r\n        isDynamicComponent\r\n      )\r\n      vnodeProps = propsBuildResult.props\r\n      patchFlag = propsBuildResult.patchFlag\r\n      dynamicPropNames = propsBuildResult.dynamicPropNames\r\n      const directives = propsBuildResult.directives\r\n      vnodeDirectives =\r\n        directives && directives.length\r\n          ? (createArrayExpression(\r\n              directives.map(dir => buildDirectiveArgs(dir, context))\r\n            ) as DirectiveArguments)\r\n          : undefined\r\n\r\n      if (propsBuildResult.shouldUseBlock) {\r\n        shouldUseBlock = true\r\n      }\r\n    }\r\n\r\n    // children\r\n    if (node.children.length > 0) {\r\n      if (vnodeTag === KEEP_ALIVE) {\r\n        // Although a built-in component, we compile KeepAlive with raw children\r\n        // instead of slot functions so that it can be used inside Transition\r\n        // or other Transition-wrapping HOCs.\r\n        // To ensure correct updates with block optimizations, we need to:\r\n        // 1. Force keep-alive into a block. This avoids its children being\r\n        //    collected by a parent block.\r\n        shouldUseBlock = true\r\n        // 2. Force keep-alive to always be updated, since it uses raw children.\r\n        patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        if (__DEV__ && node.children.length > 1) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN, {\r\n              start: node.children[0].loc.start,\r\n              end: node.children[node.children.length - 1].loc.end,\r\n              source: ''\r\n            })\r\n          )\r\n        }\r\n      }\r\n\r\n      const shouldBuildAsSlots =\r\n        isComponent &&\r\n        // Teleport is not a real component and has dedicated runtime handling\r\n        vnodeTag !== TELEPORT &&\r\n        // explained above.\r\n        vnodeTag !== KEEP_ALIVE\r\n\r\n      if (shouldBuildAsSlots) {\r\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\r\n        vnodeChildren = slots\r\n        if (hasDynamicSlots) {\r\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        }\r\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n        const child = node.children[0]\r\n        const type = child.type\r\n        // check for dynamic text children\r\n        const hasDynamicTextChild =\r\n          type === NodeTypes.INTERPOLATION ||\r\n          type === NodeTypes.COMPOUND_EXPRESSION\r\n        if (\r\n          hasDynamicTextChild &&\r\n          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\r\n        ) {\r\n          patchFlag |= PatchFlags.TEXT\r\n        }\r\n        // pass directly if the only child is a text node\r\n        // (plain / interpolation / expression)\r\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\r\n          vnodeChildren = child as TemplateTextChildNode\r\n        } else {\r\n          vnodeChildren = node.children\r\n        }\r\n      } else {\r\n        vnodeChildren = node.children\r\n      }\r\n    }\r\n\r\n    // patchFlag & dynamicPropNames\r\n    if (patchFlag !== 0) {\r\n      if (__DEV__) {\r\n        if (patchFlag < 0) {\r\n          // special flags (negative and mutually exclusive)\r\n          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`\r\n        } else {\r\n          // bitwise flags\r\n          const flagNames = Object.keys(PatchFlagNames)\r\n            .map(Number)\r\n            .filter(n => n > 0 && patchFlag & n)\r\n            .map(n => PatchFlagNames[n])\r\n            .join(`, `)\r\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`\r\n        }\r\n      } else {\r\n        vnodePatchFlag = String(patchFlag)\r\n      }\r\n      if (dynamicPropNames && dynamicPropNames.length) {\r\n        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)\r\n      }\r\n    }\r\n\r\n    node.codegenNode = createVNodeCall(\r\n      context,\r\n      vnodeTag,\r\n      vnodeProps,\r\n      vnodeChildren,\r\n      vnodePatchFlag,\r\n      vnodeDynamicProps,\r\n      vnodeDirectives,\r\n      !!shouldUseBlock,\r\n      false /* disableTracking */,\r\n      isComponent,\r\n      node.loc\r\n    )\r\n  }\r\n}\r\n\r\nexport function resolveComponentType(\r\n  node: ComponentNode,\r\n  context: TransformContext,\r\n  ssr = false\r\n) {\r\n  let { tag } = node\r\n\r\n  // 1. dynamic component\r\n  const isExplicitDynamic = isComponentTag(tag)\r\n  const isProp = findProp(node, 'is')\r\n  if (isProp) {\r\n    if (\r\n      isExplicitDynamic ||\r\n      (__COMPAT__ &&\r\n        isCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n          context\r\n        ))\r\n    ) {\r\n      const exp =\r\n        isProp.type === NodeTypes.ATTRIBUTE\r\n          ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n          : isProp.exp\r\n      if (exp) {\r\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n          exp\r\n        ])\r\n      }\r\n    } else if (\r\n      isProp.type === NodeTypes.ATTRIBUTE &&\r\n      isProp.value!.content.startsWith('vue:')\r\n    ) {\r\n      // <button is=\"vue:xxx\">\r\n      // if not <component>, only is value that starts with \"vue:\" will be\r\n      // treated as component by the parse phase and reach here, unless it's\r\n      // compat mode where all is values are considered components\r\n      tag = isProp.value!.content.slice(4)\r\n    }\r\n  }\r\n\r\n  // 1.5 v-is (TODO: Deprecate)\r\n  const isDir = !isExplicitDynamic && findDir(node, 'is')\r\n  if (isDir && isDir.exp) {\r\n    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n      isDir.exp\r\n    ])\r\n  }\r\n\r\n  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)\r\n  if (builtIn) {\r\n    // built-ins are simply fallthroughs / have special handling during ssr\r\n    // so we don't need to import their runtime equivalents\r\n    if (!ssr) context.helper(builtIn)\r\n    return builtIn\r\n  }\r\n\r\n  // 3. user component (from setup bindings)\r\n  // this is skipped in browser build since browser builds do not perform\r\n  // binding analysis.\r\n  if (!__BROWSER__) {\r\n    const fromSetup = resolveSetupReference(tag, context)\r\n    if (fromSetup) {\r\n      return fromSetup\r\n    }\r\n    const dotIndex = tag.indexOf('.')\r\n    if (dotIndex > 0) {\r\n      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)\r\n      if (ns) {\r\n        return ns + tag.slice(dotIndex)\r\n      }\r\n    }\r\n  }\r\n\r\n  // 4. Self referencing component (inferred from filename)\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.selfName &&\r\n    capitalize(camelize(tag)) === context.selfName\r\n  ) {\r\n    context.helper(RESOLVE_COMPONENT)\r\n    // codegen.ts has special check for __self postfix when generating\r\n    // component imports, which will pass additional `maybeSelfReference` flag\r\n    // to `resolveComponent`.\r\n    context.components.add(tag + `__self`)\r\n    return toValidAssetId(tag, `component`)\r\n  }\r\n\r\n  // 5. user component (resolve)\r\n  context.helper(RESOLVE_COMPONENT)\r\n  context.components.add(tag)\r\n  return toValidAssetId(tag, `component`)\r\n}\r\n\r\nfunction resolveSetupReference(name: string, context: TransformContext) {\r\n  const bindings = context.bindingMetadata\r\n  if (!bindings || bindings.__isScriptSetup === false) {\r\n    return\r\n  }\r\n\r\n  const camelName = camelize(name)\r\n  const PascalName = capitalize(camelName)\r\n  const checkType = (type: BindingTypes) => {\r\n    if (bindings[name] === type) {\r\n      return name\r\n    }\r\n    if (bindings[camelName] === type) {\r\n      return camelName\r\n    }\r\n    if (bindings[PascalName] === type) {\r\n      return PascalName\r\n    }\r\n  }\r\n\r\n  const fromConst =\r\n    checkType(BindingTypes.SETUP_CONST) ||\r\n    checkType(BindingTypes.SETUP_REACTIVE_CONST)\r\n  if (fromConst) {\r\n    return context.inline\r\n      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is\r\n        fromConst\r\n      : `$setup[${JSON.stringify(fromConst)}]`\r\n  }\r\n\r\n  const fromMaybeRef =\r\n    checkType(BindingTypes.SETUP_LET) ||\r\n    checkType(BindingTypes.SETUP_REF) ||\r\n    checkType(BindingTypes.SETUP_MAYBE_REF)\r\n  if (fromMaybeRef) {\r\n    return context.inline\r\n      ? // setup scope bindings that may be refs need to be unrefed\r\n        `${context.helperString(UNREF)}(${fromMaybeRef})`\r\n      : `$setup[${JSON.stringify(fromMaybeRef)}]`\r\n  }\r\n}\r\n\r\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\r\n\r\nexport function buildProps(\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  props: ElementNode['props'] = node.props,\r\n  isComponent: boolean,\r\n  isDynamicComponent: boolean,\r\n  ssr = false\r\n): {\r\n  props: PropsExpression | undefined\r\n  directives: DirectiveNode[]\r\n  patchFlag: number\r\n  dynamicPropNames: string[]\r\n  shouldUseBlock: boolean\r\n} {\r\n  const { tag, loc: elementLoc, children } = node\r\n  let properties: ObjectExpression['properties'] = []\r\n  const mergeArgs: PropsExpression[] = []\r\n  const runtimeDirectives: DirectiveNode[] = []\r\n  const hasChildren = children.length > 0\r\n  let shouldUseBlock = false\r\n\r\n  // patchFlag analysis\r\n  let patchFlag = 0\r\n  let hasRef = false\r\n  let hasClassBinding = false\r\n  let hasStyleBinding = false\r\n  let hasHydrationEventBinding = false\r\n  let hasDynamicKeys = false\r\n  let hasVnodeHook = false\r\n  const dynamicPropNames: string[] = []\r\n\r\n  const analyzePatchFlag = ({ key, value }: Property) => {\r\n    if (isStaticExp(key)) {\r\n      const name = key.content\r\n      const isEventHandler = isOn(name)\r\n      if (\r\n        isEventHandler &&\r\n        (!isComponent || isDynamicComponent) &&\r\n        // omit the flag for click handlers because hydration gives click\r\n        // dedicated fast path.\r\n        name.toLowerCase() !== 'onclick' &&\r\n        // omit v-model handlers\r\n        name !== 'onUpdate:modelValue' &&\r\n        // omit onVnodeXXX hooks\r\n        !isReservedProp(name)\r\n      ) {\r\n        hasHydrationEventBinding = true\r\n      }\r\n\r\n      if (isEventHandler && isReservedProp(name)) {\r\n        hasVnodeHook = true\r\n      }\r\n\r\n      if (\r\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\r\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\r\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\r\n          getConstantType(value, context) > 0)\r\n      ) {\r\n        // skip if the prop is a cached handler or has constant value\r\n        return\r\n      }\r\n\r\n      if (name === 'ref') {\r\n        hasRef = true\r\n      } else if (name === 'class') {\r\n        hasClassBinding = true\r\n      } else if (name === 'style') {\r\n        hasStyleBinding = true\r\n      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {\r\n        dynamicPropNames.push(name)\r\n      }\r\n\r\n      // treat the dynamic class and style binding of the component as dynamic props\r\n      if (\r\n        isComponent &&\r\n        (name === 'class' || name === 'style') &&\r\n        !dynamicPropNames.includes(name)\r\n      ) {\r\n        dynamicPropNames.push(name)\r\n      }\r\n    } else {\r\n      hasDynamicKeys = true\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < props.length; i++) {\r\n    // static attribute\r\n    const prop = props[i]\r\n    if (prop.type === NodeTypes.ATTRIBUTE) {\r\n      const { loc, name, value } = prop\r\n      let isStatic = true\r\n      if (name === 'ref') {\r\n        hasRef = true\r\n        if (context.scopes.vFor > 0) {\r\n          properties.push(\r\n            createObjectProperty(\r\n              createSimpleExpression('ref_for', true),\r\n              createSimpleExpression('true')\r\n            )\r\n          )\r\n        }\r\n        // in inline mode there is no setupState object, so we can't use string\r\n        // keys to set the ref. Instead, we need to transform it to pass the\r\n        // actual ref instead.\r\n        if (\r\n          !__BROWSER__ &&\r\n          value &&\r\n          context.inline &&\r\n          context.bindingMetadata[value.content]\r\n        ) {\r\n          isStatic = false\r\n          properties.push(\r\n            createObjectProperty(\r\n              createSimpleExpression('ref_key', true),\r\n              createSimpleExpression(value.content, true, value.loc)\r\n            )\r\n          )\r\n        }\r\n      }\r\n      // skip is on <component>, or is=\"vue:xxx\"\r\n      if (\r\n        name === 'is' &&\r\n        (isComponentTag(tag) ||\r\n          (value && value.content.startsWith('vue:')) ||\r\n          (__COMPAT__ &&\r\n            isCompatEnabled(\r\n              CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n              context\r\n            )))\r\n      ) {\r\n        continue\r\n      }\r\n      properties.push(\r\n        createObjectProperty(\r\n          createSimpleExpression(\r\n            name,\r\n            true,\r\n            getInnerRange(loc, 0, name.length)\r\n          ),\r\n          createSimpleExpression(\r\n            value ? value.content : '',\r\n            isStatic,\r\n            value ? value.loc : loc\r\n          )\r\n        )\r\n      )\r\n    } else {\r\n      // directives\r\n      const { name, arg, exp, loc } = prop\r\n      const isVBind = name === 'bind'\r\n      const isVOn = name === 'on'\r\n\r\n      // skip v-slot - it is handled by its dedicated transform.\r\n      if (name === 'slot') {\r\n        if (!isComponent) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc)\r\n          )\r\n        }\r\n        continue\r\n      }\r\n      // skip v-once/v-memo - they are handled by dedicated transforms.\r\n      if (name === 'once' || name === 'memo') {\r\n        continue\r\n      }\r\n      // skip v-is and :is on <component>\r\n      if (\r\n        name === 'is' ||\r\n        (isVBind &&\r\n          isStaticArgOf(arg, 'is') &&\r\n          (isComponentTag(tag) ||\r\n            (__COMPAT__ &&\r\n              isCompatEnabled(\r\n                CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n                context\r\n              ))))\r\n      ) {\r\n        continue\r\n      }\r\n      // skip v-on in SSR compilation\r\n      if (isVOn && ssr) {\r\n        continue\r\n      }\r\n\r\n      if (\r\n        // #938: elements with dynamic keys should be forced into blocks\r\n        (isVBind && isStaticArgOf(arg, 'key')) ||\r\n        // inline before-update hooks need to force block so that it is invoked\r\n        // before children\r\n        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))\r\n      ) {\r\n        shouldUseBlock = true\r\n      }\r\n\r\n      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\r\n        properties.push(\r\n          createObjectProperty(\r\n            createSimpleExpression('ref_for', true),\r\n            createSimpleExpression('true')\r\n          )\r\n        )\r\n      }\r\n\r\n      // special case for v-bind and v-on with no argument\r\n      if (!arg && (isVBind || isVOn)) {\r\n        hasDynamicKeys = true\r\n        if (exp) {\r\n          if (properties.length) {\r\n            mergeArgs.push(\r\n              createObjectExpression(dedupeProperties(properties), elementLoc)\r\n            )\r\n            properties = []\r\n          }\r\n          if (isVBind) {\r\n            if (__COMPAT__) {\r\n              // 2.x v-bind object order compat\r\n              if (__DEV__) {\r\n                const hasOverridableKeys = mergeArgs.some(arg => {\r\n                  if (arg.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n                    return arg.properties.some(({ key }) => {\r\n                      if (\r\n                        key.type !== NodeTypes.SIMPLE_EXPRESSION ||\r\n                        !key.isStatic\r\n                      ) {\r\n                        return true\r\n                      }\r\n                      return (\r\n                        key.content !== 'class' &&\r\n                        key.content !== 'style' &&\r\n                        !isOn(key.content)\r\n                      )\r\n                    })\r\n                  } else {\r\n                    // dynamic expression\r\n                    return true\r\n                  }\r\n                })\r\n                if (hasOverridableKeys) {\r\n                  checkCompatEnabled(\r\n                    CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\r\n                    context,\r\n                    loc\r\n                  )\r\n                }\r\n              }\r\n\r\n              if (\r\n                isCompatEnabled(\r\n                  CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\r\n                  context\r\n                )\r\n              ) {\r\n                mergeArgs.unshift(exp)\r\n                continue\r\n              }\r\n            }\r\n\r\n            mergeArgs.push(exp)\r\n          } else {\r\n            // v-on=\"obj\" -> toHandlers(obj)\r\n            mergeArgs.push({\r\n              type: NodeTypes.JS_CALL_EXPRESSION,\r\n              loc,\r\n              callee: context.helper(TO_HANDLERS),\r\n              arguments: [exp]\r\n            })\r\n          }\r\n        } else {\r\n          context.onError(\r\n            createCompilerError(\r\n              isVBind\r\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\r\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\r\n              loc\r\n            )\r\n          )\r\n        }\r\n        continue\r\n      }\r\n\r\n      const directiveTransform = context.directiveTransforms[name]\r\n      if (directiveTransform) {\r\n        // has built-in directive transform.\r\n        const { props, needRuntime } = directiveTransform(prop, node, context)\r\n        !ssr && props.forEach(analyzePatchFlag)\r\n        properties.push(...props)\r\n        if (needRuntime) {\r\n          runtimeDirectives.push(prop)\r\n          if (isSymbol(needRuntime)) {\r\n            directiveImportMap.set(prop, needRuntime)\r\n          }\r\n        }\r\n      } else if (!isBuiltInDirective(name)) {\r\n        // no built-in transform, this is a user custom directive.\r\n        runtimeDirectives.push(prop)\r\n        // custom dirs may use beforeUpdate so they need to force blocks\r\n        // to ensure before-update gets called before children update\r\n        if (hasChildren) {\r\n          shouldUseBlock = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  let propsExpression: PropsExpression | undefined = undefined\r\n\r\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\r\n  if (mergeArgs.length) {\r\n    if (properties.length) {\r\n      mergeArgs.push(\r\n        createObjectExpression(dedupeProperties(properties), elementLoc)\r\n      )\r\n    }\r\n    if (mergeArgs.length > 1) {\r\n      propsExpression = createCallExpression(\r\n        context.helper(MERGE_PROPS),\r\n        mergeArgs,\r\n        elementLoc\r\n      )\r\n    } else {\r\n      // single v-bind with nothing else - no need for a mergeProps call\r\n      propsExpression = mergeArgs[0]\r\n    }\r\n  } else if (properties.length) {\r\n    propsExpression = createObjectExpression(\r\n      dedupeProperties(properties),\r\n      elementLoc\r\n    )\r\n  }\r\n\r\n  // patchFlag analysis\r\n  if (hasDynamicKeys) {\r\n    patchFlag |= PatchFlags.FULL_PROPS\r\n  } else {\r\n    if (hasClassBinding && !isComponent) {\r\n      patchFlag |= PatchFlags.CLASS\r\n    }\r\n    if (hasStyleBinding && !isComponent) {\r\n      patchFlag |= PatchFlags.STYLE\r\n    }\r\n    if (dynamicPropNames.length) {\r\n      patchFlag |= PatchFlags.PROPS\r\n    }\r\n    if (hasHydrationEventBinding) {\r\n      patchFlag |= PatchFlags.HYDRATE_EVENTS\r\n    }\r\n  }\r\n  if (\r\n    !shouldUseBlock &&\r\n    (patchFlag === 0 || patchFlag === PatchFlags.HYDRATE_EVENTS) &&\r\n    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)\r\n  ) {\r\n    patchFlag |= PatchFlags.NEED_PATCH\r\n  }\r\n\r\n  // pre-normalize props, SSR is skipped for now\r\n  if (!context.inSSR && propsExpression) {\r\n    switch (propsExpression.type) {\r\n      case NodeTypes.JS_OBJECT_EXPRESSION:\r\n        // means that there is no v-bind,\r\n        // but still need to deal with dynamic key binding\r\n        let classKeyIndex = -1\r\n        let styleKeyIndex = -1\r\n        let hasDynamicKey = false\r\n\r\n        for (let i = 0; i < propsExpression.properties.length; i++) {\r\n          const key = propsExpression.properties[i].key\r\n          if (isStaticExp(key)) {\r\n            if (key.content === 'class') {\r\n              classKeyIndex = i\r\n            } else if (key.content === 'style') {\r\n              styleKeyIndex = i\r\n            }\r\n          } else if (!key.isHandlerKey) {\r\n            hasDynamicKey = true\r\n          }\r\n        }\r\n\r\n        const classProp = propsExpression.properties[classKeyIndex]\r\n        const styleProp = propsExpression.properties[styleKeyIndex]\r\n\r\n        // no dynamic key\r\n        if (!hasDynamicKey) {\r\n          if (classProp && !isStaticExp(classProp.value)) {\r\n            classProp.value = createCallExpression(\r\n              context.helper(NORMALIZE_CLASS),\r\n              [classProp.value]\r\n            )\r\n          }\r\n          if (\r\n            styleProp &&\r\n            // the static style is compiled into an object,\r\n            // so use `hasStyleBinding` to ensure that it is a dynamic style binding\r\n            (hasStyleBinding ||\r\n              (styleProp.value.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n                styleProp.value.content.trim()[0] === `[`) ||\r\n              // v-bind:style and style both exist,\r\n              // v-bind:style with static literal object\r\n              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)\r\n          ) {\r\n            styleProp.value = createCallExpression(\r\n              context.helper(NORMALIZE_STYLE),\r\n              [styleProp.value]\r\n            )\r\n          }\r\n        } else {\r\n          // dynamic key binding, wrap with `normalizeProps`\r\n          propsExpression = createCallExpression(\r\n            context.helper(NORMALIZE_PROPS),\r\n            [propsExpression]\r\n          )\r\n        }\r\n        break\r\n      case NodeTypes.JS_CALL_EXPRESSION:\r\n        // mergeProps call, do nothing\r\n        break\r\n      default:\r\n        // single v-bind\r\n        propsExpression = createCallExpression(\r\n          context.helper(NORMALIZE_PROPS),\r\n          [\r\n            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\r\n              propsExpression\r\n            ])\r\n          ]\r\n        )\r\n        break\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: propsExpression,\r\n    directives: runtimeDirectives,\r\n    patchFlag,\r\n    dynamicPropNames,\r\n    shouldUseBlock\r\n  }\r\n}\r\n\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it's possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties: Property[]): Property[] {\r\n  const knownProps: Map<string, Property> = new Map()\r\n  const deduped: Property[] = []\r\n  for (let i = 0; i < properties.length; i++) {\r\n    const prop = properties[i]\r\n    // dynamic keys are always allowed\r\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\r\n      deduped.push(prop)\r\n      continue\r\n    }\r\n    const name = prop.key.content\r\n    const existing = knownProps.get(name)\r\n    if (existing) {\r\n      if (name === 'style' || name === 'class' || isOn(name)) {\r\n        mergeAsArray(existing, prop)\r\n      }\r\n      // unexpected duplicate, should have emitted error during parse\r\n    } else {\r\n      knownProps.set(name, prop)\r\n      deduped.push(prop)\r\n    }\r\n  }\r\n  return deduped\r\n}\r\n\r\nfunction mergeAsArray(existing: Property, incoming: Property) {\r\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\r\n    existing.value.elements.push(incoming.value)\r\n  } else {\r\n    existing.value = createArrayExpression(\r\n      [existing.value, incoming.value],\r\n      existing.loc\r\n    )\r\n  }\r\n}\r\n\r\nexport function buildDirectiveArgs(\r\n  dir: DirectiveNode,\r\n  context: TransformContext\r\n): ArrayExpression {\r\n  const dirArgs: ArrayExpression['elements'] = []\r\n  const runtime = directiveImportMap.get(dir)\r\n  if (runtime) {\r\n    // built-in directive with runtime\r\n    dirArgs.push(context.helperString(runtime))\r\n  } else {\r\n    // user directive.\r\n    // see if we have directives exposed via <script setup>\r\n    const fromSetup =\r\n      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)\r\n    if (fromSetup) {\r\n      dirArgs.push(fromSetup)\r\n    } else {\r\n      // inject statement for resolving directive\r\n      context.helper(RESOLVE_DIRECTIVE)\r\n      context.directives.add(dir.name)\r\n      dirArgs.push(toValidAssetId(dir.name, `directive`))\r\n    }\r\n  }\r\n  const { loc } = dir\r\n  if (dir.exp) dirArgs.push(dir.exp)\r\n  if (dir.arg) {\r\n    if (!dir.exp) {\r\n      dirArgs.push(`void 0`)\r\n    }\r\n    dirArgs.push(dir.arg)\r\n  }\r\n  if (Object.keys(dir.modifiers).length) {\r\n    if (!dir.arg) {\r\n      if (!dir.exp) {\r\n        dirArgs.push(`void 0`)\r\n      }\r\n      dirArgs.push(`void 0`)\r\n    }\r\n    const trueExpression = createSimpleExpression(`true`, false, loc)\r\n    dirArgs.push(\r\n      createObjectExpression(\r\n        dir.modifiers.map(modifier =>\r\n          createObjectProperty(modifier, trueExpression)\r\n        ),\r\n        loc\r\n      )\r\n    )\r\n  }\r\n  return createArrayExpression(dirArgs, dir.loc)\r\n}\r\n\r\nfunction stringifyDynamicPropNames(props: string[]): string {\r\n  let propsNamesString = `[`\r\n  for (let i = 0, l = props.length; i < l; i++) {\r\n    propsNamesString += JSON.stringify(props[i])\r\n    if (i < l - 1) propsNamesString += ', '\r\n  }\r\n  return propsNamesString + `]`\r\n}\r\n\r\nfunction isComponentTag(tag: string) {\r\n  return tag === 'component' || tag === 'Component'\r\n}\r\n","import { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  CallExpression,\r\n  createCallExpression,\r\n  ExpressionNode,\r\n  SlotOutletNode,\r\n  createFunctionExpression\r\n} from '../ast'\r\nimport { isSlotOutlet, isStaticArgOf, isStaticExp } from '../utils'\r\nimport { buildProps, PropsExpression } from './transformElement'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { RENDER_SLOT } from '../runtimeHelpers'\r\nimport { camelize } from '@vue/shared/'\r\n\r\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\r\n  if (isSlotOutlet(node)) {\r\n    const { children, loc } = node\r\n    const { slotName, slotProps } = processSlotOutlet(node, context)\r\n\r\n    const slotArgs: CallExpression['arguments'] = [\r\n      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n      slotName,\r\n      '{}',\r\n      'undefined',\r\n      'true'\r\n    ]\r\n    let expectedLen = 2\r\n\r\n    if (slotProps) {\r\n      slotArgs[2] = slotProps\r\n      expectedLen = 3\r\n    }\r\n\r\n    if (children.length) {\r\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc)\r\n      expectedLen = 4\r\n    }\r\n\r\n    if (context.scopeId && !context.slotted) {\r\n      expectedLen = 5\r\n    }\r\n    slotArgs.splice(expectedLen) // remove unused arguments\r\n\r\n    node.codegenNode = createCallExpression(\r\n      context.helper(RENDER_SLOT),\r\n      slotArgs,\r\n      loc\r\n    )\r\n  }\r\n}\r\n\r\ninterface SlotOutletProcessResult {\r\n  slotName: string | ExpressionNode\r\n  slotProps: PropsExpression | undefined\r\n}\r\n\r\nexport function processSlotOutlet(\r\n  node: SlotOutletNode,\r\n  context: TransformContext\r\n): SlotOutletProcessResult {\r\n  let slotName: string | ExpressionNode = `\"default\"`\r\n  let slotProps: PropsExpression | undefined = undefined\r\n\r\n  const nonNameProps = []\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (p.value) {\r\n        if (p.name === 'name') {\r\n          slotName = JSON.stringify(p.value.content)\r\n        } else {\r\n          p.name = camelize(p.name)\r\n          nonNameProps.push(p)\r\n        }\r\n      }\r\n    } else {\r\n      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\r\n        if (p.exp) slotName = p.exp\r\n      } else {\r\n        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\r\n          p.arg.content = camelize(p.arg.content)\r\n        }\r\n        nonNameProps.push(p)\r\n      }\r\n    }\r\n  }\r\n\r\n  if (nonNameProps.length > 0) {\r\n    const { props, directives } = buildProps(\r\n      node,\r\n      context,\r\n      nonNameProps,\r\n      false,\r\n      false\r\n    )\r\n    slotProps = props\r\n\r\n    if (directives.length) {\r\n      context.onError(\r\n        createCompilerError(\r\n          ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\r\n          directives[0].loc\r\n        )\r\n      )\r\n    }\r\n  }\r\n\r\n  return {\r\n    slotName,\r\n    slotProps\r\n  }\r\n}\r\n","import { DirectiveTransform, DirectiveTransformResult } from '../transform'\r\nimport {\r\n  createCompoundExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  DirectiveNode,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  NodeTypes,\r\n  SimpleExpressionNode\r\n} from '../ast'\r\nimport { camelize, toHandlerKey } from '@vue/shared'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { hasScopeRef, isMemberExpression } from '../utils'\r\nimport { TO_HANDLER_KEY } from '../runtimeHelpers'\r\n\r\nconst fnExpRE =\r\n  /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/\r\n\r\nexport interface VOnDirectiveNode extends DirectiveNode {\r\n  // v-on without arg is handled directly in ./transformElements.ts due to it affecting\r\n  // codegen for the entire props object. This transform here is only for v-on\r\n  // *with* args.\r\n  arg: ExpressionNode\r\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\r\n  // skipped by transformExpression as a special case.\r\n  exp: SimpleExpressionNode | undefined\r\n}\r\n\r\nexport const transformOn: DirectiveTransform = (\r\n  dir,\r\n  node,\r\n  context,\r\n  augmentor\r\n) => {\r\n  const { loc, modifiers, arg } = dir as VOnDirectiveNode\r\n  if (!dir.exp && !modifiers.length) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\r\n  }\r\n  let eventName: ExpressionNode\r\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    if (arg.isStatic) {\r\n      let rawName = arg.content\r\n      // TODO deprecate @vnodeXXX usage\r\n      if (rawName.startsWith('vue:')) {\r\n        rawName = `vnode-${rawName.slice(4)}`\r\n      }\r\n      // for all event listeners, auto convert it to camelCase. See issue #2249\r\n      eventName = createSimpleExpression(\r\n        toHandlerKey(camelize(rawName)),\r\n        true,\r\n        arg.loc\r\n      )\r\n    } else {\r\n      // #2388\r\n      eventName = createCompoundExpression([\r\n        `${context.helperString(TO_HANDLER_KEY)}(`,\r\n        arg,\r\n        `)`\r\n      ])\r\n    }\r\n  } else {\r\n    // already a compound expression.\r\n    eventName = arg\r\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)\r\n    eventName.children.push(`)`)\r\n  }\r\n\r\n  // handler processing\r\n  let exp: ExpressionNode | undefined = dir.exp as\r\n    | SimpleExpressionNode\r\n    | undefined\r\n  if (exp && !exp.content.trim()) {\r\n    exp = undefined\r\n  }\r\n  let shouldCache: boolean = context.cacheHandlers && !exp && !context.inVOnce\r\n  if (exp) {\r\n    const isMemberExp = isMemberExpression(exp.content, context)\r\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\r\n    const hasMultipleStatements = exp.content.includes(`;`)\r\n\r\n    // process the expression since it's been skipped\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      isInlineStatement && context.addIdentifiers(`$event`)\r\n      exp = dir.exp = processExpression(\r\n        exp,\r\n        context,\r\n        false,\r\n        hasMultipleStatements\r\n      )\r\n      isInlineStatement && context.removeIdentifiers(`$event`)\r\n      // with scope analysis, the function is hoistable if it has no reference\r\n      // to scope variables.\r\n      shouldCache =\r\n        context.cacheHandlers &&\r\n        // unnecessary to cache inside v-once\r\n        !context.inVOnce &&\r\n        // runtime constants don't need to be cached\r\n        // (this is analyzed by compileScript in SFC <script setup>)\r\n        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&\r\n        // #1541 bail if this is a member exp handler passed to a component -\r\n        // we need to use the original function to preserve arity,\r\n        // e.g. <transition> relies on checking cb.length to determine\r\n        // transition end handling. Inline function is ok since its arity\r\n        // is preserved even when cached.\r\n        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&\r\n        // bail if the function references closure variables (v-for, v-slot)\r\n        // it must be passed fresh to avoid stale values.\r\n        !hasScopeRef(exp, context.identifiers)\r\n      // If the expression is optimizable and is a member expression pointing\r\n      // to a function, turn it into invocation (and wrap in an arrow function\r\n      // below) so that it always accesses the latest value when called - thus\r\n      // avoiding the need to be patched.\r\n      if (shouldCache && isMemberExp) {\r\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          exp.content = `${exp.content} && ${exp.content}(...args)`\r\n        } else {\r\n          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]\r\n        }\r\n      }\r\n    }\r\n\r\n    if (__DEV__ && __BROWSER__) {\r\n      validateBrowserExpression(\r\n        exp as SimpleExpressionNode,\r\n        context,\r\n        false,\r\n        hasMultipleStatements\r\n      )\r\n    }\r\n\r\n    if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n      // wrap inline statement in a function expression\r\n      exp = createCompoundExpression([\r\n        `${\r\n          isInlineStatement\r\n            ? !__BROWSER__ && context.isTS\r\n              ? `($event: any)`\r\n              : `$event`\r\n            : `${\r\n                !__BROWSER__ && context.isTS ? `\\n//@ts-ignore\\n` : ``\r\n              }(...args)`\r\n        } => ${hasMultipleStatements ? `{` : `(`}`,\r\n        exp,\r\n        hasMultipleStatements ? `}` : `)`\r\n      ])\r\n    }\r\n  }\r\n\r\n  let ret: DirectiveTransformResult = {\r\n    props: [\r\n      createObjectProperty(\r\n        eventName,\r\n        exp || createSimpleExpression(`() => {}`, false, loc)\r\n      )\r\n    ]\r\n  }\r\n\r\n  // apply extended compiler augmentor\r\n  if (augmentor) {\r\n    ret = augmentor(ret)\r\n  }\r\n\r\n  if (shouldCache) {\r\n    // cache handlers so that it's always the same handler being passed down.\r\n    // this avoids unnecessary re-renders when users use inline handlers on\r\n    // components.\r\n    ret.props[0].value = context.cache(ret.props[0].value)\r\n  }\r\n\r\n  // mark the key as handler for props normalization check\r\n  ret.props.forEach(p => (p.key.isHandlerKey = true))\r\n  return ret\r\n}\r\n","import { DirectiveTransform } from '../transform'\r\nimport {\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  ExpressionNode,\r\n  NodeTypes\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { camelize } from '@vue/shared'\r\nimport { CAMELIZE } from '../runtimeHelpers'\r\n\r\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n// codegen for the entire props object. This transform here is only for v-bind\r\n// *with* args.\r\nexport const transformBind: DirectiveTransform = (dir, _node, context) => {\r\n  const { exp, modifiers, loc } = dir\r\n  const arg = dir.arg!\r\n\r\n  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {\r\n    arg.children.unshift(`(`)\r\n    arg.children.push(`) || \"\"`)\r\n  } else if (!arg.isStatic) {\r\n    arg.content = `${arg.content} || \"\"`\r\n  }\r\n\r\n  // .sync is replaced by v-model:arg\r\n  if (modifiers.includes('camel')) {\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      if (arg.isStatic) {\r\n        arg.content = camelize(arg.content)\r\n      } else {\r\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\r\n      }\r\n    } else {\r\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\r\n      arg.children.push(`)`)\r\n    }\r\n  }\r\n\r\n  if (!context.inSSR) {\r\n    if (modifiers.includes('prop')) {\r\n      injectPrefix(arg, '.')\r\n    }\r\n    if (modifiers.includes('attr')) {\r\n      injectPrefix(arg, '^')\r\n    }\r\n  }\r\n\r\n  if (\r\n    !exp ||\r\n    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())\r\n  ) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\r\n    return {\r\n      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: [createObjectProperty(arg, exp)]\r\n  }\r\n}\r\n\r\nconst injectPrefix = (arg: ExpressionNode, prefix: string) => {\r\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    if (arg.isStatic) {\r\n      arg.content = prefix + arg.content\r\n    } else {\r\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``\r\n    }\r\n  } else {\r\n    arg.children.unshift(`'${prefix}' + (`)\r\n    arg.children.push(`)`)\r\n  }\r\n}\r\n","import { NodeTransform } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  CompoundExpressionNode,\r\n  createCallExpression,\r\n  CallExpression,\r\n  ElementTypes,\r\n  ConstantTypes,\r\n  createCompoundExpression\r\n} from '../ast'\r\nimport { isText } from '../utils'\r\nimport { CREATE_TEXT } from '../runtimeHelpers'\r\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\r\nimport { getConstantType } from './hoistStatic'\r\n\r\n// Merge adjacent text nodes and expressions into a single expression\r\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\nexport const transformText: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ROOT ||\r\n    node.type === NodeTypes.ELEMENT ||\r\n    node.type === NodeTypes.FOR ||\r\n    node.type === NodeTypes.IF_BRANCH\r\n  ) {\r\n    // perform the transform on node exit so that all expressions have already\r\n    // been processed.\r\n    return () => {\r\n      const children = node.children\r\n      let currentContainer: CompoundExpressionNode | undefined = undefined\r\n      let hasText = false\r\n\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i]\r\n        if (isText(child)) {\r\n          hasText = true\r\n          for (let j = i + 1; j < children.length; j++) {\r\n            const next = children[j]\r\n            if (isText(next)) {\r\n              if (!currentContainer) {\r\n                currentContainer = children[i] = createCompoundExpression(\r\n                  [child],\r\n                  child.loc\r\n                )\r\n              }\r\n              // merge adjacent text node into current\r\n              currentContainer.children.push(` + `, next)\r\n              children.splice(j, 1)\r\n              j--\r\n            } else {\r\n              currentContainer = undefined\r\n              break\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (\r\n        !hasText ||\r\n        // if this is a plain element with a single text child, leave it\r\n        // as-is since the runtime has dedicated fast path for this by directly\r\n        // setting textContent of the element.\r\n        // for component root it's always normalized anyway.\r\n        (children.length === 1 &&\r\n          (node.type === NodeTypes.ROOT ||\r\n            (node.type === NodeTypes.ELEMENT &&\r\n              node.tagType === ElementTypes.ELEMENT &&\r\n              // #3756\r\n              // custom directives can potentially add DOM elements arbitrarily,\r\n              // we need to avoid setting textContent of the element at runtime\r\n              // to avoid accidentally overwriting the DOM elements added\r\n              // by the user through custom directives.\r\n              !node.props.find(\r\n                p =>\r\n                  p.type === NodeTypes.DIRECTIVE &&\r\n                  !context.directiveTransforms[p.name]\r\n              ) &&\r\n              // in compat mode, <template> tags with no special directives\r\n              // will be rendered as a fragment so its children must be\r\n              // converted into vnodes.\r\n              !(__COMPAT__ && node.tag === 'template'))))\r\n      ) {\r\n        return\r\n      }\r\n\r\n      // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n      // runtime normalization.\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i]\r\n        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n          const callArgs: CallExpression['arguments'] = []\r\n          // createTextVNode defaults to single whitespace, so if it is a\r\n          // single space the code could be an empty call to save bytes.\r\n          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {\r\n            callArgs.push(child)\r\n          }\r\n          // mark dynamic text with flag so it gets patched inside a block\r\n          if (\r\n            !context.ssr &&\r\n            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\r\n          ) {\r\n            callArgs.push(\r\n              PatchFlags.TEXT +\r\n                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``)\r\n            )\r\n          }\r\n          children[i] = {\r\n            type: NodeTypes.TEXT_CALL,\r\n            content: child,\r\n            loc: child.loc,\r\n            codegenNode: createCallExpression(\r\n              context.helper(CREATE_TEXT),\r\n              callArgs\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { NodeTransform } from '../transform'\r\nimport { findDir } from '../utils'\r\nimport { ElementNode, ForNode, IfNode, NodeTypes } from '../ast'\r\nimport { SET_BLOCK_TRACKING } from '../runtimeHelpers'\r\n\r\nconst seen = new WeakSet()\r\n\r\nexport const transformOnce: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {\r\n    if (seen.has(node) || context.inVOnce) {\r\n      return\r\n    }\r\n    seen.add(node)\r\n    context.inVOnce = true\r\n    context.helper(SET_BLOCK_TRACKING)\r\n    return () => {\r\n      context.inVOnce = false\r\n      const cur = context.currentNode as ElementNode | IfNode | ForNode\r\n      if (cur.codegenNode) {\r\n        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { DirectiveTransform } from '../transform'\r\nimport {\r\n  createSimpleExpression,\r\n  createObjectProperty,\r\n  createCompoundExpression,\r\n  NodeTypes,\r\n  Property,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  ConstantTypes\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  isMemberExpression,\r\n  isSimpleIdentifier,\r\n  hasScopeRef,\r\n  isStaticExp\r\n} from '../utils'\r\nimport { IS_REF } from '../runtimeHelpers'\r\nimport { BindingTypes } from '../options'\r\n\r\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, arg } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc)\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  const rawExp = exp.loc.source\r\n  const expString =\r\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp\r\n\r\n  // im SFC <script setup> inline mode, the exp may have been transformed into\r\n  // _unref(exp)\r\n  const bindingType = context.bindingMetadata[rawExp]\r\n  const maybeRef =\r\n    !__BROWSER__ &&\r\n    context.inline &&\r\n    bindingType &&\r\n    bindingType !== BindingTypes.SETUP_CONST\r\n\r\n  if (\r\n    !expString.trim() ||\r\n    (!isMemberExpression(expString, context) && !maybeRef)\r\n  ) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc)\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.prefixIdentifiers &&\r\n    isSimpleIdentifier(expString) &&\r\n    context.identifiers[expString]\r\n  ) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc)\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\r\n  const eventName = arg\r\n    ? isStaticExp(arg)\r\n      ? `onUpdate:${arg.content}`\r\n      : createCompoundExpression(['\"onUpdate:\" + ', arg])\r\n    : `onUpdate:modelValue`\r\n\r\n  let assignmentExp: ExpressionNode\r\n  const eventArg = context.isTS ? `($event: any)` : `$event`\r\n  if (maybeRef) {\r\n    if (bindingType === BindingTypes.SETUP_REF) {\r\n      // v-model used on known ref.\r\n      assignmentExp = createCompoundExpression([\r\n        `${eventArg} => ((`,\r\n        createSimpleExpression(rawExp, false, exp.loc),\r\n        `).value = $event)`\r\n      ])\r\n    } else {\r\n      // v-model used on a potentially ref binding in <script setup> inline mode.\r\n      // the assignment needs to check whether the binding is actually a ref.\r\n      const altAssignment =\r\n        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`\r\n      assignmentExp = createCompoundExpression([\r\n        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,\r\n        createSimpleExpression(rawExp, false, exp.loc),\r\n        `).value = $event : ${altAssignment})`\r\n      ])\r\n    }\r\n  } else {\r\n    assignmentExp = createCompoundExpression([\r\n      `${eventArg} => ((`,\r\n      exp,\r\n      `) = $event)`\r\n    ])\r\n  }\r\n\r\n  const props = [\r\n    // modelValue: foo\r\n    createObjectProperty(propName, dir.exp!),\r\n    // \"onUpdate:modelValue\": $event => (foo = $event)\r\n    createObjectProperty(eventName, assignmentExp)\r\n  ]\r\n\r\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.prefixIdentifiers &&\r\n    !context.inVOnce &&\r\n    context.cacheHandlers &&\r\n    !hasScopeRef(exp, context.identifiers)\r\n  ) {\r\n    props[1].value = context.cache(props[1].value)\r\n  }\r\n\r\n  // modelModifiers: { foo: true, \"bar-baz\": true }\r\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\r\n    const modifiers = dir.modifiers\r\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n      .join(`, `)\r\n    const modifiersKey = arg\r\n      ? isStaticExp(arg)\r\n        ? `${arg.content}Modifiers`\r\n        : createCompoundExpression([arg, ' + \"Modifiers\"'])\r\n      : `modelModifiers`\r\n    props.push(\r\n      createObjectProperty(\r\n        modifiersKey,\r\n        createSimpleExpression(\r\n          `{ ${modifiers} }`,\r\n          false,\r\n          dir.loc,\r\n          ConstantTypes.CAN_HOIST\r\n        )\r\n      )\r\n    )\r\n  }\r\n\r\n  return createTransformProps(props)\r\n}\r\n\r\nfunction createTransformProps(props: Property[] = []) {\r\n  return { props }\r\n}\r\n","import { RESOLVE_FILTER } from '../runtimeHelpers'\r\nimport {\r\n  AttributeNode,\r\n  DirectiveNode,\r\n  NodeTransform,\r\n  NodeTypes,\r\n  SimpleExpressionNode,\r\n  toValidAssetId,\r\n  TransformContext\r\n} from '@vue/compiler-core'\r\nimport {\r\n  CompilerDeprecationTypes,\r\n  isCompatEnabled,\r\n  warnDeprecation\r\n} from './compatConfig'\r\nimport { ExpressionNode } from '../ast'\r\n\r\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/\r\n\r\nexport const transformFilter: NodeTransform = (node, context) => {\r\n  if (!isCompatEnabled(CompilerDeprecationTypes.COMPILER_FILTERS, context)) {\r\n    return\r\n  }\r\n\r\n  if (node.type === NodeTypes.INTERPOLATION) {\r\n    // filter rewrite is applied before expression transform so only\r\n    // simple expressions are possible at this stage\r\n    rewriteFilter(node.content, context)\r\n  }\r\n\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    node.props.forEach((prop: AttributeNode | DirectiveNode) => {\r\n      if (\r\n        prop.type === NodeTypes.DIRECTIVE &&\r\n        prop.name !== 'for' &&\r\n        prop.exp\r\n      ) {\r\n        rewriteFilter(prop.exp, context)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction rewriteFilter(node: ExpressionNode, context: TransformContext) {\r\n  if (node.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    parseFilter(node, context)\r\n  } else {\r\n    for (let i = 0; i < node.children.length; i++) {\r\n      const child = node.children[i]\r\n      if (typeof child !== 'object') continue\r\n      if (child.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n        parseFilter(child, context)\r\n      } else if (child.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n        rewriteFilter(node, context)\r\n      } else if (child.type === NodeTypes.INTERPOLATION) {\r\n        rewriteFilter(child.content, context)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction parseFilter(node: SimpleExpressionNode, context: TransformContext) {\r\n  const exp = node.content\r\n  let inSingle = false\r\n  let inDouble = false\r\n  let inTemplateString = false\r\n  let inRegex = false\r\n  let curly = 0\r\n  let square = 0\r\n  let paren = 0\r\n  let lastFilterIndex = 0\r\n  let c,\r\n    prev,\r\n    i: number,\r\n    expression,\r\n    filters: string[] = []\r\n\r\n  for (i = 0; i < exp.length; i++) {\r\n    prev = c\r\n    c = exp.charCodeAt(i)\r\n    if (inSingle) {\r\n      if (c === 0x27 && prev !== 0x5c) inSingle = false\r\n    } else if (inDouble) {\r\n      if (c === 0x22 && prev !== 0x5c) inDouble = false\r\n    } else if (inTemplateString) {\r\n      if (c === 0x60 && prev !== 0x5c) inTemplateString = false\r\n    } else if (inRegex) {\r\n      if (c === 0x2f && prev !== 0x5c) inRegex = false\r\n    } else if (\r\n      c === 0x7c && // pipe\r\n      exp.charCodeAt(i + 1) !== 0x7c &&\r\n      exp.charCodeAt(i - 1) !== 0x7c &&\r\n      !curly &&\r\n      !square &&\r\n      !paren\r\n    ) {\r\n      if (expression === undefined) {\r\n        // first filter, end of expression\r\n        lastFilterIndex = i + 1\r\n        expression = exp.slice(0, i).trim()\r\n      } else {\r\n        pushFilter()\r\n      }\r\n    } else {\r\n      switch (c) {\r\n        case 0x22:\r\n          inDouble = true\r\n          break // \"\r\n        case 0x27:\r\n          inSingle = true\r\n          break // '\r\n        case 0x60:\r\n          inTemplateString = true\r\n          break // `\r\n        case 0x28:\r\n          paren++\r\n          break // (\r\n        case 0x29:\r\n          paren--\r\n          break // )\r\n        case 0x5b:\r\n          square++\r\n          break // [\r\n        case 0x5d:\r\n          square--\r\n          break // ]\r\n        case 0x7b:\r\n          curly++\r\n          break // {\r\n        case 0x7d:\r\n          curly--\r\n          break // }\r\n      }\r\n      if (c === 0x2f) {\r\n        // /\r\n        let j = i - 1\r\n        let p\r\n        // find first non-whitespace prev char\r\n        for (; j >= 0; j--) {\r\n          p = exp.charAt(j)\r\n          if (p !== ' ') break\r\n        }\r\n        if (!p || !validDivisionCharRE.test(p)) {\r\n          inRegex = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (expression === undefined) {\r\n    expression = exp.slice(0, i).trim()\r\n  } else if (lastFilterIndex !== 0) {\r\n    pushFilter()\r\n  }\r\n\r\n  function pushFilter() {\r\n    filters.push(exp.slice(lastFilterIndex, i).trim())\r\n    lastFilterIndex = i + 1\r\n  }\r\n\r\n  if (filters.length) {\r\n    __DEV__ &&\r\n      warnDeprecation(\r\n        CompilerDeprecationTypes.COMPILER_FILTERS,\r\n        context,\r\n        node.loc\r\n      )\r\n    for (i = 0; i < filters.length; i++) {\r\n      expression = wrapFilter(expression, filters[i], context)\r\n    }\r\n    node.content = expression\r\n  }\r\n}\r\n\r\nfunction wrapFilter(\r\n  exp: string,\r\n  filter: string,\r\n  context: TransformContext\r\n): string {\r\n  context.helper(RESOLVE_FILTER)\r\n  const i = filter.indexOf('(')\r\n  if (i < 0) {\r\n    context.filters!.add(filter)\r\n    return `${toValidAssetId(filter, 'filter')}(${exp})`\r\n  } else {\r\n    const name = filter.slice(0, i)\r\n    const args = filter.slice(i + 1)\r\n    context.filters!.add(name)\r\n    return `${toValidAssetId(name, 'filter')}(${exp}${\r\n      args !== ')' ? ',' + args : args\r\n    }`\r\n  }\r\n}\r\n","import { NodeTransform } from '../transform'\r\nimport { findDir, makeBlock } from '../utils'\r\nimport {\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  ElementTypes,\r\n  MemoExpression,\r\n  NodeTypes,\r\n  PlainElementNode\r\n} from '../ast'\r\nimport { WITH_MEMO } from '../runtimeHelpers'\r\n\r\nconst seen = new WeakSet()\r\n\r\nexport const transformMemo: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    const dir = findDir(node, 'memo')\r\n    if (!dir || seen.has(node)) {\r\n      return\r\n    }\r\n    seen.add(node)\r\n    return () => {\r\n      const codegenNode =\r\n        node.codegenNode ||\r\n        (context.currentNode as PlainElementNode).codegenNode\r\n      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {\r\n        // non-component sub tree should be turned into a block\r\n        if (node.tagType !== ElementTypes.COMPONENT) {\r\n          makeBlock(codegenNode, context)\r\n        }\r\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\r\n          dir.exp!,\r\n          createFunctionExpression(undefined, codegenNode),\r\n          `_cache`,\r\n          String(context.cached++)\r\n        ]) as MemoExpression\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { CompilerOptions } from './options'\r\nimport { baseParse } from './parse'\r\nimport { transform, NodeTransform, DirectiveTransform } from './transform'\r\nimport { generate, CodegenResult } from './codegen'\r\nimport { RootNode } from './ast'\r\nimport { isString, extend } from '@vue/shared'\r\nimport { transformIf } from './transforms/vIf'\r\nimport { transformFor } from './transforms/vFor'\r\nimport { transformExpression } from './transforms/transformExpression'\r\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\r\nimport { transformElement } from './transforms/transformElement'\r\nimport { transformOn } from './transforms/vOn'\r\nimport { transformBind } from './transforms/vBind'\r\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\r\nimport { transformText } from './transforms/transformText'\r\nimport { transformOnce } from './transforms/vOnce'\r\nimport { transformModel } from './transforms/vModel'\r\nimport { transformFilter } from './compat/transformFilter'\r\nimport { defaultOnError, createCompilerError, ErrorCodes } from './errors'\r\nimport { transformMemo } from './transforms/vMemo'\r\n\r\nexport type TransformPreset = [\r\n  NodeTransform[],\r\n  Record<string, DirectiveTransform>\r\n]\r\n\r\nexport function getBaseTransformPreset(\r\n  prefixIdentifiers?: boolean\r\n): TransformPreset {\r\n  return [\r\n    [\r\n      transformOnce,\r\n      transformIf,\r\n      transformMemo,\r\n      transformFor,\r\n      ...(__COMPAT__ ? [transformFilter] : []),\r\n      ...(!__BROWSER__ && prefixIdentifiers\r\n        ? [\r\n            // order is important\r\n            trackVForSlotScopes,\r\n            transformExpression\r\n          ]\r\n        : __BROWSER__ && __DEV__\r\n        ? [transformExpression]\r\n        : []),\r\n      transformSlotOutlet,\r\n      transformElement,\r\n      trackSlotScopes,\r\n      transformText\r\n    ],\r\n    {\r\n      on: transformOn,\r\n      bind: transformBind,\r\n      model: transformModel\r\n    }\r\n  ]\r\n}\r\n\r\n// we name it `baseCompile` so that higher order compilers like\r\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\r\nexport function baseCompile(\r\n  template: string | RootNode,\r\n  options: CompilerOptions = {}\r\n): CodegenResult {\r\n  const onError = options.onError || defaultOnError\r\n  const isModuleMode = options.mode === 'module'\r\n  /* istanbul ignore if */\r\n  if (__BROWSER__) {\r\n    if (options.prefixIdentifiers === true) {\r\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\r\n    } else if (isModuleMode) {\r\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\r\n    }\r\n  }\r\n\r\n  const prefixIdentifiers =\r\n    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)\r\n  if (!prefixIdentifiers && options.cacheHandlers) {\r\n    onError(createCompilerError(ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED))\r\n  }\r\n  if (options.scopeId && !isModuleMode) {\r\n    onError(createCompilerError(ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED))\r\n  }\r\n\r\n  const ast = isString(template) ? baseParse(template, options) : template\r\n  const [nodeTransforms, directiveTransforms] =\r\n    getBaseTransformPreset(prefixIdentifiers)\r\n\r\n  if (!__BROWSER__ && options.isTS) {\r\n    const { expressionPlugins } = options\r\n    if (!expressionPlugins || !expressionPlugins.includes('typescript')) {\r\n      options.expressionPlugins = [...(expressionPlugins || []), 'typescript']\r\n    }\r\n  }\r\n\r\n  transform(\r\n    ast,\r\n    extend({}, options, {\r\n      prefixIdentifiers,\r\n      nodeTransforms: [\r\n        ...nodeTransforms,\r\n        ...(options.nodeTransforms || []) // user transforms\r\n      ],\r\n      directiveTransforms: extend(\r\n        {},\r\n        directiveTransforms,\r\n        options.directiveTransforms || {} // user transforms\r\n      )\r\n    })\r\n  )\r\n\r\n  return generate(\r\n    ast,\r\n    extend({}, options, {\r\n      prefixIdentifiers\r\n    })\r\n  )\r\n}\r\n","import { DirectiveTransform } from '../transform'\r\n\r\nexport const noopDirectiveTransform: DirectiveTransform = () => ({ props: [] })\r\n","import { registerRuntimeHelpers } from '@vue/compiler-core'\r\n\r\nexport const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)\r\nexport const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)\r\nexport const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)\r\nexport const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)\r\nexport const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)\r\n\r\nexport const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)\r\nexport const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)\r\n\r\nexport const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)\r\n\r\nexport const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)\r\nexport const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)\r\n\r\nregisterRuntimeHelpers({\r\n  [V_MODEL_RADIO]: `vModelRadio`,\r\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n  [V_MODEL_TEXT]: `vModelText`,\r\n  [V_MODEL_SELECT]: `vModelSelect`,\r\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n  [V_ON_WITH_KEYS]: `withKeys`,\r\n  [V_SHOW]: `vShow`,\r\n  [TRANSITION]: `Transition`,\r\n  [TRANSITION_GROUP]: `TransitionGroup`\r\n})\r\n","/* eslint-disable no-restricted-globals */\r\n\r\nlet decoder: HTMLDivElement\r\n\r\nexport function decodeHtmlBrowser(raw: string, asAttr = false): string {\r\n  if (!decoder) {\r\n    decoder = document.createElement('div')\r\n  }\r\n  if (asAttr) {\r\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`\r\n    return decoder.children[0].getAttribute('foo') as string\r\n  } else {\r\n    decoder.innerHTML = raw\r\n    return decoder.textContent as string\r\n  }\r\n}\r\n","import {\r\n  TextModes,\r\n  ParserOptions,\r\n  ElementNode,\r\n  Namespaces,\r\n  NodeTypes,\r\n  isBuiltInType\r\n} from '@vue/compiler-core'\r\nimport { makeMap, isVoidTag, isHTMLTag, isSVGTag } from '@vue/shared'\r\nimport { TRANSITION, TRANSITION_GROUP } from './runtimeHelpers'\r\nimport { decodeHtml } from './decodeHtml'\r\nimport { decodeHtmlBrowser } from './decodeHtmlBrowser'\r\n\r\nconst isRawTextContainer = /*#__PURE__*/ makeMap(\r\n  'style,iframe,script,noscript',\r\n  true\r\n)\r\n\r\nexport const enum DOMNamespaces {\r\n  HTML = Namespaces.HTML,\r\n  SVG,\r\n  MATH_ML\r\n}\r\n\r\nexport const parserOptions: ParserOptions = {\r\n  isVoidTag,\r\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\r\n  isPreTag: tag => tag === 'pre',\r\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,\r\n\r\n  isBuiltInComponent: (tag: string): symbol | undefined => {\r\n    if (isBuiltInType(tag, `Transition`)) {\r\n      return TRANSITION\r\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\r\n      return TRANSITION_GROUP\r\n    }\r\n  },\r\n\r\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n  getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {\r\n    let ns = parent ? parent.ns : DOMNamespaces.HTML\r\n\r\n    if (parent && ns === DOMNamespaces.MATH_ML) {\r\n      if (parent.tag === 'annotation-xml') {\r\n        if (tag === 'svg') {\r\n          return DOMNamespaces.SVG\r\n        }\r\n        if (\r\n          parent.props.some(\r\n            a =>\r\n              a.type === NodeTypes.ATTRIBUTE &&\r\n              a.name === 'encoding' &&\r\n              a.value != null &&\r\n              (a.value.content === 'text/html' ||\r\n                a.value.content === 'application/xhtml+xml')\r\n          )\r\n        ) {\r\n          ns = DOMNamespaces.HTML\r\n        }\r\n      } else if (\r\n        /^m(?:[ions]|text)$/.test(parent.tag) &&\r\n        tag !== 'mglyph' &&\r\n        tag !== 'malignmark'\r\n      ) {\r\n        ns = DOMNamespaces.HTML\r\n      }\r\n    } else if (parent && ns === DOMNamespaces.SVG) {\r\n      if (\r\n        parent.tag === 'foreignObject' ||\r\n        parent.tag === 'desc' ||\r\n        parent.tag === 'title'\r\n      ) {\r\n        ns = DOMNamespaces.HTML\r\n      }\r\n    }\r\n\r\n    if (ns === DOMNamespaces.HTML) {\r\n      if (tag === 'svg') {\r\n        return DOMNamespaces.SVG\r\n      }\r\n      if (tag === 'math') {\r\n        return DOMNamespaces.MATH_ML\r\n      }\r\n    }\r\n    return ns\r\n  },\r\n\r\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\r\n  getTextMode({ tag, ns }: ElementNode): TextModes {\r\n    if (ns === DOMNamespaces.HTML) {\r\n      if (tag === 'textarea' || tag === 'title') {\r\n        return TextModes.RCDATA\r\n      }\r\n      if (isRawTextContainer(tag)) {\r\n        return TextModes.RAWTEXT\r\n      }\r\n    }\r\n    return TextModes.DATA\r\n  }\r\n}\r\n","import {\r\n  NodeTransform,\r\n  NodeTypes,\r\n  createSimpleExpression,\r\n  SimpleExpressionNode,\r\n  SourceLocation,\r\n  ConstantTypes\r\n} from '@vue/compiler-core'\r\nimport { parseStringStyle } from '@vue/shared'\r\n\r\n// Parse inline CSS strings for static style attributes into an object.\r\n// This is a NodeTransform since it works on the static `style` attribute and\r\n// converts it into a dynamic equivalent:\r\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\r\n// It is then processed by `transformElement` and included in the generated\r\n// props.\r\nexport const transformStyle: NodeTransform = node => {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    node.props.forEach((p, i) => {\r\n      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {\r\n        // replace p with an expression node\r\n        node.props[i] = {\r\n          type: NodeTypes.DIRECTIVE,\r\n          name: `bind`,\r\n          arg: createSimpleExpression(`style`, true, p.loc),\r\n          exp: parseInlineCSS(p.value.content, p.loc),\r\n          modifiers: [],\r\n          loc: p.loc\r\n        }\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nconst parseInlineCSS = (\r\n  cssText: string,\r\n  loc: SourceLocation\r\n): SimpleExpressionNode => {\r\n  const normalized = parseStringStyle(cssText)\r\n  return createSimpleExpression(\r\n    JSON.stringify(normalized),\r\n    false,\r\n    loc,\r\n    ConstantTypes.CAN_STRINGIFY\r\n  )\r\n}\r\n","import {\r\n  SourceLocation,\r\n  CompilerError,\r\n  createCompilerError,\r\n  ErrorCodes\r\n} from '@vue/compiler-core'\r\n\r\nexport interface DOMCompilerError extends CompilerError {\r\n  code: DOMErrorCodes\r\n}\r\n\r\nexport function createDOMCompilerError(\r\n  code: DOMErrorCodes,\r\n  loc?: SourceLocation\r\n) {\r\n  return createCompilerError(\r\n    code,\r\n    loc,\r\n    __DEV__ || !__BROWSER__ ? DOMErrorMessages : undefined\r\n  ) as DOMCompilerError\r\n}\r\n\r\nexport const enum DOMErrorCodes {\r\n  X_V_HTML_NO_EXPRESSION = ErrorCodes.__EXTEND_POINT__,\r\n  X_V_HTML_WITH_CHILDREN,\r\n  X_V_TEXT_NO_EXPRESSION,\r\n  X_V_TEXT_WITH_CHILDREN,\r\n  X_V_MODEL_ON_INVALID_ELEMENT,\r\n  X_V_MODEL_ARG_ON_ELEMENT,\r\n  X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n  X_V_MODEL_UNNECESSARY_VALUE,\r\n  X_V_SHOW_NO_EXPRESSION,\r\n  X_TRANSITION_INVALID_CHILDREN,\r\n  X_IGNORED_SIDE_EFFECT_TAG,\r\n  __EXTEND_POINT__\r\n}\r\n\r\nexport const DOMErrorMessages: { [code: number]: string } = {\r\n  [DOMErrorCodes.X_V_HTML_NO_EXPRESSION]: `v-html is missing expression.`,\r\n  [DOMErrorCodes.X_V_HTML_WITH_CHILDREN]: `v-html will override element children.`,\r\n  [DOMErrorCodes.X_V_TEXT_NO_EXPRESSION]: `v-text is missing expression.`,\r\n  [DOMErrorCodes.X_V_TEXT_WITH_CHILDREN]: `v-text will override element children.`,\r\n  [DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n  [DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT]: `v-model argument is not supported on plain elements.`,\r\n  [DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n  [DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\r\n  [DOMErrorCodes.X_V_SHOW_NO_EXPRESSION]: `v-show is missing expression.`,\r\n  [DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN]: `<Transition> expects exactly one child element or component.`,\r\n  [DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\r\n}\r\n","import {\r\n  DirectiveTransform,\r\n  createObjectProperty,\r\n  createSimpleExpression\r\n} from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\n\r\nexport const transformVHtml: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc)\r\n    )\r\n  }\r\n  if (node.children.length) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc)\r\n    )\r\n    node.children.length = 0\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        createSimpleExpression(`innerHTML`, true, loc),\r\n        exp || createSimpleExpression('', true)\r\n      )\r\n    ]\r\n  }\r\n}\r\n","import {\r\n  transformOn as baseTransform,\r\n  DirectiveTransform,\r\n  createObjectProperty,\r\n  createCallExpression,\r\n  createSimpleExpression,\r\n  NodeTypes,\r\n  createCompoundExpression,\r\n  ExpressionNode,\r\n  SimpleExpressionNode,\r\n  isStaticExp,\r\n  CompilerDeprecationTypes,\r\n  TransformContext,\r\n  SourceLocation,\r\n  checkCompatEnabled\r\n} from '@vue/compiler-core'\r\nimport { V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS } from '../runtimeHelpers'\r\nimport { makeMap, capitalize } from '@vue/shared'\r\n\r\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)\r\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\r\n  // event propagation management\r\n  `stop,prevent,self,` +\r\n    // system modifiers + exact\r\n    `ctrl,shift,alt,meta,exact,` +\r\n    // mouse\r\n    `middle`\r\n)\r\n// left & right could be mouse or key modifiers based on event type\r\nconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')\r\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(\r\n  `onkeyup,onkeydown,onkeypress`,\r\n  true\r\n)\r\n\r\nconst resolveModifiers = (\r\n  key: ExpressionNode,\r\n  modifiers: string[],\r\n  context: TransformContext,\r\n  loc: SourceLocation\r\n) => {\r\n  const keyModifiers = []\r\n  const nonKeyModifiers = []\r\n  const eventOptionModifiers = []\r\n\r\n  for (let i = 0; i < modifiers.length; i++) {\r\n    const modifier = modifiers[i]\r\n\r\n    if (\r\n      __COMPAT__ &&\r\n      modifier === 'native' &&\r\n      checkCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_V_ON_NATIVE,\r\n        context,\r\n        loc\r\n      )\r\n    ) {\r\n      eventOptionModifiers.push(modifier)\r\n    } else if (isEventOptionModifier(modifier)) {\r\n      // eventOptionModifiers: modifiers for addEventListener() options,\r\n      // e.g. .passive & .capture\r\n      eventOptionModifiers.push(modifier)\r\n    } else {\r\n      // runtimeModifiers: modifiers that needs runtime guards\r\n      if (maybeKeyModifier(modifier)) {\r\n        if (isStaticExp(key)) {\r\n          if (isKeyboardEvent((key as SimpleExpressionNode).content)) {\r\n            keyModifiers.push(modifier)\r\n          } else {\r\n            nonKeyModifiers.push(modifier)\r\n          }\r\n        } else {\r\n          keyModifiers.push(modifier)\r\n          nonKeyModifiers.push(modifier)\r\n        }\r\n      } else {\r\n        if (isNonKeyModifier(modifier)) {\r\n          nonKeyModifiers.push(modifier)\r\n        } else {\r\n          keyModifiers.push(modifier)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    keyModifiers,\r\n    nonKeyModifiers,\r\n    eventOptionModifiers\r\n  }\r\n}\r\n\r\nconst transformClick = (key: ExpressionNode, event: string) => {\r\n  const isStaticClick =\r\n    isStaticExp(key) && key.content.toLowerCase() === 'onclick'\r\n  return isStaticClick\r\n    ? createSimpleExpression(event, true)\r\n    : key.type !== NodeTypes.SIMPLE_EXPRESSION\r\n    ? createCompoundExpression([\r\n        `(`,\r\n        key,\r\n        `) === \"onClick\" ? \"${event}\" : (`,\r\n        key,\r\n        `)`\r\n      ])\r\n    : key\r\n}\r\n\r\nexport const transformOn: DirectiveTransform = (dir, node, context) => {\r\n  return baseTransform(dir, node, context, baseResult => {\r\n    const { modifiers } = dir\r\n    if (!modifiers.length) return baseResult\r\n\r\n    let { key, value: handlerExp } = baseResult.props[0]\r\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =\r\n      resolveModifiers(key, modifiers, context, dir.loc)\r\n\r\n    // normalize click.right and click.middle since they don't actually fire\r\n    if (nonKeyModifiers.includes('right')) {\r\n      key = transformClick(key, `onContextmenu`)\r\n    }\r\n    if (nonKeyModifiers.includes('middle')) {\r\n      key = transformClick(key, `onMouseup`)\r\n    }\r\n\r\n    if (nonKeyModifiers.length) {\r\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n        handlerExp,\r\n        JSON.stringify(nonKeyModifiers)\r\n      ])\r\n    }\r\n\r\n    if (\r\n      keyModifiers.length &&\r\n      // if event name is dynamic, always wrap with keys guard\r\n      (!isStaticExp(key) || isKeyboardEvent(key.content))\r\n    ) {\r\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n        handlerExp,\r\n        JSON.stringify(keyModifiers)\r\n      ])\r\n    }\r\n\r\n    if (eventOptionModifiers.length) {\r\n      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')\r\n      key = isStaticExp(key)\r\n        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n        : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`])\r\n    }\r\n\r\n    return {\r\n      props: [createObjectProperty(key, handlerExp)]\r\n    }\r\n  })\r\n}\r\n","import { NodeTransform, NodeTypes, ElementTypes } from '@vue/compiler-core'\r\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\r\n\r\nexport const ignoreSideEffectTags: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.ELEMENT &&\r\n    (node.tag === 'script' || node.tag === 'style')\r\n  ) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG, node.loc)\r\n    )\r\n    context.removeNode()\r\n  }\r\n}\r\n","import {\r\n  baseCompile,\r\n  baseParse,\r\n  CompilerOptions,\r\n  CodegenResult,\r\n  ParserOptions,\r\n  RootNode,\r\n  noopDirectiveTransform,\r\n  NodeTransform,\r\n  DirectiveTransform\r\n} from '@vue/compiler-core'\r\nimport { parserOptions } from './parserOptions'\r\nimport { transformStyle } from './transforms/transformStyle'\r\nimport { transformVHtml } from './transforms/vHtml'\r\nimport { transformVText } from './transforms/vText'\r\nimport { transformModel } from './transforms/vModel'\r\nimport { transformOn } from './transforms/vOn'\r\nimport { transformShow } from './transforms/vShow'\r\nimport { transformTransition } from './transforms/Transition'\r\nimport { stringifyStatic } from './transforms/stringifyStatic'\r\nimport { ignoreSideEffectTags } from './transforms/ignoreSideEffectTags'\r\nimport { extend } from '@vue/shared'\r\n\r\nexport { parserOptions }\r\n\r\nexport const DOMNodeTransforms: NodeTransform[] = [\r\n  transformStyle,\r\n  ...(__DEV__ ? [transformTransition] : [])\r\n]\r\n\r\nexport const DOMDirectiveTransforms: Record<string, DirectiveTransform> = {\r\n  cloak: noopDirectiveTransform,\r\n  html: transformVHtml,\r\n  text: transformVText,\r\n  model: transformModel, // override compiler-core\r\n  on: transformOn, // override compiler-core\r\n  show: transformShow\r\n}\r\n\r\nexport function compile(\r\n  template: string,\r\n  options: CompilerOptions = {}\r\n): CodegenResult {\r\n  return baseCompile(\r\n    template,\r\n    extend({}, parserOptions, options, {\r\n      nodeTransforms: [\r\n        // ignore <script> and <tag>\r\n        // this is not put inside DOMNodeTransforms because that list is used\r\n        // by compiler-ssr to generate vnode fallback branches\r\n        ignoreSideEffectTags,\r\n        ...DOMNodeTransforms,\r\n        ...(options.nodeTransforms || [])\r\n      ],\r\n      directiveTransforms: extend(\r\n        {},\r\n        DOMDirectiveTransforms,\r\n        options.directiveTransforms || {}\r\n      ),\r\n      transformHoist: __BROWSER__ ? null : stringifyStatic\r\n    })\r\n  )\r\n}\r\n\r\nexport function parse(template: string, options: ParserOptions = {}): RootNode {\r\n  return baseParse(template, extend({}, parserOptions, options))\r\n}\r\n\r\nexport * from './runtimeHelpers'\r\nexport { transformStyle } from './transforms/transformStyle'\r\nexport { createDOMCompilerError, DOMErrorCodes } from './errors'\r\nexport * from '@vue/compiler-core'\r\n","import {\r\n  DirectiveTransform,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  TO_DISPLAY_STRING,\r\n  createCallExpression,\r\n  getConstantType\r\n} from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\n\r\nexport const transformVText: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc)\r\n    )\r\n  }\r\n  if (node.children.length) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc)\r\n    )\r\n    node.children.length = 0\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        createSimpleExpression(`textContent`, true),\r\n        exp\r\n          ? getConstantType(exp, context) > 0\r\n            ? exp\r\n            : createCallExpression(\r\n                context.helperString(TO_DISPLAY_STRING),\r\n                [exp],\r\n                loc\r\n              )\r\n          : createSimpleExpression('', true)\r\n      )\r\n    ]\r\n  }\r\n}\r\n","import {\r\n  transformModel as baseTransform,\r\n  DirectiveTransform,\r\n  ElementTypes,\r\n  findProp,\r\n  NodeTypes,\r\n  hasDynamicKeyVBind\r\n} from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\nimport {\r\n  V_MODEL_CHECKBOX,\r\n  V_MODEL_RADIO,\r\n  V_MODEL_SELECT,\r\n  V_MODEL_TEXT,\r\n  V_MODEL_DYNAMIC\r\n} from '../runtimeHelpers'\r\n\r\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\r\n  const baseResult = baseTransform(dir, node, context)\r\n  // base transform has errors OR component v-model (only need props)\r\n  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {\r\n    return baseResult\r\n  }\r\n\r\n  if (dir.arg) {\r\n    context.onError(\r\n      createDOMCompilerError(\r\n        DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT,\r\n        dir.arg.loc\r\n      )\r\n    )\r\n  }\r\n\r\n  function checkDuplicatedValue() {\r\n    const value = findProp(node, 'value')\r\n    if (value) {\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\r\n          value.loc\r\n        )\r\n      )\r\n    }\r\n  }\r\n\r\n  const { tag } = node\r\n  const isCustomElement = context.isCustomElement(tag)\r\n  if (\r\n    tag === 'input' ||\r\n    tag === 'textarea' ||\r\n    tag === 'select' ||\r\n    isCustomElement\r\n  ) {\r\n    let directiveToUse = V_MODEL_TEXT\r\n    let isInvalidType = false\r\n    if (tag === 'input' || isCustomElement) {\r\n      const type = findProp(node, `type`)\r\n      if (type) {\r\n        if (type.type === NodeTypes.DIRECTIVE) {\r\n          // :type=\"foo\"\r\n          directiveToUse = V_MODEL_DYNAMIC\r\n        } else if (type.value) {\r\n          switch (type.value.content) {\r\n            case 'radio':\r\n              directiveToUse = V_MODEL_RADIO\r\n              break\r\n            case 'checkbox':\r\n              directiveToUse = V_MODEL_CHECKBOX\r\n              break\r\n            case 'file':\r\n              isInvalidType = true\r\n              context.onError(\r\n                createDOMCompilerError(\r\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n                  dir.loc\r\n                )\r\n              )\r\n              break\r\n            default:\r\n              // text type\r\n              __DEV__ && checkDuplicatedValue()\r\n              break\r\n          }\r\n        }\r\n      } else if (hasDynamicKeyVBind(node)) {\r\n        // element has bindings with dynamic keys, which can possibly contain\r\n        // \"type\".\r\n        directiveToUse = V_MODEL_DYNAMIC\r\n      } else {\r\n        // text type\r\n        __DEV__ && checkDuplicatedValue()\r\n      }\r\n    } else if (tag === 'select') {\r\n      directiveToUse = V_MODEL_SELECT\r\n    } else {\r\n      // textarea\r\n      __DEV__ && checkDuplicatedValue()\r\n    }\r\n    // inject runtime directive\r\n    // by returning the helper symbol via needRuntime\r\n    // the import will replaced a resolveDirective call.\r\n    if (!isInvalidType) {\r\n      baseResult.needRuntime = context.helper(directiveToUse)\r\n    }\r\n  } else {\r\n    context.onError(\r\n      createDOMCompilerError(\r\n        DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\r\n        dir.loc\r\n      )\r\n    )\r\n  }\r\n\r\n  // native vmodel doesn't need the `modelValue` props since they are also\r\n  // passed to the runtime as `binding.value`. removing it reduces code size.\r\n  baseResult.props = baseResult.props.filter(\r\n    p =>\r\n      !(\r\n        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        p.key.content === 'modelValue'\r\n      )\r\n  )\r\n\r\n  return baseResult\r\n}\r\n","import { DirectiveTransform } from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\nimport { V_SHOW } from '../runtimeHelpers'\r\n\r\nexport const transformShow: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION, loc)\r\n    )\r\n  }\r\n\r\n  return {\r\n    props: [],\r\n    needRuntime: context.helper(V_SHOW)\r\n  }\r\n}\r\n"],"names":["makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","generateCodeFrame","source","start","end","lines","newlineSequences","filter","_","idx","count","res","j","line","push","repeat","Math","max","String","lineLength","newLineSeqLength","pad","min","join","listDelimiterRE","propertyDelimiterRE","isHTMLTag","isSVGTag","isVoidTag","EMPTY_OBJ","NOOP","NO","onRE","isOn","key","test","extend","assign","isArray","Array","isString","isSymbol","isObject","isReservedProp","isBuiltInDirective","cacheStringFunction","fn","cache","camelizeRE","camelize","replace","c","toUpperCase","hyphenateRE","hyphenate","capitalize","charAt","slice","toHandlerKey","defaultOnError","error","defaultOnWarn","msg","code","loc","messages","additionalMessage","SyntaxError","FRAGMENT","Symbol","TELEPORT","SUSPENSE","KEEP_ALIVE","BASE_TRANSITION","OPEN_BLOCK","CREATE_BLOCK","CREATE_ELEMENT_BLOCK","CREATE_VNODE","CREATE_ELEMENT_VNODE","CREATE_COMMENT","CREATE_TEXT","CREATE_STATIC","RESOLVE_COMPONENT","RESOLVE_DYNAMIC_COMPONENT","RESOLVE_DIRECTIVE","RESOLVE_FILTER","WITH_DIRECTIVES","RENDER_LIST","RENDER_SLOT","CREATE_SLOTS","TO_DISPLAY_STRING","MERGE_PROPS","NORMALIZE_CLASS","NORMALIZE_STYLE","NORMALIZE_PROPS","GUARD_REACTIVE_PROPS","TO_HANDLERS","CAMELIZE","CAPITALIZE","TO_HANDLER_KEY","SET_BLOCK_TRACKING","PUSH_SCOPE_ID","POP_SCOPE_ID","WITH_CTX","UNREF","IS_REF","WITH_MEMO","IS_MEMO_SAME","helperNameMap","registerRuntimeHelpers","helpers","getOwnPropertySymbols","forEach","s","locStub","column","offset","createRoot","children","type","components","directives","hoists","imports","cached","temps","codegenNode","undefined","createVNodeCall","context","tag","props","patchFlag","dynamicProps","isBlock","disableTracking","isComponent","helper","getVNodeBlockHelper","inSSR","getVNodeHelper","createArrayExpression","elements","createObjectExpression","properties","createObjectProperty","value","createSimpleExpression","content","isStatic","constType","createInterpolation","createCompoundExpression","createCallExpression","callee","args","arguments","createFunctionExpression","params","returns","newline","isSlot","createConditionalExpression","consequent","alternate","createCacheExpression","index","isVNode","createBlockStatement","body","createTemplateLiteral","createIfStatement","createAssignmentExpression","left","right","createSequenceExpression","expressions","createReturnStatement","isStaticExp","p","isBuiltInType","expected","isCoreComponent","nonIdentifierRE","isSimpleIdentifier","name","validFirstIdentCharRE","validIdentCharRE","whitespaceRE","isMemberExpressionBrowser","path","trim","state","stateStack","currentOpenBracketCount","currentOpenParensCount","currentStringType","char","pop","isMemberExpressionNode","isMemberExpression","getInnerRange","newLoc","advancePositionWithClone","pos","numberOfCharacters","advancePositionWithMutation","linesCount","lastNewLinePos","charCodeAt","assert","condition","Error","findDir","node","allowEmpty","exp","findProp","dynamicOnly","isStaticArgOf","arg","hasDynamicKeyVBind","some","isText","isVSlot","isTemplateNode","tagType","isSlotOutlet","ssr","propsHelperSet","Set","getUnnormalizedProps","callPath","has","concat","injectProp","prop","propsWithInjection","parentCall","ret","first","unshift","alreadyExists","propKeyName","toValidAssetId","searchValue","replaceValue","toString","hasScopeRef","ids","keys","branches","b","getMemoedVNodeCall","makeBlock","removeHelper","deprecationData","COMPILER_IS_ON_ELEMENT","message","link","COMPILER_V_BIND_SYNC","COMPILER_V_BIND_PROP","COMPILER_V_BIND_OBJECT_ORDER","COMPILER_V_ON_NATIVE","COMPILER_V_IF_V_FOR_PRECEDENCE","COMPILER_NATIVE_TEMPLATE","COMPILER_INLINE_TEMPLATE","COMPILER_FILTER","getCompatValue","config","options","compatConfig","isCompatEnabled","mode","checkCompatEnabled","warnDeprecation","err","onWarn","decodeRE","decodeMap","gt","lt","amp","apos","quot","defaultParserOptions","delimiters","getNamespace","getTextMode","isPreTag","isCustomElement","decodeEntities","rawText","p1","onError","comments","baseParse","rawOptions","originalSource","inPre","inVPre","createParserContext","getCursor","parseChildren","getSelection","ancestors","parent","last","ns","nodes","isEnd","startsWith","parseInterpolation","parseComment","parseBogusComment","parseCDATA","advanceBy","parseTag","parseElement","isSpecialTemplateDirective","parseText","pushNode","removedWhitespace","shouldCondense","whitespace","prev","next","Boolean","match","exec","prevIndex","nestedIndex","indexOf","contentStart","closeIndex","wasInPre","wasInVPre","element","isPreBoundary","isVPreBoundary","isSelfClosing","inlineTemplateProp","find","startsWithEndTagOpen","advanceSpaces","cursor","currentSource","parseAttributes","isBuiltInComponent","isNativeTag","attributeNames","attr","parseAttribute","nameSet","add","pattern","m","quote","isQuoted","endIndex","parseTextData","unexpectedChars","parseAttributeValue","isPropShorthand","dirName","startOffset","lastIndexOf","getNewPosition","endsWith","valueLoc","modifiers","includes","splice","open","close","innerStart","innerEnd","rawContentLength","rawContent","preTrimContent","endTokens","xs","searchString","hoistStatic","root","walk","isSingleElementRoot","child","doNotHoistNode","originalCount","hoistedCount","constantType","getConstantType","hoist","flag","getPatchFlag","getGeneratedPropsConstantType","getNodeProps","scopes","vSlot","transformHoist","constantCache","get","set","returnType","generatedPropsType","childType","expType","allowHoistedHelperSet","getConstantTypeOfHelperCall","keyType","valueType","parseInt","createTransformContext","filename","prefixIdentifiers","cacheHandlers","nodeTransforms","directiveTransforms","expressionPlugins","scopeId","slotted","ssrCssVars","bindingMetadata","inline","isTS","nameMatch","selfName","Map","identifiers","vFor","vPre","vOnce","currentNode","childIndex","inVOnce","currentCount","delete","helperString","replaceNode","removeNode","removalIndex","onNodeRemoved","addIdentifiers","removeIdentifiers","identifier","hoisted","filters","transform","traverseNode","createRootCodegen","exitFns","onExit","nodeRemoved","traverseChildren","createStructuralDirectiveTransform","matches","n","aliasHelper","generate","ast","sourceMap","optimizeImports","runtimeGlobalName","runtimeModuleName","ssrRuntimeModuleName","indentLevel","pure","indent","deindent","withoutNewLine","createCodegenContext","onContextCreated","hasHelpers","useWithBlock","VueBinding","genNode","genHoists","genFunctionPreamble","genAssets","preamble","toJSON","assets","resolver","id","maybeSelfReference","JSON","stringify","genNodeListAsArray","multilines","genNodeList","comma","genText","genExpression","genInterpolation","genCompoundExpression","genComment","callHelper","genNullableArgs","genVNodeCall","genCallExpression","genExpressionAsPropertyKey","genObjectExpression","genArrayExpression","isNonScopedSlot","genFunctionExpression","needNewline","needsParens","isNested","genConditionalExpression","genCacheExpression","walkIdentifiers","onIdentifier","includeAll","parentStack","knownIds","isReferencedIdentifier","isInDestructureAssignment","walkFunctionParams","onIdent","extractIdentifiers","walkBlockDeclarations","block","stmt","declare","decl","declarations","param","object","argument","isFunctionType","isStaticProperty","computed","isStaticPropertyKey","transformExpression","processExpression","dir","asParams","asRawStatements","localVars","transformIf","processIf","ifNode","branch","isRoot","siblings","sibling","createCodegenNodeForBranch","parentCondition","getParentCondition","processCodegen","createIfBranch","isTemplateIf","userKey","keyIndex","createChildrenCodegenNode","keyProperty","firstChild","vnodeCall","transformFor","processFor","forNode","renderExp","isTemplate","memo","keyProp","keyExp","isStableFragment","fragmentFlag","childBlock","needFragmentWrapper","slotOutlet","loop","createForLoopParams","parseResult","parseForExpression","valueAlias","keyAlias","objectIndexAlias","forAliasRE","forIteratorRE","stripParensRE","input","inMatch","LHS","RHS","result","createAliasExpression","valueContent","trimmedOffset","iteratorMatch","keyContent","keyOffset","indexContent","range","memoArgs","createParamsList","defaultFallback","trackSlotScopes","trackVForSlotScopes","buildClientSlotFn","buildSlots","buildSlotFn","slotsProperties","dynamicSlots","hasDynamicSlots","onComponentSlot","hasTemplateSlots","hasNamedDefaultSlot","implicitDefaultChildren","seenSlotNames","slotElement","slotDir","slotChildren","slotLoc","slotName","slotProps","staticSlotName","slotFunction","vIf","vElse","buildDynamicSlot","conditional","buildDefaultSlotProperty","isNonWhitespaceContent","slotFlag","hasForwardedSlots","slots","directiveImportMap","WeakMap","transformElement","vnodeTag","resolveComponentType","isDynamicComponent","vnodeProps","vnodeChildren","vnodePatchFlag","vnodeDynamicProps","dynamicPropNames","vnodeDirectives","shouldUseBlock","propsBuildResult","buildProps","buildDirectiveArgs","hasDynamicTextChild","propsNamesString","l","stringifyDynamicPropNames","isExplicitDynamic","isComponentTag","isProp","isDir","builtIn","elementLoc","mergeArgs","runtimeDirectives","hasChildren","hasRef","hasClassBinding","hasStyleBinding","hasHydrationEventBinding","hasDynamicKeys","hasVnodeHook","analyzePatchFlag","isEventHandler","isVBind","isVOn","dedupeProperties","directiveTransform","needRuntime","propsExpression","classKeyIndex","styleKeyIndex","hasDynamicKey","isHandlerKey","classProp","styleProp","knownProps","deduped","existing","mergeAsArray","incoming","dirArgs","runtime","trueExpression","modifier","transformSlotOutlet","processSlotOutlet","slotArgs","expectedLen","nonNameProps","fnExpRE","transformOn","augmentor","eventName","rawName","shouldCache","isMemberExp","isInlineStatement","hasMultipleStatements","transformBind","_node","injectPrefix","prefix","transformText","currentContainer","hasText","callArgs","seen","WeakSet","transformOnce","cur","transformModel","createTransformProps","rawExp","expString","propName","assignmentExp","modifiersKey","validDivisionCharRE","transformFilter","rewriteFilter","parseFilter","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","lastFilterIndex","pushFilter","wrapFilter","transformMemo","getBaseTransformPreset","on","bind","model","baseCompile","template","isModuleMode","noopDirectiveTransform","V_MODEL_RADIO","V_MODEL_CHECKBOX","V_MODEL_TEXT","V_MODEL_SELECT","V_MODEL_DYNAMIC","V_ON_WITH_MODIFIERS","V_ON_WITH_KEYS","V_SHOW","TRANSITION","TRANSITION_GROUP","decoder","isRawTextContainer","parserOptions","raw","asAttr","document","createElement","innerHTML","getAttribute","textContent","a","transformStyle","parseInlineCSS","cssText","normalized","item","tmp","parseStringStyle","isEventOptionModifier","isNonKeyModifier","maybeKeyModifier","isKeyboardEvent","transformClick","event","ignoreSideEffectTags","DOMNodeTransforms","DOMDirectiveTransforms","cloak","html","text","baseResult","baseTransform","directiveToUse","isInvalidType","handlerExp","keyModifiers","nonKeyModifiers","eventOptionModifiers","resolveModifiers","modifierPostfix","show","compile","parse"],"mappings":"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"}