{"version":3,"file":"compiler-ssr.cjs.js","sources":["../src/runtimeHelpers.ts","../src/transforms/ssrVIf.ts","../src/transforms/ssrVFor.ts","../src/transforms/ssrTransformSlotOutlet.ts","../src/errors.ts","../src/transforms/ssrTransformTeleport.ts","../src/transforms/ssrTransformSuspense.ts","../src/transforms/ssrTransformElement.ts","../src/transforms/ssrTransformTransitionGroup.ts","../src/transforms/ssrTransformComponent.ts","../src/ssrCodegenTransform.ts","../src/transforms/ssrVModel.ts","../src/transforms/ssrVShow.ts","../src/transforms/ssrInjectFallthroughAttrs.ts","../src/transforms/ssrInjectCssVars.ts","../src/index.ts"],"sourcesContent":["import { registerRuntimeHelpers } from '@vue/compiler-dom'\r\n\r\nexport const SSR_INTERPOLATE = Symbol(`ssrInterpolate`)\r\nexport const SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`)\r\nexport const SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`)\r\nexport const SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`)\r\nexport const SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`)\r\nexport const SSR_RENDER_CLASS = Symbol(`ssrRenderClass`)\r\nexport const SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`)\r\nexport const SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`)\r\nexport const SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`)\r\nexport const SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`)\r\nexport const SSR_RENDER_LIST = Symbol(`ssrRenderList`)\r\nexport const SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`)\r\nexport const SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`)\r\nexport const SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`)\r\nexport const SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`)\r\nexport const SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`)\r\nexport const SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`)\r\nexport const SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`)\r\nexport const SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`)\r\n\r\nexport const ssrHelpers = {\r\n  [SSR_INTERPOLATE]: `ssrInterpolate`,\r\n  [SSR_RENDER_VNODE]: `ssrRenderVNode`,\r\n  [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,\r\n  [SSR_RENDER_SLOT]: `ssrRenderSlot`,\r\n  [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,\r\n  [SSR_RENDER_CLASS]: `ssrRenderClass`,\r\n  [SSR_RENDER_STYLE]: `ssrRenderStyle`,\r\n  [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,\r\n  [SSR_RENDER_ATTR]: `ssrRenderAttr`,\r\n  [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,\r\n  [SSR_RENDER_LIST]: `ssrRenderList`,\r\n  [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,\r\n  [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,\r\n  [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,\r\n  [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,\r\n  [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,\r\n  [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,\r\n  [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,\r\n  [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`\r\n}\r\n\r\n// Note: these are helpers imported from @vue/server-renderer\r\n// make sure the names match!\r\nregisterRuntimeHelpers(ssrHelpers)\r\n","import {\r\n  createStructuralDirectiveTransform,\r\n  processIf,\r\n  IfNode,\r\n  createIfStatement,\r\n  createBlockStatement,\r\n  createCallExpression,\r\n  IfBranchNode,\r\n  BlockStatement,\r\n  NodeTypes\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  SSRTransformContext,\r\n  processChildrenAsStatement\r\n} from '../ssrCodegenTransform'\r\n\r\n// Plugin for the first transform pass, which simply constructs the AST node\r\nexport const ssrTransformIf = createStructuralDirectiveTransform(\r\n  /^(if|else|else-if)$/,\r\n  processIf\r\n)\r\n\r\n// This is called during the 2nd transform pass to construct the SSR-specific\r\n// codegen nodes.\r\nexport function ssrProcessIf(\r\n  node: IfNode,\r\n  context: SSRTransformContext,\r\n  disableNestedFragments = false\r\n) {\r\n  const [rootBranch] = node.branches\r\n  const ifStatement = createIfStatement(\r\n    rootBranch.condition!,\r\n    processIfBranch(rootBranch, context, disableNestedFragments)\r\n  )\r\n  context.pushStatement(ifStatement)\r\n\r\n  let currentIf = ifStatement\r\n  for (let i = 1; i < node.branches.length; i++) {\r\n    const branch = node.branches[i]\r\n    const branchBlockStatement = processIfBranch(\r\n      branch,\r\n      context,\r\n      disableNestedFragments\r\n    )\r\n    if (branch.condition) {\r\n      // else-if\r\n      currentIf = currentIf.alternate = createIfStatement(\r\n        branch.condition,\r\n        branchBlockStatement\r\n      )\r\n    } else {\r\n      // else\r\n      currentIf.alternate = branchBlockStatement\r\n    }\r\n  }\r\n\r\n  if (!currentIf.alternate) {\r\n    currentIf.alternate = createBlockStatement([\r\n      createCallExpression(`_push`, ['`<!---->`'])\r\n    ])\r\n  }\r\n}\r\n\r\nfunction processIfBranch(\r\n  branch: IfBranchNode,\r\n  context: SSRTransformContext,\r\n  disableNestedFragments = false\r\n): BlockStatement {\r\n  const { children } = branch\r\n  const needFragmentWrapper =\r\n    !disableNestedFragments &&\r\n    (children.length !== 1 || children[0].type !== NodeTypes.ELEMENT) &&\r\n    // optimize away nested fragments when the only child is a ForNode\r\n    !(children.length === 1 && children[0].type === NodeTypes.FOR)\r\n  return processChildrenAsStatement(branch, context, needFragmentWrapper)\r\n}\r\n","import {\r\n  createStructuralDirectiveTransform,\r\n  ForNode,\r\n  processFor,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  createForLoopParams,\r\n  NodeTypes\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  SSRTransformContext,\r\n  processChildrenAsStatement\r\n} from '../ssrCodegenTransform'\r\nimport { SSR_RENDER_LIST } from '../runtimeHelpers'\r\n\r\n// Plugin for the first transform pass, which simply constructs the AST node\r\nexport const ssrTransformFor = createStructuralDirectiveTransform(\r\n  'for',\r\n  processFor\r\n)\r\n\r\n// This is called during the 2nd transform pass to construct the SSR-specific\r\n// codegen nodes.\r\nexport function ssrProcessFor(\r\n  node: ForNode,\r\n  context: SSRTransformContext,\r\n  disableNestedFragments = false\r\n) {\r\n  const needFragmentWrapper =\r\n    !disableNestedFragments &&\r\n    (node.children.length !== 1 || node.children[0].type !== NodeTypes.ELEMENT)\r\n  const renderLoop = createFunctionExpression(\r\n    createForLoopParams(node.parseResult)\r\n  )\r\n  renderLoop.body = processChildrenAsStatement(\r\n    node,\r\n    context,\r\n    needFragmentWrapper\r\n  )\r\n  // v-for always renders a fragment unless explicitly disabled\r\n  if (!disableNestedFragments) {\r\n    context.pushStringPart(`<!--[-->`)\r\n  }\r\n  context.pushStatement(\r\n    createCallExpression(context.helper(SSR_RENDER_LIST), [\r\n      node.source,\r\n      renderLoop\r\n    ])\r\n  )\r\n  if (!disableNestedFragments) {\r\n    context.pushStringPart(`<!--]-->`)\r\n  }\r\n}\r\n","import {\r\n  NodeTransform,\r\n  isSlotOutlet,\r\n  processSlotOutlet,\r\n  createCallExpression,\r\n  SlotOutletNode,\r\n  createFunctionExpression,\r\n  NodeTypes,\r\n  ElementTypes,\r\n  resolveComponentType,\r\n  TRANSITION\r\n} from '@vue/compiler-dom'\r\nimport { SSR_RENDER_SLOT, SSR_RENDER_SLOT_INNER } from '../runtimeHelpers'\r\nimport {\r\n  SSRTransformContext,\r\n  processChildrenAsStatement\r\n} from '../ssrCodegenTransform'\r\n\r\nexport const ssrTransformSlotOutlet: NodeTransform = (node, context) => {\r\n  if (isSlotOutlet(node)) {\r\n    const { slotName, slotProps } = processSlotOutlet(node, context)\r\n\r\n    const args = [\r\n      `_ctx.$slots`,\r\n      slotName,\r\n      slotProps || `{}`,\r\n      // fallback content placeholder. will be replaced in the process phase\r\n      `null`,\r\n      `_push`,\r\n      `_parent`\r\n    ]\r\n\r\n    // inject slot scope id if current template uses :slotted\r\n    if (context.scopeId && context.slotted !== false) {\r\n      args.push(`\"${context.scopeId}-s\"`)\r\n    }\r\n\r\n    let method = SSR_RENDER_SLOT\r\n\r\n    // #3989\r\n    // check if this is a single slot inside a transition wrapper - since\r\n    // transition will unwrap the slot fragment into a single vnode at runtime,\r\n    // we need to avoid rendering the slot as a fragment.\r\n    const parent = context.parent\r\n    if (\r\n      parent &&\r\n      parent.type === NodeTypes.ELEMENT &&\r\n      parent.tagType === ElementTypes.COMPONENT &&\r\n      resolveComponentType(parent, context, true) === TRANSITION &&\r\n      parent.children.filter(c => c.type === NodeTypes.ELEMENT).length === 1\r\n    ) {\r\n      method = SSR_RENDER_SLOT_INNER\r\n      if (!(context.scopeId && context.slotted !== false)) {\r\n        args.push('null')\r\n      }\r\n      args.push('true')\r\n    }\r\n\r\n    node.ssrCodegenNode = createCallExpression(context.helper(method), args)\r\n  }\r\n}\r\n\r\nexport function ssrProcessSlotOutlet(\r\n  node: SlotOutletNode,\r\n  context: SSRTransformContext\r\n) {\r\n  const renderCall = node.ssrCodegenNode!\r\n\r\n  // has fallback content\r\n  if (node.children.length) {\r\n    const fallbackRenderFn = createFunctionExpression([])\r\n    fallbackRenderFn.body = processChildrenAsStatement(node, context)\r\n    // _renderSlot(slots, name, props, fallback, ...)\r\n    renderCall.arguments[3] = fallbackRenderFn\r\n  }\r\n\r\n  // Forwarded <slot/>. Merge slot scope ids\r\n  if (context.withSlotScopeId) {\r\n    const slotScopeId = renderCall.arguments[6]\r\n    renderCall.arguments[6] = slotScopeId\r\n      ? `${slotScopeId as string} + _scopeId`\r\n      : `_scopeId`\r\n  }\r\n\r\n  context.pushStatement(node.ssrCodegenNode!)\r\n}\r\n","import {\r\n  SourceLocation,\r\n  CompilerError,\r\n  createCompilerError,\r\n  DOMErrorCodes\r\n} from '@vue/compiler-dom'\r\n\r\nexport interface SSRCompilerError extends CompilerError {\r\n  code: SSRErrorCodes\r\n}\r\n\r\nexport function createSSRCompilerError(\r\n  code: SSRErrorCodes,\r\n  loc?: SourceLocation\r\n) {\r\n  return createCompilerError(code, loc, SSRErrorMessages) as SSRCompilerError\r\n}\r\n\r\nexport const enum SSRErrorCodes {\r\n  X_SSR_UNSAFE_ATTR_NAME = DOMErrorCodes.__EXTEND_POINT__,\r\n  X_SSR_NO_TELEPORT_TARGET,\r\n  X_SSR_INVALID_AST_NODE\r\n}\r\n\r\nexport const SSRErrorMessages: { [code: number]: string } = {\r\n  [SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME]: `Unsafe attribute name for SSR.`,\r\n  [SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET]: `Missing the 'to' prop on teleport element.`,\r\n  [SSRErrorCodes.X_SSR_INVALID_AST_NODE]: `Invalid AST node during SSR transform.`\r\n}\r\n","import {\r\n  ComponentNode,\r\n  findProp,\r\n  NodeTypes,\r\n  createSimpleExpression,\r\n  createFunctionExpression,\r\n  createCallExpression,\r\n  ExpressionNode\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  SSRTransformContext,\r\n  processChildrenAsStatement\r\n} from '../ssrCodegenTransform'\r\nimport { createSSRCompilerError, SSRErrorCodes } from '../errors'\r\nimport { SSR_RENDER_TELEPORT } from '../runtimeHelpers'\r\n\r\n// Note: this is a 2nd-pass codegen transform.\r\nexport function ssrProcessTeleport(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext\r\n) {\r\n  const targetProp = findProp(node, 'to')\r\n  if (!targetProp) {\r\n    context.onError(\r\n      createSSRCompilerError(SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET, node.loc)\r\n    )\r\n    return\r\n  }\r\n\r\n  let target: ExpressionNode | undefined\r\n  if (targetProp.type === NodeTypes.ATTRIBUTE) {\r\n    target =\r\n      targetProp.value && createSimpleExpression(targetProp.value.content, true)\r\n  } else {\r\n    target = targetProp.exp\r\n  }\r\n  if (!target) {\r\n    context.onError(\r\n      createSSRCompilerError(\r\n        SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET,\r\n        targetProp.loc\r\n      )\r\n    )\r\n    return\r\n  }\r\n\r\n  const disabledProp = findProp(node, 'disabled', false, true /* allow empty */)\r\n  const disabled = disabledProp\r\n    ? disabledProp.type === NodeTypes.ATTRIBUTE\r\n      ? `true`\r\n      : disabledProp.exp || `false`\r\n    : `false`\r\n\r\n  const contentRenderFn = createFunctionExpression(\r\n    [`_push`],\r\n    undefined, // Body is added later\r\n    true, // newline\r\n    false, // isSlot\r\n    node.loc\r\n  )\r\n  contentRenderFn.body = processChildrenAsStatement(node, context)\r\n  context.pushStatement(\r\n    createCallExpression(context.helper(SSR_RENDER_TELEPORT), [\r\n      `_push`,\r\n      contentRenderFn,\r\n      target,\r\n      disabled,\r\n      `_parent`\r\n    ])\r\n  )\r\n}\r\n","import {\r\n  ComponentNode,\r\n  TransformContext,\r\n  buildSlots,\r\n  createFunctionExpression,\r\n  FunctionExpression,\r\n  TemplateChildNode,\r\n  createCallExpression,\r\n  SlotsExpression\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  SSRTransformContext,\r\n  processChildrenAsStatement\r\n} from '../ssrCodegenTransform'\r\nimport { SSR_RENDER_SUSPENSE } from '../runtimeHelpers'\r\n\r\nconst wipMap = new WeakMap<ComponentNode, WIPEntry>()\r\n\r\ninterface WIPEntry {\r\n  slotsExp: SlotsExpression\r\n  wipSlots: Array<{\r\n    fn: FunctionExpression\r\n    children: TemplateChildNode[]\r\n  }>\r\n}\r\n\r\n// phase 1\r\nexport function ssrTransformSuspense(\r\n  node: ComponentNode,\r\n  context: TransformContext\r\n) {\r\n  return () => {\r\n    if (node.children.length) {\r\n      const wipEntry: WIPEntry = {\r\n        slotsExp: null!, // to be immediately set\r\n        wipSlots: []\r\n      }\r\n      wipMap.set(node, wipEntry)\r\n      wipEntry.slotsExp = buildSlots(node, context, (_props, children, loc) => {\r\n        const fn = createFunctionExpression(\r\n          [],\r\n          undefined, // no return, assign body later\r\n          true, // newline\r\n          false, // suspense slots are not treated as normal slots\r\n          loc\r\n        )\r\n        wipEntry.wipSlots.push({\r\n          fn,\r\n          children\r\n        })\r\n        return fn\r\n      }).slots\r\n    }\r\n  }\r\n}\r\n\r\n// phase 2\r\nexport function ssrProcessSuspense(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext\r\n) {\r\n  // complete wip slots with ssr code\r\n  const wipEntry = wipMap.get(node)\r\n  if (!wipEntry) {\r\n    return\r\n  }\r\n  const { slotsExp, wipSlots } = wipEntry\r\n  for (let i = 0; i < wipSlots.length; i++) {\r\n    const slot = wipSlots[i]\r\n    slot.fn.body = processChildrenAsStatement(slot, context)\r\n  }\r\n  // _push(ssrRenderSuspense(slots))\r\n  context.pushStatement(\r\n    createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [\r\n      `_push`,\r\n      slotsExp\r\n    ])\r\n  )\r\n}\r\n","import {\r\n  NodeTransform,\r\n  NodeTypes,\r\n  ElementTypes,\r\n  TemplateLiteral,\r\n  createTemplateLiteral,\r\n  createInterpolation,\r\n  createCallExpression,\r\n  createConditionalExpression,\r\n  createSimpleExpression,\r\n  buildProps,\r\n  DirectiveNode,\r\n  PlainElementNode,\r\n  createCompilerError,\r\n  ErrorCodes,\r\n  CallExpression,\r\n  createArrayExpression,\r\n  ExpressionNode,\r\n  JSChildNode,\r\n  ArrayExpression,\r\n  createAssignmentExpression,\r\n  TextNode,\r\n  hasDynamicKeyVBind,\r\n  MERGE_PROPS,\r\n  isStaticArgOf,\r\n  createSequenceExpression,\r\n  InterpolationNode,\r\n  isStaticExp,\r\n  AttributeNode,\r\n  buildDirectiveArgs,\r\n  TransformContext,\r\n  PropsExpression\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  escapeHtml,\r\n  isBooleanAttr,\r\n  isBuiltInDirective,\r\n  isSSRSafeAttrName,\r\n  NO,\r\n  propsToAttrMap\r\n} from '@vue/shared'\r\nimport { createSSRCompilerError, SSRErrorCodes } from '../errors'\r\nimport {\r\n  SSR_RENDER_ATTR,\r\n  SSR_RENDER_CLASS,\r\n  SSR_RENDER_STYLE,\r\n  SSR_RENDER_DYNAMIC_ATTR,\r\n  SSR_RENDER_ATTRS,\r\n  SSR_INTERPOLATE,\r\n  SSR_GET_DYNAMIC_MODEL_PROPS,\r\n  SSR_INCLUDE_BOOLEAN_ATTR,\r\n  SSR_GET_DIRECTIVE_PROPS\r\n} from '../runtimeHelpers'\r\nimport { SSRTransformContext, processChildren } from '../ssrCodegenTransform'\r\n\r\n// for directives with children overwrite (e.g. v-html & v-text), we need to\r\n// store the raw children so that they can be added in the 2nd pass.\r\nconst rawChildrenMap = new WeakMap<\r\n  PlainElementNode,\r\n  TemplateLiteral['elements'][0]\r\n>()\r\n\r\nexport const ssrTransformElement: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type !== NodeTypes.ELEMENT ||\r\n    node.tagType !== ElementTypes.ELEMENT\r\n  ) {\r\n    return\r\n  }\r\n\r\n  return function ssrPostTransformElement() {\r\n    // element\r\n    // generate the template literal representing the open tag.\r\n    const openTag: TemplateLiteral['elements'] = [`<${node.tag}`]\r\n    // some tags need to be passed to runtime for special checks\r\n    const needTagForRuntime =\r\n      node.tag === 'textarea' || node.tag.indexOf('-') > 0\r\n\r\n    // v-bind=\"obj\", v-bind:[key] and custom directives can potentially\r\n    // overwrite other static attrs and can affect final rendering result,\r\n    // so when they are present we need to bail out to full `renderAttrs`\r\n    const hasDynamicVBind = hasDynamicKeyVBind(node)\r\n    const hasCustomDir = node.props.some(\r\n      p => p.type === NodeTypes.DIRECTIVE && !isBuiltInDirective(p.name)\r\n    )\r\n    const needMergeProps = hasDynamicVBind || hasCustomDir\r\n    if (needMergeProps) {\r\n      const { props, directives } = buildProps(\r\n        node,\r\n        context,\r\n        node.props,\r\n        false /* isComponent */,\r\n        false /* isDynamicComponent */,\r\n        true /* ssr */\r\n      )\r\n      if (props || directives.length) {\r\n        const mergedProps = buildSSRProps(props, directives, context)\r\n        const propsExp = createCallExpression(\r\n          context.helper(SSR_RENDER_ATTRS),\r\n          [mergedProps]\r\n        )\r\n\r\n        if (node.tag === 'textarea') {\r\n          const existingText = node.children[0] as\r\n            | TextNode\r\n            | InterpolationNode\r\n            | undefined\r\n          // If interpolation, this is dynamic <textarea> content, potentially\r\n          // injected by v-model and takes higher priority than v-bind value\r\n          if (!existingText || existingText.type !== NodeTypes.INTERPOLATION) {\r\n            // <textarea> with dynamic v-bind. We don't know if the final props\r\n            // will contain .value, so we will have to do something special:\r\n            // assign the merged props to a temp variable, and check whether\r\n            // it contains value (if yes, render is as children).\r\n            const tempId = `_temp${context.temps++}`\r\n            propsExp.arguments = [\r\n              createAssignmentExpression(\r\n                createSimpleExpression(tempId, false),\r\n                mergedProps\r\n              )\r\n            ]\r\n            rawChildrenMap.set(\r\n              node,\r\n              createCallExpression(context.helper(SSR_INTERPOLATE), [\r\n                createConditionalExpression(\r\n                  createSimpleExpression(`\"value\" in ${tempId}`, false),\r\n                  createSimpleExpression(`${tempId}.value`, false),\r\n                  createSimpleExpression(\r\n                    existingText ? existingText.content : ``,\r\n                    true\r\n                  ),\r\n                  false\r\n                )\r\n              ])\r\n            )\r\n          }\r\n        } else if (node.tag === 'input') {\r\n          // <input v-bind=\"obj\" v-model>\r\n          // we need to determine the props to render for the dynamic v-model\r\n          // and merge it with the v-bind expression.\r\n          const vModel = findVModel(node)\r\n          if (vModel) {\r\n            // 1. save the props (san v-model) in a temp variable\r\n            const tempId = `_temp${context.temps++}`\r\n            const tempExp = createSimpleExpression(tempId, false)\r\n            propsExp.arguments = [\r\n              createSequenceExpression([\r\n                createAssignmentExpression(tempExp, mergedProps),\r\n                createCallExpression(context.helper(MERGE_PROPS), [\r\n                  tempExp,\r\n                  createCallExpression(\r\n                    context.helper(SSR_GET_DYNAMIC_MODEL_PROPS),\r\n                    [\r\n                      tempExp, // existing props\r\n                      vModel.exp! // model\r\n                    ]\r\n                  )\r\n                ])\r\n              ])\r\n            ]\r\n          }\r\n        }\r\n\r\n        if (needTagForRuntime) {\r\n          propsExp.arguments.push(`\"${node.tag}\"`)\r\n        }\r\n\r\n        openTag.push(propsExp)\r\n      }\r\n    }\r\n\r\n    // book keeping static/dynamic class merging.\r\n    let dynamicClassBinding: CallExpression | undefined = undefined\r\n    let staticClassBinding: string | undefined = undefined\r\n    // all style bindings are converted to dynamic by transformStyle.\r\n    // but we need to make sure to merge them.\r\n    let dynamicStyleBinding: CallExpression | undefined = undefined\r\n\r\n    for (let i = 0; i < node.props.length; i++) {\r\n      const prop = node.props[i]\r\n      // ignore true-value/false-value on input\r\n      if (node.tag === 'input' && isTrueFalseValue(prop)) {\r\n        continue\r\n      }\r\n      // special cases with children override\r\n      if (prop.type === NodeTypes.DIRECTIVE) {\r\n        if (prop.name === 'html' && prop.exp) {\r\n          rawChildrenMap.set(node, prop.exp)\r\n        } else if (prop.name === 'text' && prop.exp) {\r\n          node.children = [createInterpolation(prop.exp, prop.loc)]\r\n        } else if (prop.name === 'slot') {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, prop.loc)\r\n          )\r\n        } else if (isTextareaWithValue(node, prop) && prop.exp) {\r\n          if (!needMergeProps) {\r\n            node.children = [createInterpolation(prop.exp, prop.loc)]\r\n          }\r\n        } else if (!needMergeProps && prop.name !== 'on') {\r\n          // Directive transforms.\r\n          const directiveTransform = context.directiveTransforms[prop.name]\r\n          if (directiveTransform) {\r\n            const { props, ssrTagParts } = directiveTransform(\r\n              prop,\r\n              node,\r\n              context\r\n            )\r\n            if (ssrTagParts) {\r\n              openTag.push(...ssrTagParts)\r\n            }\r\n            for (let j = 0; j < props.length; j++) {\r\n              const { key, value } = props[j]\r\n              if (isStaticExp(key)) {\r\n                let attrName = key.content\r\n                // static key attr\r\n                if (attrName === 'key' || attrName === 'ref') {\r\n                  continue\r\n                }\r\n                if (attrName === 'class') {\r\n                  openTag.push(\r\n                    ` class=\"`,\r\n                    (dynamicClassBinding = createCallExpression(\r\n                      context.helper(SSR_RENDER_CLASS),\r\n                      [value]\r\n                    )),\r\n                    `\"`\r\n                  )\r\n                } else if (attrName === 'style') {\r\n                  if (dynamicStyleBinding) {\r\n                    // already has style binding, merge into it.\r\n                    mergeCall(dynamicStyleBinding, value)\r\n                  } else {\r\n                    openTag.push(\r\n                      ` style=\"`,\r\n                      (dynamicStyleBinding = createCallExpression(\r\n                        context.helper(SSR_RENDER_STYLE),\r\n                        [value]\r\n                      )),\r\n                      `\"`\r\n                    )\r\n                  }\r\n                } else {\r\n                  attrName =\r\n                    node.tag.indexOf('-') > 0\r\n                      ? attrName // preserve raw name on custom elements\r\n                      : propsToAttrMap[attrName] || attrName.toLowerCase()\r\n                  if (isBooleanAttr(attrName)) {\r\n                    openTag.push(\r\n                      createConditionalExpression(\r\n                        createCallExpression(\r\n                          context.helper(SSR_INCLUDE_BOOLEAN_ATTR),\r\n                          [value]\r\n                        ),\r\n                        createSimpleExpression(' ' + attrName, true),\r\n                        createSimpleExpression('', true),\r\n                        false /* no newline */\r\n                      )\r\n                    )\r\n                  } else if (isSSRSafeAttrName(attrName)) {\r\n                    openTag.push(\r\n                      createCallExpression(context.helper(SSR_RENDER_ATTR), [\r\n                        key,\r\n                        value\r\n                      ])\r\n                    )\r\n                  } else {\r\n                    context.onError(\r\n                      createSSRCompilerError(\r\n                        SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME,\r\n                        key.loc\r\n                      )\r\n                    )\r\n                  }\r\n                }\r\n              } else {\r\n                // dynamic key attr\r\n                // this branch is only encountered for custom directive\r\n                // transforms that returns properties with dynamic keys\r\n                const args: CallExpression['arguments'] = [key, value]\r\n                if (needTagForRuntime) {\r\n                  args.push(`\"${node.tag}\"`)\r\n                }\r\n                openTag.push(\r\n                  createCallExpression(\r\n                    context.helper(SSR_RENDER_DYNAMIC_ATTR),\r\n                    args\r\n                  )\r\n                )\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // special case: value on <textarea>\r\n        if (node.tag === 'textarea' && prop.name === 'value' && prop.value) {\r\n          rawChildrenMap.set(node, escapeHtml(prop.value.content))\r\n        } else if (!needMergeProps) {\r\n          if (prop.name === 'key' || prop.name === 'ref') {\r\n            continue\r\n          }\r\n          // static prop\r\n          if (prop.name === 'class' && prop.value) {\r\n            staticClassBinding = JSON.stringify(prop.value.content)\r\n          }\r\n          openTag.push(\r\n            ` ${prop.name}` +\r\n              (prop.value ? `=\"${escapeHtml(prop.value.content)}\"` : ``)\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    // handle co-existence of dynamic + static class bindings\r\n    if (dynamicClassBinding && staticClassBinding) {\r\n      mergeCall(dynamicClassBinding, staticClassBinding)\r\n      removeStaticBinding(openTag, 'class')\r\n    }\r\n\r\n    if (context.scopeId) {\r\n      openTag.push(` ${context.scopeId}`)\r\n    }\r\n\r\n    node.ssrCodegenNode = createTemplateLiteral(openTag)\r\n  }\r\n}\r\n\r\nexport function buildSSRProps(\r\n  props: PropsExpression | undefined,\r\n  directives: DirectiveNode[],\r\n  context: TransformContext\r\n): JSChildNode {\r\n  let mergePropsArgs: JSChildNode[] = []\r\n  if (props) {\r\n    if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n      // already a mergeProps call\r\n      mergePropsArgs = props.arguments as JSChildNode[]\r\n    } else {\r\n      mergePropsArgs.push(props)\r\n    }\r\n  }\r\n  if (directives.length) {\r\n    for (const dir of directives) {\r\n      mergePropsArgs.push(\r\n        createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [\r\n          `_ctx`,\r\n          ...buildDirectiveArgs(dir, context).elements\r\n        ] as JSChildNode[])\r\n      )\r\n    }\r\n  }\r\n\r\n  return mergePropsArgs.length > 1\r\n    ? createCallExpression(context.helper(MERGE_PROPS), mergePropsArgs)\r\n    : mergePropsArgs[0]\r\n}\r\n\r\nfunction isTrueFalseValue(prop: DirectiveNode | AttributeNode) {\r\n  if (prop.type === NodeTypes.DIRECTIVE) {\r\n    return (\r\n      prop.name === 'bind' &&\r\n      prop.arg &&\r\n      isStaticExp(prop.arg) &&\r\n      (prop.arg.content === 'true-value' || prop.arg.content === 'false-value')\r\n    )\r\n  } else {\r\n    return prop.name === 'true-value' || prop.name === 'false-value'\r\n  }\r\n}\r\n\r\nfunction isTextareaWithValue(\r\n  node: PlainElementNode,\r\n  prop: DirectiveNode\r\n): boolean {\r\n  return !!(\r\n    node.tag === 'textarea' &&\r\n    prop.name === 'bind' &&\r\n    isStaticArgOf(prop.arg, 'value')\r\n  )\r\n}\r\n\r\nfunction mergeCall(call: CallExpression, arg: string | JSChildNode) {\r\n  const existing = call.arguments[0] as ExpressionNode | ArrayExpression\r\n  if (existing.type === NodeTypes.JS_ARRAY_EXPRESSION) {\r\n    existing.elements.push(arg)\r\n  } else {\r\n    call.arguments[0] = createArrayExpression([existing, arg])\r\n  }\r\n}\r\n\r\nfunction removeStaticBinding(\r\n  tag: TemplateLiteral['elements'],\r\n  binding: string\r\n) {\r\n  const regExp = new RegExp(`^ ${binding}=\".+\"$`)\r\n\r\n  const i = tag.findIndex(e => typeof e === 'string' && regExp.test(e))\r\n\r\n  if (i > -1) {\r\n    tag.splice(i, 1)\r\n  }\r\n}\r\n\r\nfunction findVModel(node: PlainElementNode): DirectiveNode | undefined {\r\n  return node.props.find(\r\n    p => p.type === NodeTypes.DIRECTIVE && p.name === 'model' && p.exp\r\n  ) as DirectiveNode | undefined\r\n}\r\n\r\nexport function ssrProcessElement(\r\n  node: PlainElementNode,\r\n  context: SSRTransformContext\r\n) {\r\n  const isVoidTag = context.options.isVoidTag || NO\r\n  const elementsToAdd = node.ssrCodegenNode!.elements\r\n  for (let j = 0; j < elementsToAdd.length; j++) {\r\n    context.pushStringPart(elementsToAdd[j])\r\n  }\r\n\r\n  // Handle slot scopeId\r\n  if (context.withSlotScopeId) {\r\n    context.pushStringPart(createSimpleExpression(`_scopeId`, false))\r\n  }\r\n\r\n  // close open tag\r\n  context.pushStringPart(`>`)\r\n\r\n  const rawChildren = rawChildrenMap.get(node)\r\n  if (rawChildren) {\r\n    context.pushStringPart(rawChildren)\r\n  } else if (node.children.length) {\r\n    processChildren(node, context)\r\n  }\r\n\r\n  if (!isVoidTag(node.tag)) {\r\n    // push closing tag\r\n    context.pushStringPart(`</${node.tag}>`)\r\n  }\r\n}\r\n","import {\r\n  AttributeNode,\r\n  buildProps,\r\n  ComponentNode,\r\n  createCallExpression,\r\n  DirectiveNode,\r\n  findProp,\r\n  JSChildNode,\r\n  NodeTypes,\r\n  TransformContext\r\n} from '@vue/compiler-dom'\r\nimport { SSR_RENDER_ATTRS } from '../runtimeHelpers'\r\nimport { processChildren, SSRTransformContext } from '../ssrCodegenTransform'\r\nimport { buildSSRProps } from './ssrTransformElement'\r\n\r\nconst wipMap = new WeakMap<ComponentNode, WIPEntry>()\r\n\r\ninterface WIPEntry {\r\n  tag: AttributeNode | DirectiveNode\r\n  propsExp: string | JSChildNode | null\r\n}\r\n\r\n// phase 1: build props\r\nexport function ssrTransformTransitionGroup(\r\n  node: ComponentNode,\r\n  context: TransformContext\r\n) {\r\n  return () => {\r\n    const tag = findProp(node, 'tag')\r\n    if (tag) {\r\n      const otherProps = node.props.filter(p => p !== tag)\r\n      const { props, directives } = buildProps(\r\n        node,\r\n        context,\r\n        otherProps,\r\n        true, /* isComponent */\r\n        false, /* isDynamicComponent */\r\n        true /* ssr (skip event listeners) */\r\n      )\r\n      let propsExp = null\r\n      if (props || directives.length) {\r\n        propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [\r\n          buildSSRProps(props, directives, context)\r\n        ])\r\n      }\r\n      wipMap.set(node, {\r\n        tag,\r\n        propsExp\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\n// phase 2: process children\r\nexport function ssrProcessTransitionGroup(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext\r\n) {\r\n  const entry = wipMap.get(node)\r\n  if (entry) {\r\n    const { tag, propsExp } = entry\r\n    if (tag.type === NodeTypes.DIRECTIVE) {\r\n      // dynamic :tag\r\n      context.pushStringPart(`<`)\r\n      context.pushStringPart(tag.exp!)\r\n      if (propsExp) {\r\n        context.pushStringPart(propsExp)\r\n      }\r\n      context.pushStringPart(`>`)\r\n\r\n      processChildren(\r\n        node,\r\n        context,\r\n        false,\r\n        /**\r\n         * TransitionGroup has the special runtime behavior of flattening and\r\n         * concatenating all children into a single fragment (in order for them to\r\n         * be patched using the same key map) so we need to account for that here\r\n         * by disabling nested fragment wrappers from being generated.\r\n         */\r\n        true\r\n      )\r\n      context.pushStringPart(`</`)\r\n      context.pushStringPart(tag.exp!)\r\n      context.pushStringPart(`>`)\r\n    } else {\r\n      // static tag\r\n      context.pushStringPart(`<${tag.value!.content}`)\r\n      if (propsExp) {\r\n        context.pushStringPart(propsExp)\r\n      }\r\n      context.pushStringPart(`>`)\r\n      processChildren(node, context, false, true)\r\n      context.pushStringPart(`</${tag.value!.content}>`)\r\n    }\r\n  } else {\r\n    // fragment\r\n    processChildren(node, context, true, true)\r\n  }\r\n}\r\n","import {\r\n  NodeTransform,\r\n  NodeTypes,\r\n  ElementTypes,\r\n  createCallExpression,\r\n  resolveComponentType,\r\n  buildProps,\r\n  ComponentNode,\r\n  SlotFnBuilder,\r\n  createFunctionExpression,\r\n  buildSlots,\r\n  FunctionExpression,\r\n  TemplateChildNode,\r\n  createIfStatement,\r\n  createSimpleExpression,\r\n  getBaseTransformPreset,\r\n  DOMNodeTransforms,\r\n  DOMDirectiveTransforms,\r\n  createReturnStatement,\r\n  ReturnStatement,\r\n  Namespaces,\r\n  locStub,\r\n  RootNode,\r\n  TransformContext,\r\n  CompilerOptions,\r\n  TransformOptions,\r\n  createRoot,\r\n  createTransformContext,\r\n  traverseNode,\r\n  ExpressionNode,\r\n  TemplateNode,\r\n  SUSPENSE,\r\n  TELEPORT,\r\n  TRANSITION_GROUP,\r\n  CREATE_VNODE,\r\n  CallExpression,\r\n  JSChildNode,\r\n  RESOLVE_DYNAMIC_COMPONENT,\r\n  TRANSITION\r\n} from '@vue/compiler-dom'\r\nimport { SSR_RENDER_COMPONENT, SSR_RENDER_VNODE } from '../runtimeHelpers'\r\nimport {\r\n  SSRTransformContext,\r\n  processChildren,\r\n  processChildrenAsStatement\r\n} from '../ssrCodegenTransform'\r\nimport { ssrProcessTeleport } from './ssrTransformTeleport'\r\nimport {\r\n  ssrProcessSuspense,\r\n  ssrTransformSuspense\r\n} from './ssrTransformSuspense'\r\nimport {\r\n  ssrProcessTransitionGroup,\r\n  ssrTransformTransitionGroup\r\n} from './ssrTransformTransitionGroup'\r\nimport { isSymbol, isObject, isArray } from '@vue/shared'\r\nimport { buildSSRProps } from './ssrTransformElement'\r\n\r\n// We need to construct the slot functions in the 1st pass to ensure proper\r\n// scope tracking, but the children of each slot cannot be processed until\r\n// the 2nd pass, so we store the WIP slot functions in a weakMap during the 1st\r\n// pass and complete them in the 2nd pass.\r\nconst wipMap = new WeakMap<ComponentNode, WIPSlotEntry[]>()\r\n\r\nconst WIP_SLOT = Symbol()\r\n\r\ninterface WIPSlotEntry {\r\n  type: typeof WIP_SLOT\r\n  fn: FunctionExpression\r\n  children: TemplateChildNode[]\r\n  vnodeBranch: ReturnStatement\r\n}\r\n\r\nconst componentTypeMap = new WeakMap<\r\n  ComponentNode,\r\n  string | symbol | CallExpression\r\n>()\r\n\r\n// ssr component transform is done in two phases:\r\n// In phase 1. we use `buildSlot` to analyze the children of the component into\r\n// WIP slot functions (it must be done in phase 1 because `buildSlot` relies on\r\n// the core transform context).\r\n// In phase 2. we convert the WIP slots from phase 1 into ssr-specific codegen\r\n// nodes.\r\nexport const ssrTransformComponent: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type !== NodeTypes.ELEMENT ||\r\n    node.tagType !== ElementTypes.COMPONENT\r\n  ) {\r\n    return\r\n  }\r\n\r\n  const component = resolveComponentType(node, context, true /* ssr */)\r\n  const isDynamicComponent =\r\n    isObject(component) && component.callee === RESOLVE_DYNAMIC_COMPONENT\r\n  componentTypeMap.set(node, component)\r\n\r\n  if (isSymbol(component)) {\r\n    if (component === SUSPENSE) {\r\n      return ssrTransformSuspense(node, context)\r\n    }\r\n    if (component === TRANSITION_GROUP) {\r\n      return ssrTransformTransitionGroup(node, context)\r\n    }\r\n    return // other built-in components: fallthrough\r\n  }\r\n\r\n  // Build the fallback vnode-based branch for the component's slots.\r\n  // We need to clone the node into a fresh copy and use the buildSlots' logic\r\n  // to get access to the children of each slot. We then compile them with\r\n  // a child transform pipeline using vnode-based transforms (instead of ssr-\r\n  // based ones), and save the result branch (a ReturnStatement) in an array.\r\n  // The branch is retrieved when processing slots again in ssr mode.\r\n  const vnodeBranches: ReturnStatement[] = []\r\n  const clonedNode = clone(node)\r\n\r\n  return function ssrPostTransformComponent() {\r\n    // Using the cloned node, build the normal VNode-based branches (for\r\n    // fallback in case the child is render-fn based). Store them in an array\r\n    // for later use.\r\n    if (clonedNode.children.length) {\r\n      buildSlots(clonedNode, context, (props, children) => {\r\n        vnodeBranches.push(createVNodeSlotBranch(props, children, context))\r\n        return createFunctionExpression(undefined)\r\n      })\r\n    }\r\n\r\n    let propsExp: string | JSChildNode = `null`\r\n    if (node.props.length) {\r\n      // note we are not passing ssr: true here because for components, v-on\r\n      // handlers should still be passed\r\n      const { props, directives } = buildProps(\r\n        node,\r\n        context,\r\n        undefined,\r\n        true,\r\n        isDynamicComponent\r\n      )\r\n      if (props || directives.length) {\r\n        propsExp = buildSSRProps(props, directives, context)\r\n      }\r\n    }\r\n\r\n    const wipEntries: WIPSlotEntry[] = []\r\n    wipMap.set(node, wipEntries)\r\n\r\n    const buildSSRSlotFn: SlotFnBuilder = (props, children, loc) => {\r\n      const fn = createFunctionExpression(\r\n        [props || `_`, `_push`, `_parent`, `_scopeId`],\r\n        undefined, // no return, assign body later\r\n        true, // newline\r\n        true, // isSlot\r\n        loc\r\n      )\r\n      wipEntries.push({\r\n        type: WIP_SLOT,\r\n        fn,\r\n        children,\r\n        // also collect the corresponding vnode branch built earlier\r\n        vnodeBranch: vnodeBranches[wipEntries.length]\r\n      })\r\n      return fn\r\n    }\r\n\r\n    const slots = node.children.length\r\n      ? buildSlots(node, context, buildSSRSlotFn).slots\r\n      : `null`\r\n\r\n    if (typeof component !== 'string') {\r\n      // dynamic component that resolved to a `resolveDynamicComponent` call\r\n      // expression - since the resolved result may be a plain element (string)\r\n      // or a VNode, handle it with `renderVNode`.\r\n      node.ssrCodegenNode = createCallExpression(\r\n        context.helper(SSR_RENDER_VNODE),\r\n        [\r\n          `_push`,\r\n          createCallExpression(context.helper(CREATE_VNODE), [\r\n            component,\r\n            propsExp,\r\n            slots\r\n          ]),\r\n          `_parent`\r\n        ]\r\n      )\r\n    } else {\r\n      node.ssrCodegenNode = createCallExpression(\r\n        context.helper(SSR_RENDER_COMPONENT),\r\n        [component, propsExp, slots, `_parent`]\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\nexport function ssrProcessComponent(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext,\r\n  parent: { children: TemplateChildNode[] }\r\n) {\r\n  const component = componentTypeMap.get(node)!\r\n  if (!node.ssrCodegenNode) {\r\n    // this is a built-in component that fell-through.\r\n    if (component === TELEPORT) {\r\n      return ssrProcessTeleport(node, context)\r\n    } else if (component === SUSPENSE) {\r\n      return ssrProcessSuspense(node, context)\r\n    } else if (component === TRANSITION_GROUP) {\r\n      return ssrProcessTransitionGroup(node, context)\r\n    } else {\r\n      // real fall-through: Transition / KeepAlive\r\n      // just render its children.\r\n      // #5352: if is at root level of a slot, push an empty string.\r\n      // this does not affect the final output, but avoids all-comment slot\r\n      // content of being treated as empty by ssrRenderSlot().\r\n      if ((parent as WIPSlotEntry).type === WIP_SLOT) {\r\n        context.pushStringPart(``)\r\n      }\r\n      // #5351: filter out comment children inside transition\r\n      if (component === TRANSITION) {\r\n        node.children = node.children.filter(c => c.type !== NodeTypes.COMMENT)\r\n      }\r\n      processChildren(node, context)\r\n    }\r\n  } else {\r\n    // finish up slot function expressions from the 1st pass.\r\n    const wipEntries = wipMap.get(node) || []\r\n    for (let i = 0; i < wipEntries.length; i++) {\r\n      const { fn, vnodeBranch } = wipEntries[i]\r\n      // For each slot, we generate two branches: one SSR-optimized branch and\r\n      // one normal vnode-based branch. The branches are taken based on the\r\n      // presence of the 2nd `_push` argument (which is only present if the slot\r\n      // is called by `_ssrRenderSlot`.\r\n      fn.body = createIfStatement(\r\n        createSimpleExpression(`_push`, false),\r\n        processChildrenAsStatement(\r\n          wipEntries[i],\r\n          context,\r\n          false,\r\n          true /* withSlotScopeId */\r\n        ),\r\n        vnodeBranch\r\n      )\r\n    }\r\n\r\n    // component is inside a slot, inherit slot scope Id\r\n    if (context.withSlotScopeId) {\r\n      node.ssrCodegenNode.arguments.push(`_scopeId`)\r\n    }\r\n\r\n    if (typeof component === 'string') {\r\n      // static component\r\n      context.pushStatement(\r\n        createCallExpression(`_push`, [node.ssrCodegenNode])\r\n      )\r\n    } else {\r\n      // dynamic component (`resolveDynamicComponent` call)\r\n      // the codegen node is a `renderVNode` call\r\n      context.pushStatement(node.ssrCodegenNode)\r\n    }\r\n  }\r\n}\r\n\r\nexport const rawOptionsMap = new WeakMap<RootNode, CompilerOptions>()\r\n\r\nconst [baseNodeTransforms, baseDirectiveTransforms] =\r\n  getBaseTransformPreset(true)\r\nconst vnodeNodeTransforms = [...baseNodeTransforms, ...DOMNodeTransforms]\r\nconst vnodeDirectiveTransforms = {\r\n  ...baseDirectiveTransforms,\r\n  ...DOMDirectiveTransforms\r\n}\r\n\r\nfunction createVNodeSlotBranch(\r\n  props: ExpressionNode | undefined,\r\n  children: TemplateChildNode[],\r\n  parentContext: TransformContext\r\n): ReturnStatement {\r\n  // apply a sub-transform using vnode-based transforms.\r\n  const rawOptions = rawOptionsMap.get(parentContext.root)!\r\n\r\n  const subOptions = {\r\n    ...rawOptions,\r\n    // overwrite with vnode-based transforms\r\n    nodeTransforms: [\r\n      ...vnodeNodeTransforms,\r\n      ...(rawOptions.nodeTransforms || [])\r\n    ],\r\n    directiveTransforms: {\r\n      ...vnodeDirectiveTransforms,\r\n      ...(rawOptions.directiveTransforms || {})\r\n    }\r\n  }\r\n\r\n  // wrap the children with a wrapper template for proper children treatment.\r\n  const wrapperNode: TemplateNode = {\r\n    type: NodeTypes.ELEMENT,\r\n    ns: Namespaces.HTML,\r\n    tag: 'template',\r\n    tagType: ElementTypes.TEMPLATE,\r\n    isSelfClosing: false,\r\n    // important: provide v-slot=\"props\" on the wrapper for proper\r\n    // scope analysis\r\n    props: [\r\n      {\r\n        type: NodeTypes.DIRECTIVE,\r\n        name: 'slot',\r\n        exp: props,\r\n        arg: undefined,\r\n        modifiers: [],\r\n        loc: locStub\r\n      }\r\n    ],\r\n    children,\r\n    loc: locStub,\r\n    codegenNode: undefined\r\n  }\r\n  subTransform(wrapperNode, subOptions, parentContext)\r\n  return createReturnStatement(children)\r\n}\r\n\r\nfunction subTransform(\r\n  node: TemplateChildNode,\r\n  options: TransformOptions,\r\n  parentContext: TransformContext\r\n) {\r\n  const childRoot = createRoot([node])\r\n  const childContext = createTransformContext(childRoot, options)\r\n  // this sub transform is for vnode fallback branch so it should be handled\r\n  // like normal render functions\r\n  childContext.ssr = false\r\n  // inherit parent scope analysis state\r\n  childContext.scopes = { ...parentContext.scopes }\r\n  childContext.identifiers = { ...parentContext.identifiers }\r\n  childContext.imports = parentContext.imports\r\n  // traverse\r\n  traverseNode(childRoot, childContext)\r\n  // merge helpers/components/directives into parent context\r\n  ;(['helpers', 'components', 'directives'] as const).forEach(key => {\r\n    childContext[key].forEach((value: any, helperKey: any) => {\r\n      if (key === 'helpers') {\r\n        const parentCount = parentContext.helpers.get(helperKey)\r\n        if (parentCount === undefined) {\r\n          parentContext.helpers.set(helperKey, value)\r\n        } else {\r\n          parentContext.helpers.set(helperKey, value + parentCount)\r\n        }\r\n      } else {\r\n        ;(parentContext[key] as any).add(value)\r\n      }\r\n    })\r\n  })\r\n  // imports/hoists are not merged because:\r\n  // - imports are only used for asset urls and should be consistent between\r\n  //   node/client branches\r\n  // - hoists are not enabled for the client branch here\r\n}\r\n\r\nfunction clone(v: any): any {\r\n  if (isArray(v)) {\r\n    return v.map(clone)\r\n  } else if (isObject(v)) {\r\n    const res: any = {}\r\n    for (const key in v) {\r\n      res[key] = clone(v[key])\r\n    }\r\n    return res\r\n  } else {\r\n    return v\r\n  }\r\n}\r\n","import {\r\n  RootNode,\r\n  BlockStatement,\r\n  TemplateLiteral,\r\n  createCallExpression,\r\n  createTemplateLiteral,\r\n  NodeTypes,\r\n  TemplateChildNode,\r\n  ElementTypes,\r\n  createBlockStatement,\r\n  CompilerOptions,\r\n  IfStatement,\r\n  CallExpression,\r\n  isText,\r\n  processExpression,\r\n  createSimpleExpression,\r\n  createCompoundExpression,\r\n  createTransformContext,\r\n  createRoot\r\n} from '@vue/compiler-dom'\r\nimport { isString, escapeHtml } from '@vue/shared'\r\nimport { SSR_INTERPOLATE, ssrHelpers } from './runtimeHelpers'\r\nimport { ssrProcessIf } from './transforms/ssrVIf'\r\nimport { ssrProcessFor } from './transforms/ssrVFor'\r\nimport { ssrProcessSlotOutlet } from './transforms/ssrTransformSlotOutlet'\r\nimport { ssrProcessComponent } from './transforms/ssrTransformComponent'\r\nimport { ssrProcessElement } from './transforms/ssrTransformElement'\r\nimport { createSSRCompilerError, SSRErrorCodes } from './errors'\r\n\r\n// Because SSR codegen output is completely different from client-side output\r\n// (e.g. multiple elements can be concatenated into a single template literal\r\n// instead of each getting a corresponding call), we need to apply an extra\r\n// transform pass to convert the template AST into a fresh JS AST before\r\n// passing it to codegen.\r\n\r\nexport function ssrCodegenTransform(ast: RootNode, options: CompilerOptions) {\r\n  const context = createSSRTransformContext(ast, options)\r\n\r\n  // inject SFC <style> CSS variables\r\n  // we do this instead of inlining the expression to ensure the vars are\r\n  // only resolved once per render\r\n  if (options.ssrCssVars) {\r\n    const varsExp = processExpression(\r\n      createSimpleExpression(options.ssrCssVars, false),\r\n      createTransformContext(createRoot([]), options)\r\n    )\r\n    context.body.push(\r\n      createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`])\r\n    )\r\n  }\r\n\r\n  const isFragment =\r\n    ast.children.length > 1 && ast.children.some(c => !isText(c))\r\n  processChildren(ast, context, isFragment)\r\n  ast.codegenNode = createBlockStatement(context.body)\r\n\r\n  // Finalize helpers.\r\n  // We need to separate helpers imported from 'vue' vs. '@vue/server-renderer'\r\n  ast.ssrHelpers = Array.from(\r\n    new Set([...ast.helpers.filter(h => h in ssrHelpers), ...context.helpers])\r\n  )\r\n\r\n  ast.helpers = ast.helpers.filter(h => !(h in ssrHelpers))\r\n}\r\n\r\nexport type SSRTransformContext = ReturnType<typeof createSSRTransformContext>\r\n\r\nfunction createSSRTransformContext(\r\n  root: RootNode,\r\n  options: CompilerOptions,\r\n  helpers: Set<symbol> = new Set(),\r\n  withSlotScopeId = false\r\n) {\r\n  const body: BlockStatement['body'] = []\r\n  let currentString: TemplateLiteral | null = null\r\n\r\n  return {\r\n    root,\r\n    options,\r\n    body,\r\n    helpers,\r\n    withSlotScopeId,\r\n    onError:\r\n      options.onError ||\r\n      (e => {\r\n        throw e\r\n      }),\r\n    helper<T extends symbol>(name: T): T {\r\n      helpers.add(name)\r\n      return name\r\n    },\r\n    pushStringPart(part: TemplateLiteral['elements'][0]) {\r\n      if (!currentString) {\r\n        const currentCall = createCallExpression(`_push`)\r\n        body.push(currentCall)\r\n        currentString = createTemplateLiteral([])\r\n        currentCall.arguments.push(currentString)\r\n      }\r\n      const bufferedElements = currentString.elements\r\n      const lastItem = bufferedElements[bufferedElements.length - 1]\r\n      if (isString(part) && isString(lastItem)) {\r\n        bufferedElements[bufferedElements.length - 1] += part\r\n      } else {\r\n        bufferedElements.push(part)\r\n      }\r\n    },\r\n    pushStatement(statement: IfStatement | CallExpression) {\r\n      // close current string\r\n      currentString = null\r\n      body.push(statement)\r\n    }\r\n  }\r\n}\r\n\r\nfunction createChildContext(\r\n  parent: SSRTransformContext,\r\n  withSlotScopeId = parent.withSlotScopeId\r\n): SSRTransformContext {\r\n  // ensure child inherits parent helpers\r\n  return createSSRTransformContext(\r\n    parent.root,\r\n    parent.options,\r\n    parent.helpers,\r\n    withSlotScopeId\r\n  )\r\n}\r\n\r\ninterface Container {\r\n  children: TemplateChildNode[]\r\n}\r\n\r\nexport function processChildren(\r\n  parent: Container,\r\n  context: SSRTransformContext,\r\n  asFragment = false,\r\n  disableNestedFragments = false\r\n) {\r\n  if (asFragment) {\r\n    context.pushStringPart(`<!--[-->`)\r\n  }\r\n  const { children } = parent\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    switch (child.type) {\r\n      case NodeTypes.ELEMENT:\r\n        switch (child.tagType) {\r\n          case ElementTypes.ELEMENT:\r\n            ssrProcessElement(child, context)\r\n            break\r\n          case ElementTypes.COMPONENT:\r\n            ssrProcessComponent(child, context, parent)\r\n            break\r\n          case ElementTypes.SLOT:\r\n            ssrProcessSlotOutlet(child, context)\r\n            break\r\n          case ElementTypes.TEMPLATE:\r\n            // TODO\r\n            break\r\n          default:\r\n            context.onError(\r\n              createSSRCompilerError(\r\n                SSRErrorCodes.X_SSR_INVALID_AST_NODE,\r\n                (child as any).loc\r\n              )\r\n            )\r\n            // make sure we exhaust all possible types\r\n            const exhaustiveCheck: never = child\r\n            return exhaustiveCheck\r\n        }\r\n        break\r\n      case NodeTypes.TEXT:\r\n        context.pushStringPart(escapeHtml(child.content))\r\n        break\r\n      case NodeTypes.COMMENT:\r\n        // no need to escape comment here because the AST can only\r\n        // contain valid comments.\r\n        context.pushStringPart(`<!--${child.content}-->`)\r\n        break\r\n      case NodeTypes.INTERPOLATION:\r\n        context.pushStringPart(\r\n          createCallExpression(context.helper(SSR_INTERPOLATE), [child.content])\r\n        )\r\n        break\r\n      case NodeTypes.IF:\r\n        ssrProcessIf(child, context, disableNestedFragments)\r\n        break\r\n      case NodeTypes.FOR:\r\n        ssrProcessFor(child, context, disableNestedFragments)\r\n        break\r\n      case NodeTypes.IF_BRANCH:\r\n        // no-op - handled by ssrProcessIf\r\n        break\r\n      case NodeTypes.TEXT_CALL:\r\n      case NodeTypes.COMPOUND_EXPRESSION:\r\n        // no-op - these two types can never appear as template child node since\r\n        // `transformText` is not used during SSR compile.\r\n        break\r\n      default:\r\n        context.onError(\r\n          createSSRCompilerError(\r\n            SSRErrorCodes.X_SSR_INVALID_AST_NODE,\r\n            (child as any).loc\r\n          )\r\n        )\r\n        // make sure we exhaust all possible types\r\n        const exhaustiveCheck: never = child\r\n        return exhaustiveCheck\r\n    }\r\n  }\r\n  if (asFragment) {\r\n    context.pushStringPart(`<!--]-->`)\r\n  }\r\n}\r\n\r\nexport function processChildrenAsStatement(\r\n  parent: Container,\r\n  parentContext: SSRTransformContext,\r\n  asFragment = false,\r\n  withSlotScopeId = parentContext.withSlotScopeId\r\n): BlockStatement {\r\n  const childContext = createChildContext(parentContext, withSlotScopeId)\r\n  processChildren(parent, childContext, asFragment)\r\n  return createBlockStatement(childContext.body)\r\n}\r\n","import {\r\n  DirectiveTransform,\r\n  ElementTypes,\r\n  transformModel,\r\n  findProp,\r\n  NodeTypes,\r\n  createDOMCompilerError,\r\n  DOMErrorCodes,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createCallExpression,\r\n  PlainElementNode,\r\n  ExpressionNode,\r\n  createConditionalExpression,\r\n  createInterpolation,\r\n  hasDynamicKeyVBind\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  SSR_LOOSE_EQUAL,\r\n  SSR_LOOSE_CONTAIN,\r\n  SSR_RENDER_DYNAMIC_MODEL\r\n} from '../runtimeHelpers'\r\nimport { DirectiveTransformResult } from 'packages/compiler-core/src/transform'\r\n\r\nexport const ssrTransformModel: DirectiveTransform = (dir, node, context) => {\r\n  const model = dir.exp!\r\n\r\n  function checkDuplicatedValue() {\r\n    const value = findProp(node, 'value')\r\n    if (value) {\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\r\n          value.loc\r\n        )\r\n      )\r\n    }\r\n  }\r\n\r\n  if (node.tagType === ElementTypes.ELEMENT) {\r\n    const res: DirectiveTransformResult = { props: [] }\r\n    const defaultProps = [\r\n      // default value binding for text type inputs\r\n      createObjectProperty(`value`, model)\r\n    ]\r\n    if (node.tag === 'input') {\r\n      const type = findProp(node, 'type')\r\n      if (type) {\r\n        const value = findValueBinding(node)\r\n        if (type.type === NodeTypes.DIRECTIVE) {\r\n          // dynamic type\r\n          res.ssrTagParts = [\r\n            createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [\r\n              type.exp!,\r\n              model,\r\n              value\r\n            ])\r\n          ]\r\n        } else if (type.value) {\r\n          // static type\r\n          switch (type.value.content) {\r\n            case 'radio':\r\n              res.props = [\r\n                createObjectProperty(\r\n                  `checked`,\r\n                  createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\r\n                    model,\r\n                    value\r\n                  ])\r\n                )\r\n              ]\r\n              break\r\n            case 'checkbox':\r\n              const trueValueBinding = findProp(node, 'true-value')\r\n              if (trueValueBinding) {\r\n                const trueValue =\r\n                  trueValueBinding.type === NodeTypes.ATTRIBUTE\r\n                    ? JSON.stringify(trueValueBinding.value!.content)\r\n                    : trueValueBinding.exp!\r\n                res.props = [\r\n                  createObjectProperty(\r\n                    `checked`,\r\n                    createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\r\n                      model,\r\n                      trueValue\r\n                    ])\r\n                  )\r\n                ]\r\n              } else {\r\n                res.props = [\r\n                  createObjectProperty(\r\n                    `checked`,\r\n                    createConditionalExpression(\r\n                      createCallExpression(`Array.isArray`, [model]),\r\n                      createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\r\n                        model,\r\n                        value\r\n                      ]),\r\n                      model\r\n                    )\r\n                  )\r\n                ]\r\n              }\r\n              break\r\n            case 'file':\r\n              context.onError(\r\n                createDOMCompilerError(\r\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n                  dir.loc\r\n                )\r\n              )\r\n              break\r\n            default:\r\n              checkDuplicatedValue()\r\n              res.props = defaultProps\r\n              break\r\n          }\r\n        }\r\n      } else if (hasDynamicKeyVBind(node)) {\r\n        // dynamic type due to dynamic v-bind\r\n        // NOOP, handled in ssrTransformElement due to need to rewrite\r\n        // the entire props expression\r\n      } else {\r\n        // text type\r\n        checkDuplicatedValue()\r\n        res.props = defaultProps\r\n      }\r\n    } else if (node.tag === 'textarea') {\r\n      checkDuplicatedValue()\r\n      node.children = [createInterpolation(model, model.loc)]\r\n    } else if (node.tag === 'select') {\r\n      // NOOP\r\n      // select relies on client-side directive to set initial selected state.\r\n    } else {\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\r\n          dir.loc\r\n        )\r\n      )\r\n    }\r\n\r\n    return res\r\n  } else {\r\n    // component v-model\r\n    return transformModel(dir, node, context)\r\n  }\r\n}\r\n\r\nfunction findValueBinding(node: PlainElementNode): ExpressionNode {\r\n  const valueBinding = findProp(node, 'value')\r\n  return valueBinding\r\n    ? valueBinding.type === NodeTypes.DIRECTIVE\r\n      ? valueBinding.exp!\r\n      : createSimpleExpression(valueBinding.value!.content, true)\r\n    : createSimpleExpression(`null`, false)\r\n}\r\n","import {\r\n  DirectiveTransform,\r\n  DOMErrorCodes,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createConditionalExpression,\r\n  createObjectExpression,\r\n  createDOMCompilerError\r\n} from '@vue/compiler-dom'\r\n\r\nexport const ssrTransformShow: DirectiveTransform = (dir, node, context) => {\r\n  if (!dir.exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION)\r\n    )\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        `style`,\r\n        createConditionalExpression(\r\n          dir.exp!,\r\n          createSimpleExpression(`null`, false),\r\n          createObjectExpression([\r\n            createObjectProperty(\r\n              `display`,\r\n              createSimpleExpression(`none`, true)\r\n            )\r\n          ]),\r\n          false /* no newline */\r\n        )\r\n      )\r\n    ]\r\n  }\r\n}\r\n","import {\r\n  NodeTransform,\r\n  NodeTypes,\r\n  ElementTypes,\r\n  locStub,\r\n  createSimpleExpression,\r\n  RootNode,\r\n  TemplateChildNode,\r\n  ParentNode,\r\n  findDir,\r\n  isBuiltInType\r\n} from '@vue/compiler-dom'\r\n\r\nconst filterChild = (node: ParentNode) =>\r\n  node.children.filter(n => n.type !== NodeTypes.COMMENT)\r\n\r\nconst hasSingleChild = (node: ParentNode): boolean =>\r\n  filterChild(node).length === 1\r\n\r\nexport const ssrInjectFallthroughAttrs: NodeTransform = (node, context) => {\r\n  // _attrs is provided as a function argument.\r\n  // mark it as a known identifier so that it doesn't get prefixed by\r\n  // transformExpression.\r\n  if (node.type === NodeTypes.ROOT) {\r\n    context.identifiers._attrs = 1\r\n  }\r\n\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.COMPONENT &&\r\n    (isBuiltInType(node.tag, 'Transition') ||\r\n      isBuiltInType(node.tag, 'KeepAlive'))\r\n  ) {\r\n    const rootChildren = filterChild(context.root)\r\n    if (rootChildren.length === 1 && rootChildren[0] === node) {\r\n      if (hasSingleChild(node)) {\r\n        injectFallthroughAttrs(node.children[0])\r\n      }\r\n      return\r\n    }\r\n  }\r\n\r\n  const parent = context.parent\r\n  if (!parent || parent.type !== NodeTypes.ROOT) {\r\n    return\r\n  }\r\n\r\n  if (node.type === NodeTypes.IF_BRANCH && hasSingleChild(node)) {\r\n    // detect cases where the parent v-if is not the only root level node\r\n    let hasEncounteredIf = false\r\n    for (const c of filterChild(parent)) {\r\n      if (\r\n        c.type === NodeTypes.IF ||\r\n        (c.type === NodeTypes.ELEMENT && findDir(c, 'if'))\r\n      ) {\r\n        // multiple root v-if\r\n        if (hasEncounteredIf) return\r\n        hasEncounteredIf = true\r\n      } else if (\r\n        // node before v-if\r\n        !hasEncounteredIf ||\r\n        // non else nodes\r\n        !(c.type === NodeTypes.ELEMENT && findDir(c, /else/, true))\r\n      ) {\r\n        return\r\n      }\r\n    }\r\n    injectFallthroughAttrs(node.children[0])\r\n  } else if (hasSingleChild(parent)) {\r\n    injectFallthroughAttrs(node)\r\n  }\r\n}\r\n\r\nfunction injectFallthroughAttrs(node: RootNode | TemplateChildNode) {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    (node.tagType === ElementTypes.ELEMENT ||\r\n      node.tagType === ElementTypes.COMPONENT) &&\r\n    !findDir(node, 'for')\r\n  ) {\r\n    node.props.push({\r\n      type: NodeTypes.DIRECTIVE,\r\n      name: 'bind',\r\n      arg: undefined,\r\n      exp: createSimpleExpression(`_attrs`, false),\r\n      modifiers: [],\r\n      loc: locStub\r\n    })\r\n  }\r\n}\r\n","import {\r\n  NodeTransform,\r\n  NodeTypes,\r\n  ElementTypes,\r\n  locStub,\r\n  createSimpleExpression,\r\n  RootNode,\r\n  TemplateChildNode,\r\n  findDir,\r\n  isBuiltInType\r\n} from '@vue/compiler-dom'\r\n\r\nexport const ssrInjectCssVars: NodeTransform = (node, context) => {\r\n  if (!context.ssrCssVars) {\r\n    return\r\n  }\r\n\r\n  // _cssVars is initialized once per render function\r\n  // the code is injected in ssrCodegenTransform when creating the\r\n  // ssr transform context\r\n  if (node.type === NodeTypes.ROOT) {\r\n    context.identifiers._cssVars = 1\r\n  }\r\n\r\n  const parent = context.parent\r\n  if (!parent || parent.type !== NodeTypes.ROOT) {\r\n    return\r\n  }\r\n\r\n  if (node.type === NodeTypes.IF_BRANCH) {\r\n    for (const child of node.children) {\r\n      injectCssVars(child)\r\n    }\r\n  } else {\r\n    injectCssVars(node)\r\n  }\r\n}\r\n\r\nfunction injectCssVars(node: RootNode | TemplateChildNode) {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    (node.tagType === ElementTypes.ELEMENT ||\r\n      node.tagType === ElementTypes.COMPONENT) &&\r\n    !findDir(node, 'for')\r\n  ) {\r\n    if (isBuiltInType(node.tag, 'Suspense')) {\r\n      for (const child of node.children) {\r\n        if (\r\n          child.type === NodeTypes.ELEMENT &&\r\n          child.tagType === ElementTypes.TEMPLATE\r\n        ) {\r\n          // suspense slot\r\n          child.children.forEach(injectCssVars)\r\n        } else {\r\n          injectCssVars(child)\r\n        }\r\n      }\r\n    } else {\r\n      node.props.push({\r\n        type: NodeTypes.DIRECTIVE,\r\n        name: 'bind',\r\n        arg: undefined,\r\n        exp: createSimpleExpression(`_cssVars`, false),\r\n        modifiers: [],\r\n        loc: locStub\r\n      })\r\n    }\r\n  }\r\n}\r\n","import {\r\n  CodegenResult,\r\n  baseParse,\r\n  parserOptions,\r\n  transform,\r\n  generate,\r\n  CompilerOptions,\r\n  transformExpression,\r\n  trackVForSlotScopes,\r\n  trackSlotScopes,\r\n  noopDirectiveTransform,\r\n  transformBind,\r\n  transformStyle,\r\n  transformOn\r\n} from '@vue/compiler-dom'\r\nimport { ssrCodegenTransform } from './ssrCodegenTransform'\r\nimport { ssrTransformElement } from './transforms/ssrTransformElement'\r\nimport {\r\n  ssrTransformComponent,\r\n  rawOptionsMap\r\n} from './transforms/ssrTransformComponent'\r\nimport { ssrTransformSlotOutlet } from './transforms/ssrTransformSlotOutlet'\r\nimport { ssrTransformIf } from './transforms/ssrVIf'\r\nimport { ssrTransformFor } from './transforms/ssrVFor'\r\nimport { ssrTransformModel } from './transforms/ssrVModel'\r\nimport { ssrTransformShow } from './transforms/ssrVShow'\r\nimport { ssrInjectFallthroughAttrs } from './transforms/ssrInjectFallthroughAttrs'\r\nimport { ssrInjectCssVars } from './transforms/ssrInjectCssVars'\r\n\r\nexport function compile(\r\n  template: string,\r\n  options: CompilerOptions = {}\r\n): CodegenResult {\r\n  options = {\r\n    ...options,\r\n    // apply DOM-specific parsing options\r\n    ...parserOptions,\r\n    ssr: true,\r\n    inSSR: true,\r\n    scopeId: options.mode === 'function' ? null : options.scopeId,\r\n    // always prefix since compiler-ssr doesn't have size concern\r\n    prefixIdentifiers: true,\r\n    // disable optimizations that are unnecessary for ssr\r\n    cacheHandlers: false,\r\n    hoistStatic: false\r\n  }\r\n\r\n  const ast = baseParse(template, options)\r\n\r\n  // Save raw options for AST. This is needed when performing sub-transforms\r\n  // on slot vnode branches.\r\n  rawOptionsMap.set(ast, options)\r\n\r\n  transform(ast, {\r\n    ...options,\r\n    hoistStatic: false,\r\n    nodeTransforms: [\r\n      ssrTransformIf,\r\n      ssrTransformFor,\r\n      trackVForSlotScopes,\r\n      transformExpression,\r\n      ssrTransformSlotOutlet,\r\n      ssrInjectFallthroughAttrs,\r\n      ssrInjectCssVars,\r\n      ssrTransformElement,\r\n      ssrTransformComponent,\r\n      trackSlotScopes,\r\n      transformStyle,\r\n      ...(options.nodeTransforms || []) // user transforms\r\n    ],\r\n    directiveTransforms: {\r\n      // reusing core v-bind\r\n      bind: transformBind,\r\n      on: transformOn,\r\n      // model and show has dedicated SSR handling\r\n      model: ssrTransformModel,\r\n      show: ssrTransformShow,\r\n      // the following are ignored during SSR\r\n      // on: noopDirectiveTransform,\r\n      cloak: noopDirectiveTransform,\r\n      once: noopDirectiveTransform,\r\n      memo: noopDirectiveTransform,\r\n      ...(options.directiveTransforms || {}) // user transforms\r\n    }\r\n  })\r\n\r\n  // traverse the template AST and convert into SSR codegen AST\r\n  // by replacing ast.codegenNode.\r\n  ssrCodegenTransform(ast, options)\r\n\r\n  return generate(ast, options)\r\n}\r\n"],"names":["registerRuntimeHelpers","createStructuralDirectiveTransform","processIf","createIfStatement","createBlockStatement","createCallExpression","processFor","createFunctionExpression","createForLoopParams","isSlotOutlet","processSlotOutlet","resolveComponentType","TRANSITION","createCompilerError","findProp","createSimpleExpression","buildSlots","hasDynamicKeyVBind","isBuiltInDirective","buildProps","createAssignmentExpression","createConditionalExpression","createSequenceExpression","MERGE_PROPS","createInterpolation","isStaticExp","propsToAttrMap","isBooleanAttr","isSSRSafeAttrName","escapeHtml","createTemplateLiteral","buildDirectiveArgs","isStaticArgOf","createArrayExpression","NO","wipMap","isObject","RESOLVE_DYNAMIC_COMPONENT","isSymbol","SUSPENSE","TRANSITION_GROUP","CREATE_VNODE","TELEPORT","getBaseTransformPreset","DOMNodeTransforms","DOMDirectiveTransforms","locStub","createReturnStatement","createRoot","createTransformContext","traverseNode","isArray","processExpression","createCompoundExpression","isText","isString","createDOMCompilerError","createObjectProperty","transformModel","createObjectExpression","isBuiltInType","findDir","parserOptions","baseParse","transform","trackVForSlotScopes","transformExpression","trackSlotScopes","transformStyle","transformBind","transformOn","noopDirectiveTransform","generate"],"mappings":"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"}