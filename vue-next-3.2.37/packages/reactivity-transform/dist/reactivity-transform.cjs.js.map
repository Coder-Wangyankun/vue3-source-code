{"version":3,"file":"reactivity-transform.cjs.js","sources":["../src/reactivityTransform.ts"],"sourcesContent":["import {\r\n  Node,\r\n  Identifier,\r\n  BlockStatement,\r\n  CallExpression,\r\n  ObjectPattern,\r\n  ArrayPattern,\r\n  Program,\r\n  VariableDeclarator,\r\n  Expression,\r\n  VariableDeclaration\r\n} from '@babel/types'\r\nimport MagicString, { SourceMap } from 'magic-string'\r\nimport { walk } from 'estree-walker'\r\nimport {\r\n  extractIdentifiers,\r\n  isFunctionType,\r\n  isInDestructureAssignment,\r\n  isReferencedIdentifier,\r\n  isStaticProperty,\r\n  walkFunctionParams\r\n} from '@vue/compiler-core'\r\nimport { parse, ParserPlugin } from '@babel/parser'\r\nimport { hasOwn, isArray, isString, genPropsAccessExp } from '@vue/shared'\r\n\r\nconst CONVERT_SYMBOL = '$'\r\nconst ESCAPE_SYMBOL = '$$'\r\nconst shorthands = ['ref', 'computed', 'shallowRef', 'toRef', 'customRef']\r\nconst transformCheckRE = /[^\\w]\\$(?:\\$|ref|computed|shallowRef)?\\s*(\\(|\\<)/\r\n\r\nexport function shouldTransform(src: string): boolean {\r\n  return transformCheckRE.test(src)\r\n}\r\n\r\ntype Scope = Record<string, boolean | 'prop'>\r\n\r\nexport interface RefTransformOptions {\r\n  filename?: string\r\n  sourceMap?: boolean\r\n  parserPlugins?: ParserPlugin[]\r\n  importHelpersFrom?: string\r\n}\r\n\r\nexport interface RefTransformResults {\r\n  code: string\r\n  map: SourceMap | null\r\n  rootRefs: string[]\r\n  importedHelpers: string[]\r\n}\r\n\r\nexport function transform(\r\n  src: string,\r\n  {\r\n    filename,\r\n    sourceMap,\r\n    parserPlugins,\r\n    importHelpersFrom = 'vue'\r\n  }: RefTransformOptions = {}\r\n): RefTransformResults {\r\n  const plugins: ParserPlugin[] = parserPlugins || []\r\n  if (filename) {\r\n    if (/\\.tsx?$/.test(filename)) {\r\n      plugins.push('typescript')\r\n    }\r\n    if (filename.endsWith('x')) {\r\n      plugins.push('jsx')\r\n    }\r\n  }\r\n\r\n  const ast = parse(src, {\r\n    sourceType: 'module',\r\n    plugins\r\n  })\r\n  const s = new MagicString(src)\r\n  const res = transformAST(ast.program, s, 0)\r\n\r\n  // inject helper imports\r\n  if (res.importedHelpers.length) {\r\n    s.prepend(\r\n      `import { ${res.importedHelpers\r\n        .map(h => `${h} as _${h}`)\r\n        .join(', ')} } from '${importHelpersFrom}'\\n`\r\n    )\r\n  }\r\n\r\n  return {\r\n    ...res,\r\n    code: s.toString(),\r\n    map: sourceMap\r\n      ? s.generateMap({\r\n          source: filename,\r\n          hires: true,\r\n          includeContent: true\r\n        })\r\n      : null\r\n  }\r\n}\r\n\r\nexport function transformAST(\r\n  ast: Program,\r\n  s: MagicString,\r\n  offset = 0,\r\n  knownRefs?: string[],\r\n  knownProps?: Record<\r\n    string, // public prop key\r\n    {\r\n      local: string // local identifier, may be different\r\n      default?: any\r\n    }\r\n  >\r\n): {\r\n  rootRefs: string[]\r\n  importedHelpers: string[]\r\n} {\r\n  // TODO remove when out of experimental\r\n  warnExperimental()\r\n\r\n  let convertSymbol = CONVERT_SYMBOL\r\n  let escapeSymbol = ESCAPE_SYMBOL\r\n\r\n  // macro import handling\r\n  for (const node of ast.body) {\r\n    if (\r\n      node.type === 'ImportDeclaration' &&\r\n      node.source.value === 'vue/macros'\r\n    ) {\r\n      // remove macro imports\r\n      s.remove(node.start! + offset, node.end! + offset)\r\n      // check aliasing\r\n      for (const specifier of node.specifiers) {\r\n        if (specifier.type === 'ImportSpecifier') {\r\n          const imported = (specifier.imported as Identifier).name\r\n          const local = specifier.local.name\r\n          if (local !== imported) {\r\n            if (imported === ESCAPE_SYMBOL) {\r\n              escapeSymbol = local\r\n            } else if (imported === CONVERT_SYMBOL) {\r\n              convertSymbol = local\r\n            } else {\r\n              error(\r\n                `macro imports for ref-creating methods do not support aliasing.`,\r\n                specifier\r\n              )\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const importedHelpers = new Set<string>()\r\n  const rootScope: Scope = {}\r\n  const scopeStack: Scope[] = [rootScope]\r\n  let currentScope: Scope = rootScope\r\n  let escapeScope: CallExpression | undefined // inside $$()\r\n  const excludedIds = new WeakSet<Identifier>()\r\n  const parentStack: Node[] = []\r\n  const propsLocalToPublicMap = Object.create(null)\r\n\r\n  if (knownRefs) {\r\n    for (const key of knownRefs) {\r\n      rootScope[key] = true\r\n    }\r\n  }\r\n  if (knownProps) {\r\n    for (const key in knownProps) {\r\n      const { local } = knownProps[key]\r\n      rootScope[local] = 'prop'\r\n      propsLocalToPublicMap[local] = key\r\n    }\r\n  }\r\n\r\n  function isRefCreationCall(callee: string): string | false {\r\n    if (callee === convertSymbol) {\r\n      return convertSymbol\r\n    }\r\n    if (callee[0] === '$' && shorthands.includes(callee.slice(1))) {\r\n      return callee\r\n    }\r\n    return false\r\n  }\r\n\r\n  function error(msg: string, node: Node) {\r\n    const e = new Error(msg)\r\n    ;(e as any).node = node\r\n    throw e\r\n  }\r\n\r\n  function helper(msg: string) {\r\n    importedHelpers.add(msg)\r\n    return `_${msg}`\r\n  }\r\n\r\n  function registerBinding(id: Identifier, isRef = false) {\r\n    excludedIds.add(id)\r\n    if (currentScope) {\r\n      currentScope[id.name] = isRef\r\n    } else {\r\n      error(\r\n        'registerBinding called without active scope, something is wrong.',\r\n        id\r\n      )\r\n    }\r\n  }\r\n\r\n  const registerRefBinding = (id: Identifier) => registerBinding(id, true)\r\n\r\n  let tempVarCount = 0\r\n  function genTempVar() {\r\n    return `__$temp_${++tempVarCount}`\r\n  }\r\n\r\n  function snip(node: Node) {\r\n    return s.original.slice(node.start! + offset, node.end! + offset)\r\n  }\r\n\r\n  function walkScope(node: Program | BlockStatement, isRoot = false) {\r\n    for (const stmt of node.body) {\r\n      if (stmt.type === 'VariableDeclaration') {\r\n        walkVariableDeclaration(stmt, isRoot)\r\n      } else if (\r\n        stmt.type === 'FunctionDeclaration' ||\r\n        stmt.type === 'ClassDeclaration'\r\n      ) {\r\n        if (stmt.declare || !stmt.id) continue\r\n        registerBinding(stmt.id)\r\n      } else if (\r\n        (stmt.type === 'ForOfStatement' || stmt.type === 'ForInStatement') &&\r\n        stmt.left.type === 'VariableDeclaration'\r\n      ) {\r\n        walkVariableDeclaration(stmt.left)\r\n      } else if (\r\n        stmt.type === 'ExportNamedDeclaration' &&\r\n        stmt.declaration &&\r\n        stmt.declaration.type === 'VariableDeclaration'\r\n      ) {\r\n        walkVariableDeclaration(stmt.declaration, isRoot)\r\n      } else if (\r\n        stmt.type === 'LabeledStatement' &&\r\n        stmt.body.type === 'VariableDeclaration'\r\n      ) {\r\n        walkVariableDeclaration(stmt.body, isRoot)\r\n      }\r\n    }\r\n  }\r\n\r\n  function walkVariableDeclaration(stmt: VariableDeclaration, isRoot = false) {\r\n    if (stmt.declare) {\r\n      return\r\n    }\r\n    for (const decl of stmt.declarations) {\r\n      let refCall\r\n      const isCall =\r\n        decl.init &&\r\n        decl.init.type === 'CallExpression' &&\r\n        decl.init.callee.type === 'Identifier'\r\n      if (\r\n        isCall &&\r\n        (refCall = isRefCreationCall((decl as any).init.callee.name))\r\n      ) {\r\n        processRefDeclaration(refCall, decl.id, decl.init as CallExpression)\r\n      } else {\r\n        const isProps =\r\n          isRoot && isCall && (decl as any).init.callee.name === 'defineProps'\r\n        for (const id of extractIdentifiers(decl.id)) {\r\n          if (isProps) {\r\n            // for defineProps destructure, only exclude them since they\r\n            // are already passed in as knownProps\r\n            excludedIds.add(id)\r\n          } else {\r\n            registerBinding(id)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function processRefDeclaration(\r\n    method: string,\r\n    id: VariableDeclarator['id'],\r\n    call: CallExpression\r\n  ) {\r\n    excludedIds.add(call.callee as Identifier)\r\n    if (method === convertSymbol) {\r\n      // $\r\n      // remove macro\r\n      s.remove(call.callee.start! + offset, call.callee.end! + offset)\r\n      if (id.type === 'Identifier') {\r\n        // single variable\r\n        registerRefBinding(id)\r\n      } else if (id.type === 'ObjectPattern') {\r\n        processRefObjectPattern(id, call)\r\n      } else if (id.type === 'ArrayPattern') {\r\n        processRefArrayPattern(id, call)\r\n      }\r\n    } else {\r\n      // shorthands\r\n      if (id.type === 'Identifier') {\r\n        registerRefBinding(id)\r\n        // replace call\r\n        s.overwrite(\r\n          call.start! + offset,\r\n          call.start! + method.length + offset,\r\n          helper(method.slice(1))\r\n        )\r\n      } else {\r\n        error(`${method}() cannot be used with destructure patterns.`, call)\r\n      }\r\n    }\r\n  }\r\n\r\n  function processRefObjectPattern(\r\n    pattern: ObjectPattern,\r\n    call: CallExpression,\r\n    tempVar?: string,\r\n    path: PathSegment[] = []\r\n  ) {\r\n    if (!tempVar) {\r\n      tempVar = genTempVar()\r\n      // const { x } = $(useFoo()) --> const __$temp_1 = useFoo()\r\n      s.overwrite(pattern.start! + offset, pattern.end! + offset, tempVar)\r\n    }\r\n\r\n    for (const p of pattern.properties) {\r\n      let nameId: Identifier | undefined\r\n      let key: Expression | string | undefined\r\n      let defaultValue: Expression | undefined\r\n      if (p.type === 'ObjectProperty') {\r\n        if (p.key.start! === p.value.start!) {\r\n          // shorthand { foo }\r\n          nameId = p.key as Identifier\r\n          if (p.value.type === 'Identifier') {\r\n            // avoid shorthand value identifier from being processed\r\n            excludedIds.add(p.value)\r\n          } else if (\r\n            p.value.type === 'AssignmentPattern' &&\r\n            p.value.left.type === 'Identifier'\r\n          ) {\r\n            // { foo = 1 }\r\n            excludedIds.add(p.value.left)\r\n            defaultValue = p.value.right\r\n          }\r\n        } else {\r\n          key = p.computed ? p.key : (p.key as Identifier).name\r\n          if (p.value.type === 'Identifier') {\r\n            // { foo: bar }\r\n            nameId = p.value\r\n          } else if (p.value.type === 'ObjectPattern') {\r\n            processRefObjectPattern(p.value, call, tempVar, [...path, key])\r\n          } else if (p.value.type === 'ArrayPattern') {\r\n            processRefArrayPattern(p.value, call, tempVar, [...path, key])\r\n          } else if (p.value.type === 'AssignmentPattern') {\r\n            if (p.value.left.type === 'Identifier') {\r\n              // { foo: bar = 1 }\r\n              nameId = p.value.left\r\n              defaultValue = p.value.right\r\n            } else if (p.value.left.type === 'ObjectPattern') {\r\n              processRefObjectPattern(p.value.left, call, tempVar, [\r\n                ...path,\r\n                [key, p.value.right]\r\n              ])\r\n            } else if (p.value.left.type === 'ArrayPattern') {\r\n              processRefArrayPattern(p.value.left, call, tempVar, [\r\n                ...path,\r\n                [key, p.value.right]\r\n              ])\r\n            } else {\r\n              // MemberExpression case is not possible here, ignore\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // rest element { ...foo }\r\n        error(`reactivity destructure does not support rest elements.`, p)\r\n      }\r\n      if (nameId) {\r\n        registerRefBinding(nameId)\r\n        // inject toRef() after original replaced pattern\r\n        const source = pathToString(tempVar, path)\r\n        const keyStr = isString(key)\r\n          ? `'${key}'`\r\n          : key\r\n          ? snip(key)\r\n          : `'${nameId.name}'`\r\n        const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``\r\n        s.appendLeft(\r\n          call.end! + offset,\r\n          `,\\n  ${nameId.name} = ${helper(\r\n            'toRef'\r\n          )}(${source}, ${keyStr}${defaultStr})`\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  function processRefArrayPattern(\r\n    pattern: ArrayPattern,\r\n    call: CallExpression,\r\n    tempVar?: string,\r\n    path: PathSegment[] = []\r\n  ) {\r\n    if (!tempVar) {\r\n      // const [x] = $(useFoo()) --> const __$temp_1 = useFoo()\r\n      tempVar = genTempVar()\r\n      s.overwrite(pattern.start! + offset, pattern.end! + offset, tempVar)\r\n    }\r\n\r\n    for (let i = 0; i < pattern.elements.length; i++) {\r\n      const e = pattern.elements[i]\r\n      if (!e) continue\r\n      let nameId: Identifier | undefined\r\n      let defaultValue: Expression | undefined\r\n      if (e.type === 'Identifier') {\r\n        // [a] --> [__a]\r\n        nameId = e\r\n      } else if (e.type === 'AssignmentPattern') {\r\n        // [a = 1]\r\n        nameId = e.left as Identifier\r\n        defaultValue = e.right\r\n      } else if (e.type === 'RestElement') {\r\n        // [...a]\r\n        error(`reactivity destructure does not support rest elements.`, e)\r\n      } else if (e.type === 'ObjectPattern') {\r\n        processRefObjectPattern(e, call, tempVar, [...path, i])\r\n      } else if (e.type === 'ArrayPattern') {\r\n        processRefArrayPattern(e, call, tempVar, [...path, i])\r\n      }\r\n      if (nameId) {\r\n        registerRefBinding(nameId)\r\n        // inject toRef() after original replaced pattern\r\n        const source = pathToString(tempVar, path)\r\n        const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``\r\n        s.appendLeft(\r\n          call.end! + offset,\r\n          `,\\n  ${nameId.name} = ${helper(\r\n            'toRef'\r\n          )}(${source}, ${i}${defaultStr})`\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  type PathSegmentAtom = Expression | string | number\r\n\r\n  type PathSegment =\r\n    | PathSegmentAtom\r\n    | [PathSegmentAtom, Expression /* default value */]\r\n\r\n  function pathToString(source: string, path: PathSegment[]): string {\r\n    if (path.length) {\r\n      for (const seg of path) {\r\n        if (isArray(seg)) {\r\n          source = `(${source}${segToString(seg[0])} || ${snip(seg[1])})`\r\n        } else {\r\n          source += segToString(seg)\r\n        }\r\n      }\r\n    }\r\n    return source\r\n  }\r\n\r\n  function segToString(seg: PathSegmentAtom): string {\r\n    if (typeof seg === 'number') {\r\n      return `[${seg}]`\r\n    } else if (typeof seg === 'string') {\r\n      return `.${seg}`\r\n    } else {\r\n      return snip(seg)\r\n    }\r\n  }\r\n\r\n  function rewriteId(\r\n    scope: Scope,\r\n    id: Identifier,\r\n    parent: Node,\r\n    parentStack: Node[]\r\n  ): boolean {\r\n    if (hasOwn(scope, id.name)) {\r\n      const bindingType = scope[id.name]\r\n      if (bindingType) {\r\n        const isProp = bindingType === 'prop'\r\n        if (isStaticProperty(parent) && parent.shorthand) {\r\n          // let binding used in a property shorthand\r\n          // skip for destructure patterns\r\n          if (\r\n            !(parent as any).inPattern ||\r\n            isInDestructureAssignment(parent, parentStack)\r\n          ) {\r\n            if (isProp) {\r\n              if (escapeScope) {\r\n                // prop binding in $$()\r\n                // { prop } -> { prop: __props_prop }\r\n                registerEscapedPropBinding(id)\r\n                s.appendLeft(\r\n                  id.end! + offset,\r\n                  `: __props_${propsLocalToPublicMap[id.name]}`\r\n                )\r\n              } else {\r\n                // { prop } -> { prop: __props.prop }\r\n                s.appendLeft(\r\n                  id.end! + offset,\r\n                  `: ${genPropsAccessExp(propsLocalToPublicMap[id.name])}`\r\n                )\r\n              }\r\n            } else {\r\n              // { foo } -> { foo: foo.value }\r\n              s.appendLeft(id.end! + offset, `: ${id.name}.value`)\r\n            }\r\n          }\r\n        } else {\r\n          if (isProp) {\r\n            if (escapeScope) {\r\n              // x --> __props_x\r\n              registerEscapedPropBinding(id)\r\n              s.overwrite(\r\n                id.start! + offset,\r\n                id.end! + offset,\r\n                `__props_${propsLocalToPublicMap[id.name]}`\r\n              )\r\n            } else {\r\n              // x --> __props.x\r\n              s.overwrite(\r\n                id.start! + offset,\r\n                id.end! + offset,\r\n                genPropsAccessExp(propsLocalToPublicMap[id.name])\r\n              )\r\n            }\r\n          } else {\r\n            // x --> x.value\r\n            s.appendLeft(id.end! + offset, '.value')\r\n          }\r\n        }\r\n      }\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  const propBindingRefs: Record<string, true> = {}\r\n  function registerEscapedPropBinding(id: Identifier) {\r\n    if (!propBindingRefs.hasOwnProperty(id.name)) {\r\n      propBindingRefs[id.name] = true\r\n      const publicKey = propsLocalToPublicMap[id.name]\r\n      s.prependRight(\r\n        offset,\r\n        `const __props_${publicKey} = ${helper(\r\n          `toRef`\r\n        )}(__props, '${publicKey}')\\n`\r\n      )\r\n    }\r\n  }\r\n\r\n  // check root scope first\r\n  walkScope(ast, true)\r\n  ;(walk as any)(ast, {\r\n    enter(node: Node, parent?: Node) {\r\n      parent && parentStack.push(parent)\r\n\r\n      // function scopes\r\n      if (isFunctionType(node)) {\r\n        scopeStack.push((currentScope = {}))\r\n        walkFunctionParams(node, registerBinding)\r\n        if (node.body.type === 'BlockStatement') {\r\n          walkScope(node.body)\r\n        }\r\n        return\r\n      }\r\n\r\n      // catch param\r\n      if (node.type === 'CatchClause') {\r\n        scopeStack.push((currentScope = {}))\r\n        if (node.param && node.param.type === 'Identifier') {\r\n          registerBinding(node.param)\r\n        }\r\n        walkScope(node.body)\r\n        return\r\n      }\r\n\r\n      // non-function block scopes\r\n      if (node.type === 'BlockStatement' && !isFunctionType(parent!)) {\r\n        scopeStack.push((currentScope = {}))\r\n        walkScope(node)\r\n        return\r\n      }\r\n\r\n      // skip type nodes\r\n      if (\r\n        parent &&\r\n        parent.type.startsWith('TS') &&\r\n        parent.type !== 'TSAsExpression' &&\r\n        parent.type !== 'TSNonNullExpression' &&\r\n        parent.type !== 'TSTypeAssertion'\r\n      ) {\r\n        return this.skip()\r\n      }\r\n\r\n      if (\r\n        node.type === 'Identifier' &&\r\n        // if inside $$(), skip unless this is a destructured prop binding\r\n        !(escapeScope && rootScope[node.name] !== 'prop') &&\r\n        isReferencedIdentifier(node, parent!, parentStack) &&\r\n        !excludedIds.has(node)\r\n      ) {\r\n        // walk up the scope chain to check if id should be appended .value\r\n        let i = scopeStack.length\r\n        while (i--) {\r\n          if (rewriteId(scopeStack[i], node, parent!, parentStack)) {\r\n            return\r\n          }\r\n        }\r\n      }\r\n\r\n      if (node.type === 'CallExpression' && node.callee.type === 'Identifier') {\r\n        const callee = node.callee.name\r\n\r\n        const refCall = isRefCreationCall(callee)\r\n        if (refCall && (!parent || parent.type !== 'VariableDeclarator')) {\r\n          return error(\r\n            `${refCall} can only be used as the initializer of ` +\r\n              `a variable declaration.`,\r\n            node\r\n          )\r\n        }\r\n\r\n        if (callee === escapeSymbol) {\r\n          s.remove(node.callee.start! + offset, node.callee.end! + offset)\r\n          escapeScope = node\r\n        }\r\n\r\n        // TODO remove when out of experimental\r\n        if (callee === '$raw') {\r\n          error(\r\n            `$raw() has been replaced by $$(). ` +\r\n              `See ${RFC_LINK} for latest updates.`,\r\n            node\r\n          )\r\n        }\r\n        if (callee === '$fromRef') {\r\n          error(\r\n            `$fromRef() has been replaced by $(). ` +\r\n              `See ${RFC_LINK} for latest updates.`,\r\n            node\r\n          )\r\n        }\r\n      }\r\n    },\r\n    leave(node: Node, parent?: Node) {\r\n      parent && parentStack.pop()\r\n      if (\r\n        (node.type === 'BlockStatement' && !isFunctionType(parent!)) ||\r\n        isFunctionType(node)\r\n      ) {\r\n        scopeStack.pop()\r\n        currentScope = scopeStack[scopeStack.length - 1] || null\r\n      }\r\n      if (node === escapeScope) {\r\n        escapeScope = undefined\r\n      }\r\n    }\r\n  })\r\n\r\n  return {\r\n    rootRefs: Object.keys(rootScope).filter(key => rootScope[key] === true),\r\n    importedHelpers: [...importedHelpers]\r\n  }\r\n}\r\n\r\nconst RFC_LINK = `https://github.com/vuejs/rfcs/discussions/369`\r\nconst hasWarned: Record<string, boolean> = {}\r\n\r\nfunction warnExperimental() {\r\n  // eslint-disable-next-line\r\n  if (typeof window !== 'undefined') {\r\n    return\r\n  }\r\n  warnOnce(\r\n    `Reactivity transform is an experimental feature.\\n` +\r\n      `Experimental features may change behavior between patch versions.\\n` +\r\n      `It is recommended to pin your vue dependencies to exact versions to avoid breakage.\\n` +\r\n      `You can follow the proposal's status at ${RFC_LINK}.`\r\n  )\r\n}\r\n\r\nfunction warnOnce(msg: string) {\r\n  const isNodeProd =\r\n    typeof process !== 'undefined' && process.env.NODE_ENV === 'production'\r\n  if (!isNodeProd && !__TEST__ && !hasWarned[msg]) {\r\n    hasWarned[msg] = true\r\n    warn(msg)\r\n  }\r\n}\r\n\r\nfunction warn(msg: string) {\r\n  console.warn(\r\n    `\\x1b[1m\\x1b[33m[@vue/reactivity-transform]\\x1b[0m\\x1b[33m ${msg}\\x1b[0m\\n`\r\n  )\r\n}\r\n"],"names":["parse","MagicString","extractIdentifiers","isString","isArray","hasOwn","isStaticProperty","isInDestructureAssignment","genPropsAccessExp","walk","isFunctionType","walkFunctionParams","isReferencedIdentifier"],"mappings":";;;;;;;;;;;;;;AAyBA,MAAM,cAAc,GAAG,GAAG,CAAA;AAC1B,MAAM,aAAa,GAAG,IAAI,CAAA;AAC1B,MAAM,UAAU,GAAG,CAAC,KAAK,EAAE,UAAU,EAAE,YAAY,EAAE,OAAO,EAAE,WAAW,CAAC,CAAA;AAC1E,MAAM,gBAAgB,GAAG,kDAAkD,CAAA;SAE3D,eAAe,CAAC,GAAW;IACzC,OAAO,gBAAgB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AACnC,CAAC;SAkBe,SAAS,CACvB,GAAW,EACX,EACE,QAAQ,EACR,SAAS,EACT,aAAa,EACb,iBAAiB,GAAG,KAAK,KACF,EAAE;IAE3B,MAAM,OAAO,GAAmB,aAAa,IAAI,EAAE,CAAA;IACnD,IAAI,QAAQ,EAAE;QACZ,IAAI,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAC5B,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;SAC3B;QACD,IAAI,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YAC1B,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;SACpB;KACF;IAED,MAAM,GAAG,GAAGA,YAAK,CAAC,GAAG,EAAE;QACrB,UAAU,EAAE,QAAQ;QACpB,OAAO;KACR,CAAC,CAAA;IACF,MAAM,CAAC,GAAG,IAAIC,oBAAW,CAAC,GAAG,CAAC,CAAA;IAC9B,MAAM,GAAG,GAAG,YAAY,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;;IAG3C,IAAI,GAAG,CAAC,eAAe,CAAC,MAAM,EAAE;QAC9B,CAAC,CAAC,OAAO,CACP,YAAY,GAAG,CAAC,eAAe;aAC5B,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;aACzB,IAAI,CAAC,IAAI,CAAC,YAAY,iBAAiB,KAAK,CAChD,CAAA;KACF;IAED,OAAO;QACL,GAAG,GAAG;QACN,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE;QAClB,GAAG,EAAE,SAAS;cACV,CAAC,CAAC,WAAW,CAAC;gBACZ,MAAM,EAAE,QAAQ;gBAChB,KAAK,EAAE,IAAI;gBACX,cAAc,EAAE,IAAI;aACrB,CAAC;cACF,IAAI;KACT,CAAA;AACH,CAAC;SAEe,YAAY,CAC1B,GAAY,EACZ,CAAc,EACd,MAAM,GAAG,CAAC,EACV,SAAoB,EACpB,UAMC;;IAMD,gBAAgB,EAAE,CAAA;IAElB,IAAI,aAAa,GAAG,cAAc,CAAA;IAClC,IAAI,YAAY,GAAG,aAAa,CAAA;;IAGhC,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,IAAI,EAAE;QAC3B,IACE,IAAI,CAAC,IAAI,KAAK,mBAAmB;YACjC,IAAI,CAAC,MAAM,CAAC,KAAK,KAAK,YAAY,EAClC;;YAEA,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAM,GAAG,MAAM,EAAE,IAAI,CAAC,GAAI,GAAG,MAAM,CAAC,CAAA;;YAElD,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;gBACvC,IAAI,SAAS,CAAC,IAAI,KAAK,iBAAiB,EAAE;oBACxC,MAAM,QAAQ,GAAI,SAAS,CAAC,QAAuB,CAAC,IAAI,CAAA;oBACxD,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,IAAI,CAAA;oBAClC,IAAI,KAAK,KAAK,QAAQ,EAAE;wBACtB,IAAI,QAAQ,KAAK,aAAa,EAAE;4BAC9B,YAAY,GAAG,KAAK,CAAA;yBACrB;6BAAM,IAAI,QAAQ,KAAK,cAAc,EAAE;4BACtC,aAAa,GAAG,KAAK,CAAA;yBACtB;6BAAM;4BACL,KAAK,CACH,iEAAiE,EACjE,SAAS,CACV,CAAA;yBACF;qBACF;iBACF;aACF;SACF;KACF;IAED,MAAM,eAAe,GAAG,IAAI,GAAG,EAAU,CAAA;IACzC,MAAM,SAAS,GAAU,EAAE,CAAA;IAC3B,MAAM,UAAU,GAAY,CAAC,SAAS,CAAC,CAAA;IACvC,IAAI,YAAY,GAAU,SAAS,CAAA;IACnC,IAAI,WAAuC,CAAA;IAC3C,MAAM,WAAW,GAAG,IAAI,OAAO,EAAc,CAAA;IAC7C,MAAM,WAAW,GAAW,EAAE,CAAA;IAC9B,MAAM,qBAAqB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAEjD,IAAI,SAAS,EAAE;QACb,KAAK,MAAM,GAAG,IAAI,SAAS,EAAE;YAC3B,SAAS,CAAC,GAAG,CAAC,GAAG,IAAI,CAAA;SACtB;KACF;IACD,IAAI,UAAU,EAAE;QACd,KAAK,MAAM,GAAG,IAAI,UAAU,EAAE;YAC5B,MAAM,EAAE,KAAK,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,CAAA;YACjC,SAAS,CAAC,KAAK,CAAC,GAAG,MAAM,CAAA;YACzB,qBAAqB,CAAC,KAAK,CAAC,GAAG,GAAG,CAAA;SACnC;KACF;IAED,SAAS,iBAAiB,CAAC,MAAc;QACvC,IAAI,MAAM,KAAK,aAAa,EAAE;YAC5B,OAAO,aAAa,CAAA;SACrB;QACD,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;YAC7D,OAAO,MAAM,CAAA;SACd;QACD,OAAO,KAAK,CAAA;KACb;IAED,SAAS,KAAK,CAAC,GAAW,EAAE,IAAU;QACpC,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,CACvB;QAAC,CAAS,CAAC,IAAI,GAAG,IAAI,CAAA;QACvB,MAAM,CAAC,CAAA;KACR;IAED,SAAS,MAAM,CAAC,GAAW;QACzB,eAAe,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;QACxB,OAAO,IAAI,GAAG,EAAE,CAAA;KACjB;IAED,SAAS,eAAe,CAAC,EAAc,EAAE,KAAK,GAAG,KAAK;QACpD,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;QACnB,IAAI,YAAY,EAAE;YAChB,YAAY,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;SAC9B;aAAM;YACL,KAAK,CACH,kEAAkE,EAClE,EAAE,CACH,CAAA;SACF;KACF;IAED,MAAM,kBAAkB,GAAG,CAAC,EAAc,KAAK,eAAe,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;IAExE,IAAI,YAAY,GAAG,CAAC,CAAA;IACpB,SAAS,UAAU;QACjB,OAAO,WAAW,EAAE,YAAY,EAAE,CAAA;KACnC;IAED,SAAS,IAAI,CAAC,IAAU;QACtB,OAAO,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,KAAM,GAAG,MAAM,EAAE,IAAI,CAAC,GAAI,GAAG,MAAM,CAAC,CAAA;KAClE;IAED,SAAS,SAAS,CAAC,IAA8B,EAAE,MAAM,GAAG,KAAK;QAC/D,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE;YAC5B,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,EAAE;gBACvC,uBAAuB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;aACtC;iBAAM,IACL,IAAI,CAAC,IAAI,KAAK,qBAAqB;gBACnC,IAAI,CAAC,IAAI,KAAK,kBAAkB,EAChC;gBACA,IAAI,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE;oBAAE,SAAQ;gBACtC,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;aACzB;iBAAM,IACL,CAAC,IAAI,CAAC,IAAI,KAAK,gBAAgB,IAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB;gBACjE,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,qBAAqB,EACxC;gBACA,uBAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;aACnC;iBAAM,IACL,IAAI,CAAC,IAAI,KAAK,wBAAwB;gBACtC,IAAI,CAAC,WAAW;gBAChB,IAAI,CAAC,WAAW,CAAC,IAAI,KAAK,qBAAqB,EAC/C;gBACA,uBAAuB,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;aAClD;iBAAM,IACL,IAAI,CAAC,IAAI,KAAK,kBAAkB;gBAChC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,qBAAqB,EACxC;gBACA,uBAAuB,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;aAC3C;SACF;KACF;IAED,SAAS,uBAAuB,CAAC,IAAyB,EAAE,MAAM,GAAG,KAAK;QACxE,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,OAAM;SACP;QACD,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,YAAY,EAAE;YACpC,IAAI,OAAO,CAAA;YACX,MAAM,MAAM,GACV,IAAI,CAAC,IAAI;gBACT,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,gBAAgB;gBACnC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,YAAY,CAAA;YACxC,IACE,MAAM;iBACL,OAAO,GAAG,iBAAiB,CAAE,IAAY,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAC7D;gBACA,qBAAqB,CAAC,OAAO,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,IAAsB,CAAC,CAAA;aACrE;iBAAM;gBACL,MAAM,OAAO,GACX,MAAM,IAAI,MAAM,IAAK,IAAY,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,aAAa,CAAA;gBACtE,KAAK,MAAM,EAAE,IAAIC,+BAAkB,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;oBAC5C,IAAI,OAAO,EAAE;;;wBAGX,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;qBACpB;yBAAM;wBACL,eAAe,CAAC,EAAE,CAAC,CAAA;qBACpB;iBACF;aACF;SACF;KACF;IAED,SAAS,qBAAqB,CAC5B,MAAc,EACd,EAA4B,EAC5B,IAAoB;QAEpB,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,MAAoB,CAAC,CAAA;QAC1C,IAAI,MAAM,KAAK,aAAa,EAAE;;;YAG5B,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAM,GAAG,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAI,GAAG,MAAM,CAAC,CAAA;YAChE,IAAI,EAAE,CAAC,IAAI,KAAK,YAAY,EAAE;;gBAE5B,kBAAkB,CAAC,EAAE,CAAC,CAAA;aACvB;iBAAM,IAAI,EAAE,CAAC,IAAI,KAAK,eAAe,EAAE;gBACtC,uBAAuB,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;aAClC;iBAAM,IAAI,EAAE,CAAC,IAAI,KAAK,cAAc,EAAE;gBACrC,sBAAsB,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;aACjC;SACF;aAAM;;YAEL,IAAI,EAAE,CAAC,IAAI,KAAK,YAAY,EAAE;gBAC5B,kBAAkB,CAAC,EAAE,CAAC,CAAA;;gBAEtB,CAAC,CAAC,SAAS,CACT,IAAI,CAAC,KAAM,GAAG,MAAM,EACpB,IAAI,CAAC,KAAM,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,EACpC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CACxB,CAAA;aACF;iBAAM;gBACL,KAAK,CAAC,GAAG,MAAM,8CAA8C,EAAE,IAAI,CAAC,CAAA;aACrE;SACF;KACF;IAED,SAAS,uBAAuB,CAC9B,OAAsB,EACtB,IAAoB,EACpB,OAAgB,EAChB,OAAsB,EAAE;QAExB,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,UAAU,EAAE,CAAA;;YAEtB,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,KAAM,GAAG,MAAM,EAAE,OAAO,CAAC,GAAI,GAAG,MAAM,EAAE,OAAO,CAAC,CAAA;SACrE;QAED,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,UAAU,EAAE;YAClC,IAAI,MAA8B,CAAA;YAClC,IAAI,GAAoC,CAAA;YACxC,IAAI,YAAoC,CAAA;YACxC,IAAI,CAAC,CAAC,IAAI,KAAK,gBAAgB,EAAE;gBAC/B,IAAI,CAAC,CAAC,GAAG,CAAC,KAAM,KAAK,CAAC,CAAC,KAAK,CAAC,KAAM,EAAE;;oBAEnC,MAAM,GAAG,CAAC,CAAC,GAAiB,CAAA;oBAC5B,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;;wBAEjC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAA;qBACzB;yBAAM,IACL,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,mBAAmB;wBACpC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,EAClC;;wBAEA,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;wBAC7B,YAAY,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAA;qBAC7B;iBACF;qBAAM;oBACL,GAAG,GAAG,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAI,CAAC,CAAC,GAAkB,CAAC,IAAI,CAAA;oBACrD,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;;wBAEjC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAA;qBACjB;yBAAM,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,eAAe,EAAE;wBAC3C,uBAAuB,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,CAAC,CAAC,CAAA;qBAChE;yBAAM,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,cAAc,EAAE;wBAC1C,sBAAsB,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,GAAG,IAAI,EAAE,GAAG,CAAC,CAAC,CAAA;qBAC/D;yBAAM,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,mBAAmB,EAAE;wBAC/C,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,EAAE;;4BAEtC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAA;4BACrB,YAAY,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAA;yBAC7B;6BAAM,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,eAAe,EAAE;4BAChD,uBAAuB,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;gCACnD,GAAG,IAAI;gCACP,CAAC,GAAG,EAAE,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC;6BACrB,CAAC,CAAA;yBACH;6BAAM,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE;4BAC/C,sBAAsB,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;gCAClD,GAAG,IAAI;gCACP,CAAC,GAAG,EAAE,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC;6BACrB,CAAC,CAAA;yBACH;6BAAM,CAEN;qBACF;iBACF;aACF;iBAAM;;gBAEL,KAAK,CAAC,wDAAwD,EAAE,CAAC,CAAC,CAAA;aACnE;YACD,IAAI,MAAM,EAAE;gBACV,kBAAkB,CAAC,MAAM,CAAC,CAAA;;gBAE1B,MAAM,MAAM,GAAG,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,CAAA;gBAC1C,MAAM,MAAM,GAAGC,eAAQ,CAAC,GAAG,CAAC;sBACxB,IAAI,GAAG,GAAG;sBACV,GAAG;0BACH,IAAI,CAAC,GAAG,CAAC;0BACT,IAAI,MAAM,CAAC,IAAI,GAAG,CAAA;gBACtB,MAAM,UAAU,GAAG,YAAY,GAAG,KAAK,IAAI,CAAC,YAAY,CAAC,EAAE,GAAG,EAAE,CAAA;gBAChE,CAAC,CAAC,UAAU,CACV,IAAI,CAAC,GAAI,GAAG,MAAM,EAClB,QAAQ,MAAM,CAAC,IAAI,MAAM,MAAM,CAC7B,OAAO,CACR,IAAI,MAAM,KAAK,MAAM,GAAG,UAAU,GAAG,CACvC,CAAA;aACF;SACF;KACF;IAED,SAAS,sBAAsB,CAC7B,OAAqB,EACrB,IAAoB,EACpB,OAAgB,EAChB,OAAsB,EAAE;QAExB,IAAI,CAAC,OAAO,EAAE;;YAEZ,OAAO,GAAG,UAAU,EAAE,CAAA;YACtB,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,KAAM,GAAG,MAAM,EAAE,OAAO,CAAC,GAAI,GAAG,MAAM,EAAE,OAAO,CAAC,CAAA;SACrE;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAChD,MAAM,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;YAC7B,IAAI,CAAC,CAAC;gBAAE,SAAQ;YAChB,IAAI,MAA8B,CAAA;YAClC,IAAI,YAAoC,CAAA;YACxC,IAAI,CAAC,CAAC,IAAI,KAAK,YAAY,EAAE;;gBAE3B,MAAM,GAAG,CAAC,CAAA;aACX;iBAAM,IAAI,CAAC,CAAC,IAAI,KAAK,mBAAmB,EAAE;;gBAEzC,MAAM,GAAG,CAAC,CAAC,IAAkB,CAAA;gBAC7B,YAAY,GAAG,CAAC,CAAC,KAAK,CAAA;aACvB;iBAAM,IAAI,CAAC,CAAC,IAAI,KAAK,aAAa,EAAE;;gBAEnC,KAAK,CAAC,wDAAwD,EAAE,CAAC,CAAC,CAAA;aACnE;iBAAM,IAAI,CAAC,CAAC,IAAI,KAAK,eAAe,EAAE;gBACrC,uBAAuB,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,CAAA;aACxD;iBAAM,IAAI,CAAC,CAAC,IAAI,KAAK,cAAc,EAAE;gBACpC,sBAAsB,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,CAAA;aACvD;YACD,IAAI,MAAM,EAAE;gBACV,kBAAkB,CAAC,MAAM,CAAC,CAAA;;gBAE1B,MAAM,MAAM,GAAG,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,CAAA;gBAC1C,MAAM,UAAU,GAAG,YAAY,GAAG,KAAK,IAAI,CAAC,YAAY,CAAC,EAAE,GAAG,EAAE,CAAA;gBAChE,CAAC,CAAC,UAAU,CACV,IAAI,CAAC,GAAI,GAAG,MAAM,EAClB,QAAQ,MAAM,CAAC,IAAI,MAAM,MAAM,CAC7B,OAAO,CACR,IAAI,MAAM,KAAK,CAAC,GAAG,UAAU,GAAG,CAClC,CAAA;aACF;SACF;KACF;IAQD,SAAS,YAAY,CAAC,MAAc,EAAE,IAAmB;QACvD,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;gBACtB,IAAIC,cAAO,CAAC,GAAG,CAAC,EAAE;oBAChB,MAAM,GAAG,IAAI,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAA;iBAChE;qBAAM;oBACL,MAAM,IAAI,WAAW,CAAC,GAAG,CAAC,CAAA;iBAC3B;aACF;SACF;QACD,OAAO,MAAM,CAAA;KACd;IAED,SAAS,WAAW,CAAC,GAAoB;QACvC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YAC3B,OAAO,IAAI,GAAG,GAAG,CAAA;SAClB;aAAM,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YAClC,OAAO,IAAI,GAAG,EAAE,CAAA;SACjB;aAAM;YACL,OAAO,IAAI,CAAC,GAAG,CAAC,CAAA;SACjB;KACF;IAED,SAAS,SAAS,CAChB,KAAY,EACZ,EAAc,EACd,MAAY,EACZ,WAAmB;QAEnB,IAAIC,aAAM,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE;YAC1B,MAAM,WAAW,GAAG,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,CAAA;YAClC,IAAI,WAAW,EAAE;gBACf,MAAM,MAAM,GAAG,WAAW,KAAK,MAAM,CAAA;gBACrC,IAAIC,6BAAgB,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,SAAS,EAAE;;;oBAGhD,IACE,CAAE,MAAc,CAAC,SAAS;wBAC1BC,sCAAyB,CAAC,MAAM,EAAE,WAAW,CAAC,EAC9C;wBACA,IAAI,MAAM,EAAE;4BACV,IAAI,WAAW,EAAE;;;gCAGf,0BAA0B,CAAC,EAAE,CAAC,CAAA;gCAC9B,CAAC,CAAC,UAAU,CACV,EAAE,CAAC,GAAI,GAAG,MAAM,EAChB,aAAa,qBAAqB,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAC9C,CAAA;6BACF;iCAAM;;gCAEL,CAAC,CAAC,UAAU,CACV,EAAE,CAAC,GAAI,GAAG,MAAM,EAChB,KAAKC,wBAAiB,CAAC,qBAAqB,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,CACzD,CAAA;6BACF;yBACF;6BAAM;;4BAEL,CAAC,CAAC,UAAU,CAAC,EAAE,CAAC,GAAI,GAAG,MAAM,EAAE,KAAK,EAAE,CAAC,IAAI,QAAQ,CAAC,CAAA;yBACrD;qBACF;iBACF;qBAAM;oBACL,IAAI,MAAM,EAAE;wBACV,IAAI,WAAW,EAAE;;4BAEf,0BAA0B,CAAC,EAAE,CAAC,CAAA;4BAC9B,CAAC,CAAC,SAAS,CACT,EAAE,CAAC,KAAM,GAAG,MAAM,EAClB,EAAE,CAAC,GAAI,GAAG,MAAM,EAChB,WAAW,qBAAqB,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAC5C,CAAA;yBACF;6BAAM;;4BAEL,CAAC,CAAC,SAAS,CACT,EAAE,CAAC,KAAM,GAAG,MAAM,EAClB,EAAE,CAAC,GAAI,GAAG,MAAM,EAChBA,wBAAiB,CAAC,qBAAqB,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAClD,CAAA;yBACF;qBACF;yBAAM;;wBAEL,CAAC,CAAC,UAAU,CAAC,EAAE,CAAC,GAAI,GAAG,MAAM,EAAE,QAAQ,CAAC,CAAA;qBACzC;iBACF;aACF;YACD,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,KAAK,CAAA;KACb;IAED,MAAM,eAAe,GAAyB,EAAE,CAAA;IAChD,SAAS,0BAA0B,CAAC,EAAc;QAChD,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;YAC5C,eAAe,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;YAC/B,MAAM,SAAS,GAAG,qBAAqB,CAAC,EAAE,CAAC,IAAI,CAAC,CAAA;YAChD,CAAC,CAAC,YAAY,CACZ,MAAM,EACN,iBAAiB,SAAS,MAAM,MAAM,CACpC,OAAO,CACR,cAAc,SAAS,MAAM,CAC/B,CAAA;SACF;KACF;;IAGD,SAAS,CAAC,GAAG,EAAE,IAAI,CAAC,CACnB;IAACC,iBAAY,CAAC,GAAG,EAAE;QAClB,KAAK,CAAC,IAAU,EAAE,MAAa;YAC7B,MAAM,IAAI,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;;YAGlC,IAAIC,2BAAc,CAAC,IAAI,CAAC,EAAE;gBACxB,UAAU,CAAC,IAAI,EAAE,YAAY,GAAG,EAAE,EAAE,CAAA;gBACpCC,+BAAkB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAA;gBACzC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,gBAAgB,EAAE;oBACvC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;iBACrB;gBACD,OAAM;aACP;;YAGD,IAAI,IAAI,CAAC,IAAI,KAAK,aAAa,EAAE;gBAC/B,UAAU,CAAC,IAAI,EAAE,YAAY,GAAG,EAAE,EAAE,CAAA;gBACpC,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;oBAClD,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;iBAC5B;gBACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;gBACpB,OAAM;aACP;;YAGD,IAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB,IAAI,CAACD,2BAAc,CAAC,MAAO,CAAC,EAAE;gBAC9D,UAAU,CAAC,IAAI,EAAE,YAAY,GAAG,EAAE,EAAE,CAAA;gBACpC,SAAS,CAAC,IAAI,CAAC,CAAA;gBACf,OAAM;aACP;;YAGD,IACE,MAAM;gBACN,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;gBAC5B,MAAM,CAAC,IAAI,KAAK,gBAAgB;gBAChC,MAAM,CAAC,IAAI,KAAK,qBAAqB;gBACrC,MAAM,CAAC,IAAI,KAAK,iBAAiB,EACjC;gBACA,OAAO,IAAI,CAAC,IAAI,EAAE,CAAA;aACnB;YAED,IACE,IAAI,CAAC,IAAI,KAAK,YAAY;;gBAE1B,EAAE,WAAW,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC;gBACjDE,mCAAsB,CAAC,IAAI,EAAE,MAAO,EAAE,WAAW,CAAC;gBAClD,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,EACtB;;gBAEA,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,CAAA;gBACzB,OAAO,CAAC,EAAE,EAAE;oBACV,IAAI,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,MAAO,EAAE,WAAW,CAAC,EAAE;wBACxD,OAAM;qBACP;iBACF;aACF;YAED,IAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,YAAY,EAAE;gBACvE,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAA;gBAE/B,MAAM,OAAO,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAA;gBACzC,IAAI,OAAO,KAAK,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,oBAAoB,CAAC,EAAE;oBAChE,OAAO,KAAK,CACV,GAAG,OAAO,0CAA0C;wBAClD,yBAAyB,EAC3B,IAAI,CACL,CAAA;iBACF;gBAED,IAAI,MAAM,KAAK,YAAY,EAAE;oBAC3B,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAM,GAAG,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAI,GAAG,MAAM,CAAC,CAAA;oBAChE,WAAW,GAAG,IAAI,CAAA;iBACnB;;gBAGD,IAAI,MAAM,KAAK,MAAM,EAAE;oBACrB,KAAK,CACH,oCAAoC;wBAClC,OAAO,QAAQ,sBAAsB,EACvC,IAAI,CACL,CAAA;iBACF;gBACD,IAAI,MAAM,KAAK,UAAU,EAAE;oBACzB,KAAK,CACH,uCAAuC;wBACrC,OAAO,QAAQ,sBAAsB,EACvC,IAAI,CACL,CAAA;iBACF;aACF;SACF;QACD,KAAK,CAAC,IAAU,EAAE,MAAa;YAC7B,MAAM,IAAI,WAAW,CAAC,GAAG,EAAE,CAAA;YAC3B,IACE,CAAC,IAAI,CAAC,IAAI,KAAK,gBAAgB,IAAI,CAACF,2BAAc,CAAC,MAAO,CAAC;gBAC3DA,2BAAc,CAAC,IAAI,CAAC,EACpB;gBACA,UAAU,CAAC,GAAG,EAAE,CAAA;gBAChB,YAAY,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI,CAAA;aACzD;YACD,IAAI,IAAI,KAAK,WAAW,EAAE;gBACxB,WAAW,GAAG,SAAS,CAAA;aACxB;SACF;KACF,CAAC,CAAA;IAEF,OAAO;QACL,QAAQ,EAAE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,GAAG,IAAI,SAAS,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC;QACvE,eAAe,EAAE,CAAC,GAAG,eAAe,CAAC;KACtC,CAAA;AACH,CAAC;AAED,MAAM,QAAQ,GAAG,+CAA+C,CAAA;AAChE,MAAM,SAAS,GAA4B,EAAE,CAAA;AAE7C,SAAS,gBAAgB;;IAEvB,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;QACjC,OAAM;KACP;IACD,QAAQ,CACN,oDAAoD;QAClD,qEAAqE;QACrE,uFAAuF;QACvF,2CAA2C,QAAQ,GAAG,CACzD,CAAA;AACH,CAAC;AAED,SAAS,QAAQ,CAAC,GAAW;IAC3B,MAAM,UAAU,GACd,OAAO,OAAO,KAAK,WAAW,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,CAAA;IACzE,IAAI,CAAC,UAAU,IAAI,CAAC,KAAQ,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;QAC/C,SAAS,CAAC,GAAG,CAAC,GAAG,IAAI,CAAA;QACrB,IAAI,CAAC,GAAG,CAAC,CAAA;KACV;AACH,CAAC;AAED,SAAS,IAAI,CAAC,GAAW;IACvB,OAAO,CAAC,IAAI,CACV,6DAA6D,GAAG,WAAW,CAC5E,CAAA;AACH;;;;;;"}