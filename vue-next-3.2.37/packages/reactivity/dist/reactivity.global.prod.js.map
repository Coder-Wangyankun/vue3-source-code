{"version":3,"file":"reactivity.global.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/effectScope.ts","../src/dep.ts","../src/effect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts","../src/deferredComputed.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean\r\n): (key: string) => boolean {\r\n  const map: Record<string, boolean> = Object.create(null)\r\n  const list: Array<string> = str.split(',')\r\n  for (let i = 0; i < list.length; i++) {\r\n    map[list[i]] = true\r\n  }\r\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport { makeMap }\r\nexport * from './patchFlags'\r\nexport * from './shapeFlags'\r\nexport * from './slotFlags'\r\nexport * from './globalsWhitelist'\r\nexport * from './codeframe'\r\nexport * from './normalizeProp'\r\nexport * from './domTagConfig'\r\nexport * from './domAttrConfig'\r\nexport * from './escapeHtml'\r\nexport * from './looseEqual'\r\nexport * from './toDisplayString'\r\nexport * from './typeUtils'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nconst onRE = /^on[^a-z]/\r\nexport const isOn = (key: string) => onRE.test(key)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date => toTypeString(val) === '[object Date]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as any\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase()\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(\r\n  (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction((str: string) =>\r\n  str ? `on${capitalize(str)}` : ``\r\n)\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value\r\n  })\r\n}\r\n\r\nexport const toNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n        ? self\r\n        : typeof window !== 'undefined'\r\n        ? window\r\n        : typeof global !== 'undefined'\r\n        ? global\r\n        : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n","import { ReactiveEffect } from './effect'\r\nimport { warn } from './warning'\r\n\r\nlet activeEffectScope: EffectScope | undefined\r\n\r\nexport class EffectScope {\r\n  /**\r\n   * @internal\r\n   */\r\n  active = true\r\n  /**\r\n   * @internal\r\n   */\r\n  effects: ReactiveEffect[] = []\r\n  /**\r\n   * @internal\r\n   */\r\n  cleanups: (() => void)[] = []\r\n\r\n  /**\r\n   * only assigned by undetached scope\r\n   * @internal\r\n   */\r\n  parent: EffectScope | undefined\r\n  /**\r\n   * record undetached scopes\r\n   * @internal\r\n   */\r\n  scopes: EffectScope[] | undefined\r\n  /**\r\n   * track a child scope's index in its parent's scopes array for optimized\r\n   * removal\r\n   * @internal\r\n   */\r\n  private index: number | undefined\r\n\r\n  constructor(detached = false) {\r\n    if (!detached && activeEffectScope) {\r\n      this.parent = activeEffectScope\r\n      this.index =\r\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\r\n          this\r\n        ) - 1\r\n    }\r\n  }\r\n\r\n  run<T>(fn: () => T): T | undefined {\r\n    if (this.active) {\r\n      const currentEffectScope = activeEffectScope\r\n      try {\r\n        activeEffectScope = this\r\n        return fn()\r\n      } finally {\r\n        activeEffectScope = currentEffectScope\r\n      }\r\n    } else if (__DEV__) {\r\n      warn(`cannot run an inactive effect scope.`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  on() {\r\n    activeEffectScope = this\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  off() {\r\n    activeEffectScope = this.parent\r\n  }\r\n\r\n  stop(fromParent?: boolean) {\r\n    if (this.active) {\r\n      let i, l\r\n      for (i = 0, l = this.effects.length; i < l; i++) {\r\n        this.effects[i].stop()\r\n      }\r\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n        this.cleanups[i]()\r\n      }\r\n      if (this.scopes) {\r\n        for (i = 0, l = this.scopes.length; i < l; i++) {\r\n          this.scopes[i].stop(true)\r\n        }\r\n      }\r\n      // nested scope, dereference from parent to avoid memory leaks\r\n      if (this.parent && !fromParent) {\r\n        // optimized O(1) removal\r\n        const last = this.parent.scopes!.pop()\r\n        if (last && last !== this) {\r\n          this.parent.scopes![this.index!] = last\r\n          last.index = this.index!\r\n        }\r\n      }\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nexport function effectScope(detached?: boolean) {\r\n  return new EffectScope(detached)\r\n}\r\n\r\nexport function recordEffectScope(\r\n  effect: ReactiveEffect,\r\n  scope: EffectScope | undefined = activeEffectScope\r\n) {\r\n  if (scope && scope.active) {\r\n    scope.effects.push(effect)\r\n  }\r\n}\r\n\r\nexport function getCurrentScope() {\r\n  return activeEffectScope\r\n}\r\n\r\nexport function onScopeDispose(fn: () => void) {\r\n  if (activeEffectScope) {\r\n    activeEffectScope.cleanups.push(fn)\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `onScopeDispose() is called when there is no active effect scope` +\r\n        ` to be associated with.`\r\n    )\r\n  }\r\n}\r\n","import { ReactiveEffect, trackOpBit } from './effect'\r\n\r\nexport type Dep = Set<ReactiveEffect> & TrackedMarkers\r\n\r\n/**\r\n * wasTracked and newTracked maintain the status for several levels of effect\r\n * tracking recursion. One bit per level is used to define whether the dependency\r\n * was/is tracked.\r\n */\r\ntype TrackedMarkers = {\r\n  /**\r\n   * wasTracked\r\n   */\r\n  w: number\r\n  /**\r\n   * newTracked\r\n   */\r\n  n: number\r\n}\r\n\r\nexport const createDep = (effects?: ReactiveEffect[]): Dep => {\r\n  const dep = new Set<ReactiveEffect>(effects) as Dep\r\n  dep.w = 0\r\n  dep.n = 0\r\n  return dep\r\n}\r\n\r\nexport const wasTracked = (dep: Dep): boolean => (dep.w & trackOpBit) > 0\r\n\r\nexport const newTracked = (dep: Dep): boolean => (dep.n & trackOpBit) > 0\r\n\r\nexport const initDepMarkers = ({ deps }: ReactiveEffect) => {\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].w |= trackOpBit // set was tracked\r\n    }\r\n  }\r\n}\r\n\r\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    let ptr = 0\r\n    for (let i = 0; i < deps.length; i++) {\r\n      const dep = deps[i]\r\n      if (wasTracked(dep) && !newTracked(dep)) {\r\n        dep.delete(effect)\r\n      } else {\r\n        deps[ptr++] = dep\r\n      }\r\n      // clear bits\r\n      dep.w &= ~trackOpBit\r\n      dep.n &= ~trackOpBit\r\n    }\r\n    deps.length = ptr\r\n  }\r\n}\r\n","import { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { extend, isArray, isIntegerKey, isMap } from '@vue/shared'\r\nimport { EffectScope, recordEffectScope } from './effectScope'\r\nimport {\r\n  createDep,\r\n  Dep,\r\n  finalizeDepMarkers,\r\n  initDepMarkers,\r\n  newTracked,\r\n  wasTracked\r\n} from './dep'\r\nimport { ComputedRefImpl } from './computed'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Sets to reduce memory overhead.\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<any, KeyToDepMap>()\r\n\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0\r\n\r\nexport let trackOpBit = 1\r\n\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n} & DebuggerEventExtraInfo\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  deps: Dep[] = []\r\n  parent: ReactiveEffect | undefined = undefined\r\n\r\n  /**\r\n   * Can be attached after creation\r\n   * @internal\r\n   */\r\n  computed?: ComputedRefImpl<T>\r\n  /**\r\n   * @internal\r\n   */\r\n  allowRecurse?: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  private deferStop?: boolean\r\n\r\n  onStop?: () => void\r\n  // dev only\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  // dev only\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public scheduler: EffectScheduler | null = null,\r\n    scope?: EffectScope\r\n  ) {\r\n    recordEffectScope(this, scope)\r\n  }\r\n\r\n  run() {\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    let parent: ReactiveEffect | undefined = activeEffect\r\n    let lastShouldTrack = shouldTrack\r\n    while (parent) {\r\n      if (parent === this) {\r\n        return\r\n      }\r\n      parent = parent.parent\r\n    }\r\n    try {\r\n      this.parent = activeEffect\r\n      activeEffect = this\r\n      shouldTrack = true\r\n\r\n      trackOpBit = 1 << ++effectTrackDepth\r\n\r\n      if (effectTrackDepth <= maxMarkerBits) {\r\n        initDepMarkers(this)\r\n      } else {\r\n        cleanupEffect(this)\r\n      }\r\n      return this.fn()\r\n    } finally {\r\n      if (effectTrackDepth <= maxMarkerBits) {\r\n        finalizeDepMarkers(this)\r\n      }\r\n\r\n      trackOpBit = 1 << --effectTrackDepth\r\n\r\n      activeEffect = this.parent\r\n      shouldTrack = lastShouldTrack\r\n      this.parent = undefined\r\n\r\n      if (this.deferStop) {\r\n        this.stop()\r\n      }\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    // stopped while running itself - defer the cleanup\r\n    if (activeEffect === this) {\r\n      this.deferStop = true\r\n    } else if (this.active) {\r\n      cleanupEffect(this)\r\n      if (this.onStop) {\r\n        this.onStop()\r\n      }\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nfunction cleanupEffect(effect: ReactiveEffect) {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n}\r\n\r\nexport interface ReactiveEffectOptions extends DebuggerOptions {\r\n  lazy?: boolean\r\n  scheduler?: EffectScheduler\r\n  scope?: EffectScope\r\n  allowRecurse?: boolean\r\n  onStop?: () => void\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options?: ReactiveEffectOptions\r\n): ReactiveEffectRunner {\r\n  if ((fn as ReactiveEffectRunner).effect) {\r\n    fn = (fn as ReactiveEffectRunner).effect.fn\r\n  }\r\n\r\n  const _effect = new ReactiveEffect(fn)\r\n  if (options) {\r\n    extend(_effect, options)\r\n    if (options.scope) recordEffectScope(_effect, options.scope)\r\n  }\r\n  if (!options || !options.lazy) {\r\n    _effect.run()\r\n  }\r\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\nexport function stop(runner: ReactiveEffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n\r\nexport let shouldTrack = true\r\nconst trackStack: boolean[] = []\r\n\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  if (shouldTrack && activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = createDep()))\r\n    }\r\n\r\n    const eventInfo = __DEV__\r\n      ? { effect: activeEffect, target, type, key }\r\n      : undefined\r\n\r\n    trackEffects(dep, eventInfo)\r\n  }\r\n}\r\n\r\nexport function trackEffects(\r\n  dep: Dep,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  let shouldTrack = false\r\n  if (effectTrackDepth <= maxMarkerBits) {\r\n    if (!newTracked(dep)) {\r\n      dep.n |= trackOpBit // set newly tracked\r\n      shouldTrack = !wasTracked(dep)\r\n    }\r\n  } else {\r\n    // Full cleanup mode.\r\n    shouldTrack = !dep.has(activeEffect!)\r\n  }\r\n\r\n  if (shouldTrack) {\r\n    dep.add(activeEffect!)\r\n    activeEffect!.deps.push(dep)\r\n    if (__DEV__ && activeEffect!.onTrack) {\r\n      activeEffect!.onTrack({\r\n        effect: activeEffect!,\r\n        ...debuggerEventExtraInfo!\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  let deps: (Dep | undefined)[] = []\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    deps = [...depsMap.values()]\r\n  } else if (key === 'length' && isArray(target)) {\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || key >= (newValue as number)) {\r\n        deps.push(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      deps.push(depsMap.get(key))\r\n    }\r\n\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    switch (type) {\r\n      case TriggerOpTypes.ADD:\r\n        if (!isArray(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        } else if (isIntegerKey(key)) {\r\n          // new index added to array -> length changes\r\n          deps.push(depsMap.get('length'))\r\n        }\r\n        break\r\n      case TriggerOpTypes.DELETE:\r\n        if (!isArray(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        }\r\n        break\r\n      case TriggerOpTypes.SET:\r\n        if (isMap(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n        }\r\n        break\r\n    }\r\n  }\r\n\r\n  const eventInfo = __DEV__\r\n    ? { target, type, key, newValue, oldValue, oldTarget }\r\n    : undefined\r\n\r\n  if (deps.length === 1) {\r\n    if (deps[0]) {\r\n      if (__DEV__) {\r\n        triggerEffects(deps[0], eventInfo)\r\n      } else {\r\n        triggerEffects(deps[0])\r\n      }\r\n    }\r\n  } else {\r\n    const effects: ReactiveEffect[] = []\r\n    for (const dep of deps) {\r\n      if (dep) {\r\n        effects.push(...dep)\r\n      }\r\n    }\r\n    if (__DEV__) {\r\n      triggerEffects(createDep(effects), eventInfo)\r\n    } else {\r\n      triggerEffects(createDep(effects))\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerEffects(\r\n  dep: Dep | ReactiveEffect[],\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  // spread into array for stabilization\r\n  const effects = isArray(dep) ? dep : [...dep]\r\n  for (const effect of effects) {\r\n    if (effect.computed) {\r\n      triggerEffect(effect, debuggerEventExtraInfo)\r\n    }\r\n  }\r\n  for (const effect of effects) {\r\n    if (!effect.computed) {\r\n      triggerEffect(effect, debuggerEventExtraInfo)\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerEffect(\r\n  effect: ReactiveEffect,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  if (effect !== activeEffect || effect.allowRecurse) {\r\n    if (__DEV__ && effect.onTrigger) {\r\n      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))\r\n    }\r\n    if (effect.scheduler) {\r\n      effect.scheduler()\r\n    } else {\r\n      effect.run()\r\n    }\r\n  }\r\n}\r\n","import {\r\n  reactive,\r\n  readonly,\r\n  toRaw,\r\n  ReactiveFlags,\r\n  Target,\r\n  readonlyMap,\r\n  reactiveMap,\r\n  shallowReactiveMap,\r\n  shallowReadonlyMap,\r\n  isReadonly,\r\n  isShallow\r\n} from './reactive'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport {\r\n  track,\r\n  trigger,\r\n  ITERATE_KEY,\r\n  pauseTracking,\r\n  resetTracking\r\n} from './effect'\r\nimport {\r\n  isObject,\r\n  hasOwn,\r\n  isSymbol,\r\n  hasChanged,\r\n  isArray,\r\n  isIntegerKey,\r\n  extend,\r\n  makeMap\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\nimport { warn } from './warning'\r\n\r\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\r\n\r\nconst builtInSymbols = new Set(\r\n  /*#__PURE__*/\r\n  Object.getOwnPropertyNames(Symbol)\r\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\r\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\r\n    // function\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol)\r\n)\r\n\r\nconst get = /*#__PURE__*/ createGetter()\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\r\n\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\r\n\r\nfunction createArrayInstrumentations() {\r\n  const instrumentations: Record<string, Function> = {}\r\n  // instrument identity-sensitive Array methods to account for possible reactive\r\n  // values\r\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      const arr = toRaw(this) as any\r\n      for (let i = 0, l = this.length; i < l; i++) {\r\n        track(arr, TrackOpTypes.GET, i + '')\r\n      }\r\n      // we run the method using the original args first (which may be reactive)\r\n      const res = arr[key](...args)\r\n      if (res === -1 || res === false) {\r\n        // if that didn't work, run it again using raw values.\r\n        return arr[key](...args.map(toRaw))\r\n      } else {\r\n        return res\r\n      }\r\n    }\r\n  })\r\n  // instrument length-altering mutation methods to avoid length being tracked\r\n  // which leads to infinite loops in some cases (#2137)\r\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      pauseTracking()\r\n      const res = (toRaw(this) as any)[key].apply(this, args)\r\n      resetTracking()\r\n      return res\r\n    }\r\n  })\r\n  return instrumentations\r\n}\r\n\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target: Target, key: string | symbol, receiver: object) {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\r\n      return shallow\r\n    } else if (\r\n      key === ReactiveFlags.RAW &&\r\n      receiver ===\r\n        (isReadonly\r\n          ? shallow\r\n            ? shallowReadonlyMap\r\n            : readonlyMap\r\n          : shallow\r\n          ? shallowReactiveMap\r\n          : reactiveMap\r\n        ).get(target)\r\n    ) {\r\n      return target\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n\r\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n      return Reflect.get(arrayInstrumentations, key, receiver)\r\n    }\r\n\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n      return res\r\n    }\r\n\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n\r\n    if (shallow) {\r\n      return res\r\n    }\r\n\r\n    if (isRef(res)) {\r\n      // ref unwrapping - skip unwrap for Array + integer key.\r\n      return targetIsArray && isIntegerKey(key) ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nconst set = /*#__PURE__*/ createSetter()\r\nconst shallowSet = /*#__PURE__*/ createSetter(true)\r\n\r\nfunction createSetter(shallow = false) {\r\n  return function set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object\r\n  ): boolean {\r\n    let oldValue = (target as any)[key]\r\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\r\n      return false\r\n    }\r\n    if (!shallow) {\r\n      if (!isShallow(value) && !isReadonly(value)) {\r\n        oldValue = toRaw(oldValue)\r\n        value = toRaw(value)\r\n      }\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        oldValue.value = value\r\n        return true\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\nfunction deleteProperty(target: object, key: string | symbol): boolean {\r\n  const hadKey = hasOwn(target, key)\r\n  const oldValue = (target as any)[key]\r\n  const result = Reflect.deleteProperty(target, key)\r\n  if (result && hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction has(target: object, key: string | symbol): boolean {\r\n  const result = Reflect.has(target, key)\r\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n    track(target, TrackOpTypes.HAS, key)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction ownKeys(target: object): (string | symbol)[] {\r\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\r\n  return Reflect.ownKeys(target)\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> = {\r\n  get,\r\n  set,\r\n  deleteProperty,\r\n  has,\r\n  ownKeys\r\n}\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> = {\r\n  get: readonlyGet,\r\n  set(target, key) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  },\r\n  deleteProperty(target, key) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const shallowReactiveHandlers = /*#__PURE__*/ extend(\r\n  {},\r\n  mutableHandlers,\r\n  {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n  }\r\n)\r\n\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nexport const shallowReadonlyHandlers = /*#__PURE__*/ extend(\r\n  {},\r\n  readonlyHandlers,\r\n  {\r\n    get: shallowReadonlyGet\r\n  }\r\n)\r\n","import { toRaw, ReactiveFlags, toReactive, toReadonly } from './reactive'\r\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { capitalize, hasOwn, hasChanged, toRawType, isMap } from '@vue/shared'\r\n\r\nexport type CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  isReadonly = false,\r\n  isShallow = false\r\n) {\r\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n  // of the value\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (key !== rawKey) {\r\n      track(rawTarget, TrackOpTypes.GET, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.GET, rawKey)\r\n  }\r\n  const { has } = getProto(rawTarget)\r\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n  if (has.call(rawTarget, key)) {\r\n    return wrap(target.get(key))\r\n  } else if (has.call(rawTarget, rawKey)) {\r\n    return wrap(target.get(rawKey))\r\n  } else if (target !== rawTarget) {\r\n    // #3602 readonly(reactive(Map))\r\n    // ensure that the nested reactive `Map` can do tracking for itself\r\n    target.get(key)\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\r\n  const target = (this as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (key !== rawKey) {\r\n      track(rawTarget, TrackOpTypes.HAS, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\r\n  }\r\n  return key === rawKey\r\n    ? target.has(key)\r\n    : target.has(key) || target.has(rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections, isReadonly = false) {\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(target, 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  if (!hadKey) {\r\n    target.add(value)\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  target.set(key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.delete(key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? isMap(target)\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.clear()\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown\r\n  ) {\r\n    const observed = this as any\r\n    const target = observed[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    return target.forEach((value: unknown, key: unknown) => {\r\n      // important: make sure the callback is\r\n      // 1. invoked with the reactive map as `this` and 3rd arg\r\n      // 2. the value received should be a corresponding reactive/readonly.\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    })\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  isShallow: boolean\r\n) {\r\n  return function (\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = (this as any)[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const targetIsMap = isMap(rawTarget)\r\n    const isPair =\r\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\r\n    const isKeyOnly = method === 'keys' && targetIsMap\r\n    const innerIterator = target[method](...args)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        rawTarget,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function (this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this)\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE ? false : this\r\n  }\r\n}\r\n\r\nfunction createInstrumentations() {\r\n  const mutableInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n  }\r\n\r\n  const shallowInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, false, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n  }\r\n\r\n  const readonlyInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, false)\r\n  }\r\n\r\n  const shallowReadonlyInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, true)\r\n  }\r\n\r\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\n  iteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      false\r\n    )\r\n    readonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      false\r\n    )\r\n    shallowInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      true\r\n    )\r\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      true\r\n    )\r\n  })\r\n\r\n  return [\r\n    mutableInstrumentations,\r\n    readonlyInstrumentations,\r\n    shallowInstrumentations,\r\n    shallowReadonlyInstrumentations\r\n  ]\r\n}\r\n\r\nconst [\r\n  mutableInstrumentations,\r\n  readonlyInstrumentations,\r\n  shallowInstrumentations,\r\n  shallowReadonlyInstrumentations\r\n] = /* #__PURE__*/ createInstrumentations()\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? isReadonly\r\n      ? shallowReadonlyInstrumentations\r\n      : shallowInstrumentations\r\n    : isReadonly\r\n    ? readonlyInstrumentations\r\n    : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n}\r\n\r\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\r\n  {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n  }\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`\r\n    )\r\n  }\r\n}\r\n","import { isObject, toRawType, def } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers,\r\n  shallowReadonlyCollectionHandlers\r\n} from './collectionHandlers'\r\nimport type { UnwrapRefSimple, Ref, RawSymbol } from './ref'\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive',\r\n  IS_READONLY = '__v_isReadonly',\r\n  IS_SHALLOW = '__v_isShallow',\r\n  RAW = '__v_raw'\r\n}\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const reactiveMap = new WeakMap<Target, any>()\r\nexport const shallowReactiveMap = new WeakMap<Target, any>()\r\nexport const readonlyMap = new WeakMap<Target, any>()\r\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\r\n\r\nconst enum TargetType {\r\n  INVALID = 0,\r\n  COMMON = 1,\r\n  COLLECTION = 2\r\n}\r\n\r\nfunction targetTypeMap(rawType: string) {\r\n  switch (rawType) {\r\n    case 'Object':\r\n    case 'Array':\r\n      return TargetType.COMMON\r\n    case 'Map':\r\n    case 'Set':\r\n    case 'WeakMap':\r\n    case 'WeakSet':\r\n      return TargetType.COLLECTION\r\n    default:\r\n      return TargetType.INVALID\r\n  }\r\n}\r\n\r\nfunction getTargetType(value: Target) {\r\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\r\n    ? TargetType.INVALID\r\n    : targetTypeMap(toRawType(value))\r\n}\r\n\r\n// only unwrap nested ref\r\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\r\n\r\n/**\r\n * Creates a reactive copy of the original object.\r\n *\r\n * The reactive conversion is \"deep\"â€”it affects all nested properties. In the\r\n * ES2015 Proxy based implementation, the returned proxy is **not** equal to the\r\n * original object. It is recommended to work exclusively with the reactive\r\n * proxy and avoid relying on the original object.\r\n *\r\n * A reactive object also automatically unwraps refs contained in it, so you\r\n * don't need to use `.value` when accessing and mutating their value:\r\n *\r\n * ```js\r\n * const count = ref(0)\r\n * const obj = reactive({\r\n *   count\r\n * })\r\n *\r\n * obj.count++\r\n * obj.count // -> 1\r\n * count.value // -> 1\r\n * ```\r\n */\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  if (isReadonly(target)) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers,\r\n    reactiveMap\r\n  )\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\n\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\n\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nexport function shallowReactive<T extends object>(\r\n  target: T\r\n): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers,\r\n    shallowReactiveMap\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n  : T extends ReadonlyMap<infer K, infer V>\r\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n  : T extends WeakMap<infer K, infer V>\r\n  ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n  : T extends Set<infer U>\r\n  ? ReadonlySet<DeepReadonly<U>>\r\n  : T extends ReadonlySet<infer U>\r\n  ? ReadonlySet<DeepReadonly<U>>\r\n  : T extends WeakSet<infer U>\r\n  ? WeakSet<DeepReadonly<U>>\r\n  : T extends Promise<infer U>\r\n  ? Promise<DeepReadonly<U>>\r\n  : T extends Ref<infer U>\r\n  ? Readonly<Ref<DeepReadonly<U>>>\r\n  : T extends {}\r\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n  : Readonly<T>\r\n\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nexport function readonly<T extends object>(\r\n  target: T\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers,\r\n    readonlyMap\r\n  )\r\n}\r\n\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    shallowReadonlyCollectionHandlers,\r\n    shallowReadonlyMap\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>,\r\n  proxyMap: WeakMap<Target, any>\r\n) {\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const existingProxy = proxyMap.get(target)\r\n  if (existingProxy) {\r\n    return existingProxy\r\n  }\r\n  // only specific value types can be observed.\r\n  const targetType = getTargetType(target)\r\n  if (targetType === TargetType.INVALID) {\r\n    return target\r\n  }\r\n  const proxy = new Proxy(\r\n    target,\r\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\r\n  )\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isShallow(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\r\n}\r\n\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\nexport function toRaw<T>(observed: T): T {\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport function markRaw<T extends object>(\r\n  value: T\r\n): T & { [RawSymbol]?: true } {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\nexport const toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value as Record<any, any>) : value\r\n","import {\r\n  activeEffect,\r\n  shouldTrack,\r\n  trackEffects,\r\n  triggerEffects\r\n} from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { isArray, hasChanged, IfAny } from '@vue/shared'\r\nimport {\r\n  isProxy,\r\n  toRaw,\r\n  isReactive,\r\n  toReactive,\r\n  isReadonly,\r\n  isShallow\r\n} from './reactive'\r\nimport type { ShallowReactiveMarker } from './reactive'\r\nimport { CollectionTypes } from './collectionHandlers'\r\nimport { createDep, Dep } from './dep'\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport declare const RawSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n}\r\n\r\ntype RefBase<T> = {\r\n  dep?: Dep\r\n  value: T\r\n}\r\n\r\nexport function trackRefValue(ref: RefBase<any>) {\r\n  if (shouldTrack && activeEffect) {\r\n    ref = toRaw(ref)\r\n    if (__DEV__) {\r\n      trackEffects(ref.dep || (ref.dep = createDep()), {\r\n        target: ref,\r\n        type: TrackOpTypes.GET,\r\n        key: 'value'\r\n      })\r\n    } else {\r\n      trackEffects(ref.dep || (ref.dep = createDep()))\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerRefValue(ref: RefBase<any>, newVal?: any) {\r\n  ref = toRaw(ref)\r\n  if (ref.dep) {\r\n    if (__DEV__) {\r\n      triggerEffects(ref.dep, {\r\n        target: ref,\r\n        type: TriggerOpTypes.SET,\r\n        key: 'value',\r\n        newValue: newVal\r\n      })\r\n    } else {\r\n      triggerEffects(ref.dep)\r\n    }\r\n  }\r\n}\r\n\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\nexport function ref<T extends object>(\r\n  value: T\r\n): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value, false)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\n\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\nexport function shallowRef<T extends object>(\r\n  value: T\r\n): T extends Ref ? T : ShallowRef<T>\r\nexport function shallowRef<T>(value: T): ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(value: T, public readonly __v_isShallow: boolean) {\r\n    this._rawValue = __v_isShallow ? value : toRaw(value)\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    return this._value\r\n  }\r\n\r\n  set value(newVal) {\r\n    const useDirectValue =\r\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\r\n    newVal = useDirectValue ? newVal : toRaw(newVal)\r\n    if (hasChanged(newVal, this._rawValue)) {\r\n      this._rawValue = newVal\r\n      this._value = useDirectValue ? newVal : toReactive(newVal)\r\n      triggerRefValue(this, newVal)\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerRef(ref: Ref) {\r\n  triggerRefValue(ref, __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport function unref<T>(ref: T | Ref<T>): T {\r\n  return isRef(ref) ? (ref.value as any) : ref\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  }\r\n}\r\n\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nclass CustomRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\r\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\r\n\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(factory: CustomRefFactory<T>) {\r\n    const { get, set } = factory(\r\n      () => trackRefValue(this),\r\n      () => triggerRefValue(this)\r\n    )\r\n    this._get = get\r\n    this._set = set\r\n  }\r\n\r\n  get value() {\r\n    return this._get()\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._set(newVal)\r\n  }\r\n}\r\n\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  return new CustomRefImpl(factory) as any\r\n}\r\n\r\nexport type ToRefs<T = any> = {\r\n  [K in keyof T]: ToRef<T[K]>\r\n}\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = isArray(object) ? new Array(object.length) : {}\r\n  for (const key in object) {\r\n    ret[key] = toRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nclass ObjectRefImpl<T extends object, K extends keyof T> {\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    private readonly _object: T,\r\n    private readonly _key: K,\r\n    private readonly _defaultValue?: T[K]\r\n  ) {}\r\n\r\n  get value() {\r\n    const val = this._object[this._key]\r\n    return val === undefined ? (this._defaultValue as T[K]) : val\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._object[this._key] = newVal\r\n  }\r\n}\r\n\r\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K\r\n): ToRef<T[K]>\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue: T[K]\r\n): ToRef<Exclude<T[K], undefined>>\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue?: T[K]\r\n): ToRef<T[K]> {\r\n  const val = object[key]\r\n  return isRef(val)\r\n    ? val\r\n    : (new ObjectRefImpl(object, key, defaultValue) as any)\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Note that api-extractor somehow refuses to include `declare module`\r\n * augmentations in its generated d.ts, so we have to manually append them\r\n * to the final generated d.ts in our build process.\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: T[K] extends Ref<infer V>\r\n    ? V\r\n    : // if `V` is `unknown` that means it does not extend `Ref` and is undefined\r\n    T[K] extends Ref<infer V> | undefined\r\n    ? unknown extends V\r\n      ? undefined\r\n      : V | undefined\r\n    : T[K]\r\n}\r\n\r\nexport type UnwrapRef<T> = T extends ShallowRef<infer V>\r\n  ? V\r\n  : T extends Ref<infer V>\r\n  ? UnwrapRefSimple<V>\r\n  : UnwrapRefSimple<T>\r\n\r\nexport type UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | CollectionTypes\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  | { [RawSymbol]?: true }\r\n  ? T\r\n  : T extends Array<any>\r\n  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n  : T extends object & { [ShallowReactiveMarker]?: never }\r\n  ? {\r\n      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\r\n    }\r\n  : T\r\n","import { DebuggerOptions, ReactiveEffect } from './effect'\r\nimport { Ref, trackRefValue, triggerRefValue } from './ref'\r\nimport { isFunction, NOOP } from '@vue/shared'\r\nimport { ReactiveFlags, toRaw } from './reactive'\r\nimport { Dep } from './dep'\r\n\r\ndeclare const ComputedRefSymbol: unique symbol\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n  [ComputedRefSymbol]: true\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (...args: any[]) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\r\n\r\n  public _dirty = true\r\n  public _cacheable: boolean\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly: boolean,\r\n    isSSR: boolean\r\n  ) {\r\n    this.effect = new ReactiveEffect(getter, () => {\r\n      if (!this._dirty) {\r\n        this._dirty = true\r\n        triggerRefValue(this)\r\n      }\r\n    })\r\n    this.effect.computed = this\r\n    this.effect.active = this._cacheable = !isSSR\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  get value() {\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    const self = toRaw(this)\r\n    trackRefValue(self)\r\n    if (self._dirty || !self._cacheable) {\r\n      self._dirty = false\r\n      self._value = self.effect.run()!\r\n    }\r\n    return self._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue)\r\n  }\r\n}\r\n\r\nexport function computed<T>(\r\n  getter: ComputedGetter<T>,\r\n  debugOptions?: DebuggerOptions\r\n): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\r\n\r\n  if (__DEV__ && debugOptions && !isSSR) {\r\n    cRef.effect.onTrack = debugOptions.onTrack\r\n    cRef.effect.onTrigger = debugOptions.onTrigger\r\n  }\r\n\r\n  return cRef as any\r\n}\r\n","import { Dep } from './dep'\r\nimport { ReactiveEffect } from './effect'\r\nimport { ComputedGetter, ComputedRef } from './computed'\r\nimport { ReactiveFlags, toRaw } from './reactive'\r\nimport { trackRefValue, triggerRefValue } from './ref'\r\n\r\nconst tick = /*#__PURE__*/ Promise.resolve()\r\nconst queue: any[] = []\r\nlet queued = false\r\n\r\nconst scheduler = (fn: any) => {\r\n  queue.push(fn)\r\n  if (!queued) {\r\n    queued = true\r\n    tick.then(flush)\r\n  }\r\n}\r\n\r\nconst flush = () => {\r\n  for (let i = 0; i < queue.length; i++) {\r\n    queue[i]()\r\n  }\r\n  queue.length = 0\r\n  queued = false\r\n}\r\n\r\nclass DeferredComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  private _dirty = true\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY] = true\r\n\r\n  constructor(getter: ComputedGetter<T>) {\r\n    let compareTarget: any\r\n    let hasCompareTarget = false\r\n    let scheduled = false\r\n    this.effect = new ReactiveEffect(getter, (computedTrigger?: boolean) => {\r\n      if (this.dep) {\r\n        if (computedTrigger) {\r\n          compareTarget = this._value\r\n          hasCompareTarget = true\r\n        } else if (!scheduled) {\r\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value\r\n          scheduled = true\r\n          hasCompareTarget = false\r\n          scheduler(() => {\r\n            if (this.effect.active && this._get() !== valueToCompare) {\r\n              triggerRefValue(this)\r\n            }\r\n            scheduled = false\r\n          })\r\n        }\r\n        // chained upstream computeds are notified synchronously to ensure\r\n        // value invalidation in case of sync access; normal effects are\r\n        // deferred to be triggered in scheduler.\r\n        for (const e of this.dep) {\r\n          if (e.computed instanceof DeferredComputedRefImpl) {\r\n            e.scheduler!(true /* computedTrigger */)\r\n          }\r\n        }\r\n      }\r\n      this._dirty = true\r\n    })\r\n    this.effect.computed = this as any\r\n  }\r\n\r\n  private _get() {\r\n    if (this._dirty) {\r\n      this._dirty = false\r\n      return (this._value = this.effect.run()!)\r\n    }\r\n    return this._value\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    return toRaw(this)._get()\r\n  }\r\n}\r\n\r\nexport function deferredComputed<T>(getter: () => T): ComputedRef<T> {\r\n  return new DeferredComputedRefImpl(getter) as any\r\n}\r\n"],"names":["makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","NOOP","extend","assign","hasOwnProperty","prototype","hasOwn","key","call","isArray","Array","isMap","toTypeString","isSymbol","isObject","objectToString","toString","value","isIntegerKey","parseInt","hasChanged","oldValue","is","activeEffectScope","EffectScope","constructor","detached","this","parent","index","scopes","push","run","fn","active","currentEffectScope","on","off","stop","fromParent","l","effects","cleanups","last","pop","recordEffectScope","effect","scope","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","targetMap","WeakMap","effectTrackDepth","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","undefined","lastShouldTrack","shouldTrack","deps","initDepMarkers","cleanupEffect","ptr","delete","finalizeDepMarkers","deferStop","onStop","trackStack","pauseTracking","resetTracking","track","target","type","depsMap","get","set","Map","trackEffects","debuggerEventExtraInfo","has","add","trigger","newValue","oldTarget","values","forEach","triggerEffects","computed","triggerEffect","allowRecurse","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","res","apply","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","readonly","reactive","createSetter","isShallow","hadKey","Number","result","mutableHandlers","deleteProperty","ownKeys","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","rawTarget","rawKey","wrap","toReadonly","toReactive","size","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","getTargetType","isExtensible","rawType","targetTypeMap","slice","toRawType","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","raw","trackRefValue","ref","triggerRefValue","newVal","r","__v_isRef","createRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","useDirectValue","unref","shallowUnwrapHandlers","CustomRefImpl","factory","_get","_set","ObjectRefImpl","_object","_key","_defaultValue","toRef","object","defaultValue","ComputedRefImpl","getter","_setter","isSSR","_dirty","_cacheable","self","tick","Promise","resolve","queue","queued","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","then","e","getterOrOptions","debugOptions","setter","onlyGetter","options","_effect","lazy","runner","bind","obj","defineProperty","configurable","enumerable","def","objectWithRefs","ret"],"mappings":"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"}